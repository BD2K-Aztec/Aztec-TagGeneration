Graphical pan-genome analysis with compressed suffix trees and the Burrowsâ€“Wheeler transform Motivation: Low-cost genome sequencing gives unprecedented complete information about the genetic structure of populations, and a population graph captures the variations between many individuals of a population. Recently, Marcus et al. proposed to use a compressed de Bruijn graph for representing an entire population of genomes. They devised an On log g time algorithm called splitMEM that constructs this graph directly (i.e. without using the uncompressed de Bruijn graph) based on a suffix tree, where n is the total length of the genomes and g is the length of the longest genome. Since the applicability of their algorithm is limited to rather small datasets, there is a strong need for space-efficient construction algorithms. Results: We present two algorithms that outperform splitMEM in theory and in practice. The first implements a novel linear-time suffix tree algorithm by means of a compressed suffix tree. The second algorithm uses the BurrowsWheeler transform to build the compressed de Bruijn graph in On log r time, where r is the size of the alphabet. To demonstrate the scalability of the algorithms , we applied it to seven human genomes. Availability and implementation:We implemented our new algorithms in C, using the library sdsl of. Software and test data are available at http:// www.uni-ulm.de/in/theo/research/seqana.html. Both algorithms use a variant of the semi-external algorithm described into construct the CST and the BWT, respectively. The experiments were conducted on a 64 bit Ubuntu 14.04.1 LTS (Kernel 3.13) system equipped with two ten-core Intel Xeon processors E52680v2 with 2.8 GHz and 128 GB of RAM (but no parallelism was used). All programs were compiled with g (version 4.8.2) using the provided makefile. With the CST-based and the BWT-based algorithm, respectively, we built compressed de Bruijn graphs for the 62 E.coli genomes (containing 310 million base pairs) listed in the Supplementary Material of, using the k-mer lengths 50, 100 and 1000.lists the results of our experiments. The run-times include the construction of the index, but similar to splitMEM it is unnecessary to rebuild the index for a fixed dataset and varying values of k. The peak memory usage reported inincludes the size of the index and the size of the compressed de Bruijn graph. Because of its large memory requirements, splitMEM was not able to build a compressed de Bruijn graph for all 62 strains of E.coli on our machine equipped with 128 GB of RAM. That is why we included a comparison based on the first 40 E.coli genomes (containing 199 million base pairs) of the dataset. The experimental results show that both of our algorithms use significantly less space (two orders of magnitude) than splitMEM. The CST-based algorithm is five times faster than splitMEM, while the BWT-based algorithm is more than an order of magnitude faster. It is worth mentioning that our two algorithms compute isomorphicbut not necessarily identicalcompressed de Bruijn graphs because the node identifiers may differ. To show the scalability of our new algorithms, we applied them to five different assemblies of the human reference genome (UCSC Genome Browser assembly IDs: hg16, hg17, hg18, hg19 and hg38) as well as the maternal and paternal haplotype of individual NA12878 (Utah female) of the 1000 Genomes Project; see. The compressed de Bruijn graphs of their first chromosomes (7xChr1, containing 1736 million base pairs) and the complete seven genomes (7xHG, containing 21 201 million base pairs) were built for the k-mer lengths 50, 100 and 1000. The experimental results inshow that the BWT-based algorithm clearly outperforms the CST-based algorithm. It took slightly over 6 h (22 000 s) to construct the index of the seven human genomes and less than 2 h (60007000 s) to build the graph with the Our CST-based algorithm mimics splitMEM in this respect, whereas the BWT-based algorithm treats the different occurrences of as if they were different characters. Assuming that is the second smallest character, this can be achieved as follows. As explained in the Supplementary Material, all right-maximal k-mers can be determined without the entire LCP-array if the algorithm inis used. If there are m 1 occurrences of in total and this algorithm starts with m 1 singleton intervals i::i; 2 i m, instead of the -interval 2::m, then the different occurrences of are treated as if they were different characters.We have presented two space-efficient methods to build the compressed de Bruijn graph from scratch. An experimental comparison with splitMEM showed that our algorithms are more than an order of magnitude faster than splitMEM while using significantly less space (two orders of magnitude). To demonstrate their scalability, we successfully applied them to seven complete human genomes. Consequently, it is now possible to use the compressed de Bruijn graph for much larger pan-genomes than before (consisting, e.g. of hundreds or even thousands of different strains of bacteria). Although the BWT-based algorithm is the clear winner of the comparison, CSTbased algorithms are still important. This is because STs play a central role in sequence analysis and most bioinformatics curricula comprise courses that cover this important data structure. It is therefore conceivable that a bioinformatician might be able to come up with a suffix tree algorithm that solves his/her problem at hand, but not with an algorithm that is based on the BWT and/or related data structures. If the space requirement of the ST is the bottleneck in the application, one can use a CST instead. CSTs with full functionality are, e.g. implemented in the succinct data structure library (sdsl) of. On the downside, extra features such as suffix skips are not implemented in those libraries so that a direct implementation of a suffix tree algorithm by means of a CST might not be possible. Future work includes parallel implementations of the algorithms. Moreover, it should be worthwhile to investigate the time-space tradeoff if one uses data structures that are optimized for highly repetitive texts, see Navarro and Ord n ez (2014) and the references therein. Most important, however, is to address the problem of compressing the compressed de Bruijn graph itself. (Our experiments show that for smaller k, the size of the graph can be larger than the size of the index, e.g. the graph for the seven human genomes and k 50 takes 1.65 bytes per base pair, whereas the BWT-index requires only 1.13 bytes per base pair.) Very recently, two Bloom filter methods were presented that can be used for this purpose. Solomon and Kingsford (2015) introduced the Sequence Bloom Tree to support sequence-based querying of large-scale collections of thousands of short-read sequencing experiments and applied it to the problem of finding conditions under which query transcripts are expressed. The second approach byis closer to the splitMEM approach. Their data structurethe Bloom Filter Trie (BFT)allows to efficiently store and traverse the uncompressed de Bruijn graph. In the Section Conclusion of their article,write Future work concerns the possibility to compress non-branching paths. .. This is exactly what splitMEM and our new algorithms do, so maybe the combination of both approaches will yield the ideal pan-genome representation.The first row in a block specifies the experiment. The second row shows the graph size in bytes per base pair. Rows 36 contain the numbers of edges, nodes, uniqueNodes and repeatNodes, respectively. Rows 710 show the average out-degree of the nodes as well as the average string length of the nodes, uniqueNodes and repeatNodes. The remaining rows (if applicable) contain the percentage of the nodes that are shared by x sequences. 
