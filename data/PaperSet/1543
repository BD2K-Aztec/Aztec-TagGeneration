Efficient construction of an assembly string graph using the FM-index Motivation: Sequence assembly is a difficult problem whose importance has grown again recently as the cost of sequencing has dramatically dropped. Most new sequence assembly software has started by building a de Bruijn graph, avoiding the overlap-based methods used previously because of the computational cost and complexity of these with very large numbers of short reads. Here, we show how to use suffix array-based methods that have formed the basis of recent very fast sequence mapping algorithms to find overlaps and generate assembly string graphs asymptotically faster than previously described algorithms. Results: Standard overlap assembly methods have time complexity O(N 2), where N is the sum of the lengths of the reads. We use the FerraginaManzini index (FM-index) derived from the Burrows Wheeler transform to find overlaps of length at least among a set of reads. As well as an approach that finds all overlaps then implements transitive reduction to produce a string graph, we show how to output directly only the irreducible overlaps, significantly shrinking memory requirements and reducing compute time to O(N), independent of depth. Overlap-based assembly methods naturally handle mixed length read sets, including capillary reads or long reads promised by the third generation sequencing technologies. The algorithms we present here pave the way for overlap-based assembly approaches to be developed that scale to whole vertebrate genome de novo assembly.The sequence assembly problem is one of the most important and difficult problems in bioinformatics. Most genomes, particularly eukaryotic genomes, are highly repetitive that complicates their assembly by obscuring true relationships between reads with many false options. To help disambiguate the true relationships between the reads from those induced by different copies of repeats, it is useful to construct a graph where all the copies of a repeat are collapsed into a single segment. Such a graph is commonly referred to as a repeat graph. This structure is a natural consequence of the de Bruijn graph method of sequence assembly as the deconstruction of the sequence reads into k-mers (short subsequences of the reads of length k) collapses repeats that share the same k-mer into a single vertex . An alternative formulation was proposed by Gene Myers and is called the string graph . The string graph is built by first constructing a graph of the pairwise overlaps between sequence reads and transforming it into a string graph by removing transitive edges. The string graph shares with the de Bruijn graph the property that repeats are To whom correspondence should be addressed. collapsed to a single unit without the need to first deconstruct the reads into k-mers. Because it is based on maximal overlaps, which are typically longer than de Bruijn k-mers, it also disambiguates shorter repeats that de Bruijn methods would only resolve in later processing steps (if at all). The string graph is much more expensive to construct, however, as the set of all pairwise, inexact overlaps between sequence reads must be found. For this reason, the majority of assemblers of short read sequence data have been based on the de Bruijn approach . A notable exception is the Edena assembler that uses a suffix array to compute exact overlaps between reads that are then used to construct the string graph. We address the construction of a string graph with a related approach by indexing the set of sequence reads using the BurrowsWheeler transform(BWT)/Ferragina Manzini(FM)-index, which has recently been used for the short read alignment problem . We show how to efficiently compute the set of overlaps needed to construct the string graph from the FMindex. Furthermore, we show that the string graph can be constructed directly using the FM-index without the need for explicitly finding all overlaps and a subsequent transitive removal step, yielding a space and time efficient construction algorithm.As a proof of concept, we implemented the above algorithms. The program is broken into three stages: index, overlap and assemble. The index stage constructs the suffix array and FM-index for a set of sequence reads, the overlap stage computes the set of overlaps between the reads and the assemble stage builds the string graph, performs transitive reduction if necessary, then compacts unambiguous paths in the graph and writes out a set of contigs. We tested the performance of the algorithms with two sets of simulations. In both sets of simulations, we compared the exhaustive overlap algorithm (which constructs the set of all overlaps) and the direct construction algorithm (which only outputs overlaps for irreducible edges). First, we simulated Escherichia coli read data with mean sequence depth from 5 to 100 to investigate the computational complexity of the overlap algorithms as a function of depth. After constructing the index for each dataset, we ran the overlap step in exhaustive and direct mode with = 27. The running times of these simulations are shown in. As expected,Overlap (exhaustive) Overlap (direct). The running time of the direct and exhaustive overlap algorithms for simulated E. coli data with sequence depth from 5 to 100. The direct overlap algorithm scales linearly with sequence depth. As the number of overlaps grows quadratically with sequence depth, the exhaustive overlap algorithm exhibits above-linear scaling. the direct overlap algorithm scales linearly with sequence depth. The exhaustive overlap algorithm exhibits the expected abovelinear scaling as the number of overlaps for a given read grows quadratically with sequence depth. To assess the quality of the resulting assembly, we assembled the data using the direct overlap algorithm and compared the contigs to the reference. For each level of coverage, we selected to maximize the assembly N50 value. The N50 values ranged from 1.7 kbp (5 data, = 17) to 80 kbp (100 data, = 85). We aligned the contigs to the reference genome with bwa-sw and found that no contigs were misassembled. We also simulated data from human chromosomes 22, 15, 7 and 2 to assess how the algorithms scale with the size of the genome. We pre-processed the chromosome sequences to remove sequence gaps then generated 100 bp error-free reads randomly at an average coverage of 20 for each chromosome. The results of the simulations are summarized in. The running time of the exhaustive and direct overlap algorithms are comparable. As the sequence depth is fixed at 20, both overlap algorithms scale linearly with the size of the input data. The final stage of the algorithm, building the string graph and constructing contigs, is much shorter for the direct algorithm as the transitive reduction step does not need to be performed. In addition, this step requires considerably less memory as the initial graph constructed by the direct algorithm only contains irreducible edges. The bottleneck in terms of both computation time and memory usage is the indexing step, which builds the suffix array and FMindex for the entire read set. This required 8.5 h and 55 GB of memory for chromosome 2. Extrapolating to the size of the human genome indicates it would require 4.5 days and 700 GB of memory to index 20 sequence data. While the computational time is tractable, the amount of memory required is not practical for the routine assembly of human genomes. We address ways to reduce the computational requirements in Section 5.For the overlap and assemble rows,-e and-d indicate the exhaustive and direct algorithms, respectively. The last column is the ratio between chromosome 2 and 22. 
