kcmbt a k_mer counter based on multiple burst trees motivation a massive number of bioinformatics applications require counting of k length sub strings in genetically important long strings a k_mer counter generates the frequencies of each k length substring in genome_sequences genome_assembly repeat detection multiple_sequence error_detection and many other related applications use a k_mer counter as a building_block very fast and efficient algorithms are necessary to count k_mers in large_data to be useful in such applications results we propose a novel trie based algorithm for this k_mer problem we compare our devised algorithm k_mer counter based on multiple burst trees kcmbt with available all well known algorithms our experimental_results show that kcmbt is around faster than the previous best performing algorithm kmc for human_genome dataset as another example our algorithm is around six times_faster than jellyfish overall kcmbt is faster than kmc on five benchmark_data when both the algorithms were run using multiple threads availability_and kcmbt is freely_available on github https github com abdulstring algorithms have been frequently used in bioinformatics as genomic_sequences can be represented by strings from an alphabet of distinct characters a substring of length k in a string is defined as a k_mer where k is a positive integer k_mers in genomic_sequences have been utilized to perform various analyses on the sequences numerous applications require counting the occurrences of particular k_mers a k_mer counter computes the abundance of every unique k_mer in a string or a set of strings it has become an elementary building_block for various bioinformatics applications frequencies of k_mers along with the coverage_information have been used in assembling genomic_sequences burst tries to store k_mers consideration of k x mers and unifying a k_mer and its count in a single unit currently kcmbt is the fastest k_mer algorithm experimental_results in conjunction with theoretical_analysis establish our statement we have compared our kcmbt implementation with previous best known algorithms kcmbt has been implemented in c and compiled with g along with optimization level we ran all the algorithms on a core dual intel_xeon processor e machine with gb ddr ram tb hdd gb sata ssd and red hat linux enterprise we have collected statistics for jellyfish kmc turtle dsk and our kcmbt we have chosen the latest working implementations of these algorithms most of these algorithms perform much better than their original versions published in their respective publications as kmc is currently the fastest k_mer algorithm we have attempted to compare with it more thoroughly for this purpose we have used the same input datasets that kmc used for experiments we have received all the information from their publication our input data_sets consist of five genomes with varied genome lengths fragaria vesca is the smallest data_set among these five and homo_sapiens is the largest one all of these genomes have multiple compressed fastq_files we have decompressed and concatenated them into one file so that every tool can handle them easily jellyfish requires an initial hash_table to store k_mers and their counts we supplied around more value than the exact unique k_mers count for example we used m hash size for h sapiens where we knew that the total number of unique k_mers is around millions some tools do not count k_mers with single occurrences we ran all of these implementations in such a way that they output all the k_mers turtle is another internal memory algorithm it has a necessary parameter for the expected number of unique k_mers to select the array size it uses for sorting and counting we have also used the same number as we have used for jellyfish turtle comes with three different tools scturtle cturtle and aturtle each one has two versions to support for maximum mer and mer computations scturtle counts k_mers with frequency cturtle only reports k_mers with frequency without showing their counts and aturtle gives k_mers with all frequencies along with their counts scturtle and cturtle support multiple threads but aturle is single threaded we have used aturtle for our experiments as it counts k_mers with all frequencies kmc is mainly an external memory or disk based algorithm but it has an option to make it an internal memory based algorithm original publication shows results for using gb_memory and gb_memory limit options later option performs better although we see that it uses less than allocated memory we have only included results for the gb_memory limit option dsk is another memory frugal disk based algorithm it can complete k_mer of human_genome using only gb of memory we chose a fixed gb of memory for all the tests although it did not use all of it kcmbt is a cache efficient algorithm it has several parameters which have substantial effects on the running time containers of burst trie contain k_mers if the container size is large many containers will be partially filled up and it will leave a huge memory unused on the other hand the depth of the trees will be low and consequently insertion and traversal will take less time also there will be less number of sorting as sorting is called when a container is full but if the container size is small memory requirement is low sorting and bursting are called frequently and the height of the tree will be high hence insertion and traversal need to compare many branches and the running time will be increased even if the container size is large consumed time may be high because of numerous cache misses another important factor is the number of trees if we have only one tree it becomes giant for large_genomes height of the tree grows fast and cache misses occur constantly to keep the depth reasonable we employ hundreds of trees to store k_mers index of the tree for a k_mer is determined by its prefix as a tree contains k_mers with the same prefix there is no need to keep that prefix in those k_mers so we can use this spare bits to manage counting there are some optimal values for the number of trees dependent on the genome_size cache and memory size we see in our experiments that or trees work the best for or threads but or is a good number for a single thread we chose for experiments with a single thread and for multiple threads we insert k_mers into trees in batches if we insert one k_mer at a time caches have to be refreshed possibly each time which is very time consuming so we fill a buffer of a fixed size for each tree until it is full then we insert these k_mers into that tree we have found that a buffer size of is a good value for our experiments another major impact_factor is the value of x for k x mers generation of k x mers is time consuming but it reduces the total number of insertions or traversals we use x as a default value as we have received good results with this value fragaria vesca has a comparatively smaller genome_size and coverage we ran jellyfish turtle kmc dsk and kcmbt from table we see that jellyfish is the slowest one among these turtle is faster than jellyfish but it has occupied much more memory than jellyfish all of our tests count all the k_mers including single occurrence k_mers cturtle and scturtle do not provide perfect counting so we used single threaded aturtle for our purposes dsk is well known for its careful memory_usage kmc is a popular disk based k_mer counter it requires almost the same amount of memory as dsk but it is much faster than dsk the internal memory version of kmc consumes the same amount of time as the external memory one our kcmbt implementation shows a remarkable improvement it is around faster than kmc for single thread and two threads and around faster for four threads we see that kcmbt is around six times_faster than jellyfish for one thread and two threads and four times for four threads it uses gb_memory for one thread where gb for two threads and gb for four threads we have noticed that kmc is more than two times_faster when running with four threads than when running with two threads kmc has two phases it uses one thread for reading sequences in the first phase this reading thread does not employ cpu all the time therefore it wastes some time here so when we run with one thread or two threads the first phase generally uses two threads one thread is for reading sequences and another one is for computational works but for four threads there are three threads for computation compared to one in two threads as a consequence the speedup for four threads is better than for two threads jellyfish takes more than min to complete the counting of k_mers in gallus_gallus for one thread and min for four threads kcmbt has also performed excellently for this data_set which took less time than kmc kmc needed s for four threads whereas kcmbt takes s kmc ram spends the same amount of time as kmc for this genome dsk is much slower than kmc compares these tools for g gallus atutrtle was run for musa balbisiana but we waited for several hours without observing any noticeable update and then we killed the process so we did not include turtle for all of our other tests also showed that turtle was an underperformer than jellyfish although they included results for scturtle which reports k_mers with frequency above displays results for m balbisiana jellyfish uses only gb of memory to count k_mers for m balbisiana but it is more than three times slower than kmc kcmbt is also around faster than kmc and dsk takes more than double the time taken by kcmbt we see from tables and that kcmbt for two threads and four threads takes much less memory than for one thread the memory_usage depends on several factors such as k_mer distribution of that input genome percentage of buckets filled up in burst trees and so on human_genome is a massive as well as vital data_set we have compared these tools for h sapiens and h sapiens and arranged the results in tables and respectively homo_sapiens has around billion mers and billion unique mers jellyfish is still a very memory_efficient internal memory algorithm as it has used only gb of memory to hold these huge number of unique k_mers and their counts in memory but it is very slow compared to other tools in kmc is five times_faster than this one kmc ram achieves a similar speed up dsk seems to be slow compared to kmc and kcmbt kmc is slower than kcmbt by around for one thread for two threads and for four threads homo_sapiens has more coverage than h sapiens the comparative_analysis among these tools remains the same fromkcmbt a k_mer counterh sapiens to h sapiens in this case kmc is around slower than kcmbt for one thread and slower for four threads kcmbt consumes gb_memory for a single thread whereas kmc ram uses gb but kcmbt takes gb_memory for four threads as every prefix has four trees and similar k_mers exist in four trees kcmbt works in three phases the most time consuming phase is the generation of k x mers and insertion of them we have chosen x for all of our tests the first phase generates k_mers and their reverse complements and tracks the minimum or canonical ones then it slides one symbol computes new k_mer value and a new reverse complement it again finds the minimum one of these two if this minimum and the previous minimum are from the same direction given a k_mer direction or its reverse complement direction it gets a k_mer then it shifts symbol again to extend till x or directions of minimum and previous minimum are different we maintain fixed_length buffers for each tree whenever a buffer is full all the k x mers are inserted into the tree insertion is also time consuming it incorporates traversal to find the proper bucket and if the bucket is full a new node and buckets are created and the distribution of k x mers takes_place so we see fromthat of the total time for f vesca was needed for this first phase this value is for g gallus for m balbisiana for h sapiens and for h sapiens this phase takes a major portion of the total time and the ratio increases according to the size of the total number of k_mers and unique k_mers we show the importance of generation and insertion of k xmers in the first phase in the last column indicates how many k_mers will have to be inserted if we only insert k_mers instead of k x mers where x for each data_set we had to call insertion less than of the times because of the benefits of generation of k x mers we also see that this phase produces a majority number of k_mers after k_mers for every considered genome except m balbisiana this point is beneficial for the second and the third phases this reduction in the number of insertions comes at some expense on k x mers generation the first phase completes a considerable part of the work the second phase traverses all the k_mer k_mer and k_mer trees after the traversal of a k_mer tree we get the k_mer count of that specific k_mer if this count value is c then the constituent two k_mers starting at position and position respectively will have a count of c from this k_mer k_mer trees contain k_mers each of which has three k_mers for a k_mer this value is so when x is large our gain is large as well shows how many unique k x mers exist after the traversal in phase where x let c c and c be the counts of k_mers k_mers and k_mers found in phase respectively we know that a k x mer covers x k_mers so we get c c c k_mers from only c c c k x mers where x for h sapiens we observe that the average counts of k_mers k_mers and k_mers is around a billion this average is more than million for f vesca million for g gallus million for m balbisiana and million for h sapiens this improved achievement is the main_reason behind the consideration of k x mers from all of these experiments we discover that high expenses at first phase are substantially recovered by second and third phases displays the total numbers of k_mers in k_mer trees after the first two phases if the number of k_mers in a tree increases the height of the tree might increase the other effects are moreinsertion time and traversal time we have thousands of trees to reduce the height of these trees the idea of generation insertion and traversal of k x mers also facilitates our intention of keeping the trees within a reasonable height the total number of k_mers in k_mer trees is millions instead of millions for h sapiens millions instead of millions for h sapiens these values are times smaller than originally required insertions as the inserted numbers of k_mers have been reduced a lot the time for traversal in the third phase is dramatically_reduced we observe fromthat very little amount of time was spent for this final traversal third phase traverses these k_mer trees and produces k_mers with their counts if we do not use k x mers for some x then we have to traverse larger trees which is very time taking the number of trees has a huge impact on the running time if we increase the number of trees the average height of trees decreases therefore insertion and traversal take less time but after a certain number the running time starts to increase because there are already many trees and cache misses occur frequently at the time of insertion our observations from experimental_results imply that or are quite good numbers for the trees for these data_sets we used for all of these experiments we have included elapsed time for all of these data_sets for these two values inkcmbt outperforms every other k_mer counter by a large margin kmc is currently the best performing k_mer counter it requires a low internal memory and some not so much inexpensive disk storage it is practically a very fast k_mer counter with several good options we have collected data_sets of the five genomes used in our experiments from available links in the published paper of kmc in this kmc paper the authors also explain how they ran the other programs we have tried to employ the same values for the underlying parameters except for the number of cores we have shown in the previous section how our ideas were fruitful in counting k_mers efficiently our algorithm chooses burst tries to store k_mers burst trie is very cache efficient for keeping strings in approximate sorted order we need that for holding somewhat similar k_mers together for large_genomes there exist enormous numbers of k_mers a single tree is not enough to store all of them efficiently insertion and traversal become very time expensive operations because of the large height of the tree we employed hundreds of trees to resolve this issue when the number of trees is large we can remove some prefix bits from each k_mer to index its corresponding tree these extra bits can be used to store counts keeping a k_mer and its count together in an unsigned bit word is indeed helpful since the alphabet size is each symbol needs at least bits if we want a symbol prefix there will be or trees we ran kcmbt for prefix symbols for value some of these tree heights become large for a value of there are a massive number of trees and cache misses occur regularly we have found good results for values and it is not fruitful to insert one k_mer at a time if we choose this option in some of the cases the running time rises more than because of frequent cache swapping therefore we choose a large buffer to cache these k_mers and insert them at a time which is very cache friendly our first attempt was generation and insertion of k_mers there were two phases the first phase inserted these k_mers into trees and the second phase traversed them to accumulate all k_mers with their counts but this idea was not good enough to outperform kmc in some cases we have adapted the very good idea of using of k xmers from kmc we have followed almost the same idea to generate these k x mers kmc generates them from super k_mers stored in disk files we form them from k_mers in the first phase experimental outcomes prove the usefulness of this idea it eliminates many insertion and traverse counts we generally use k xmers where x a value of more than for x works better if they have enough duplicate occurrences we have noticed that x performs better in our experiments in the second phase we traverse k x mer trees and count the number of occurrences of each k x mer we then split each k x mer into k_mers and insert them into k_mer trees we could have improved the time by not inserting the k_mers occurring in the first positions of k x mers if we did that we will have to merge at a later stage the process would be complicated as the total time spent in the last two phases is not that much we have avoided this complexity kcmbt a k_mer counter 
