efficient construction of an assembly string_graph using the fm_index motivation sequence_assembly is a difficult problem whose importance has grown again recently as the cost of sequencing has dramatically dropped most new sequence_assembly software has started by building a de_bruijn avoiding the overlap based_methods used previously because of the computational_cost and complexity of these with very large_numbers of short_reads here we show how to use suffix_array based_methods that have formed the basis of recent very fast sequence mapping algorithms to find overlaps and generate assembly string graphs asymptotically faster than previously described algorithms results standard overlap assembly methods have time complexity o n where n is the sum of the lengths of the reads we use the ferraginamanzini index fm_index derived from the_burrows to find overlaps of length at least among a set of reads as well as an approach that finds all overlaps then implements transitive_reduction to produce a string_graph we show how to output directly only the irreducible overlaps significantly shrinking memory_requirements and reducing compute time to o n independent of depth overlap based assembly methods naturally handle mixed length read sets including capillary reads or long_reads promised by the third_generation the algorithms we present here pave the way for overlap based assembly approaches to be developed that scale to whole vertebrate genome de_novo the sequence_assembly problem is one of the most important and difficult_problems in bioinformatics most genomes particularly eukaryotic_genomes are highly repetitive that complicates their assembly by obscuring true relationships between reads with many false options to help disambiguate the true relationships between the reads from those induced by different copies of repeats it is useful to construct a graph where all the copies of a repeat are collapsed into a single segment such a graph is commonly referred to as a repeat graph this structure is a natural consequence of the de_bruijn method of sequence_assembly as the deconstruction of the sequence_reads into k_mers short subsequences of the reads of length k collapses repeats that share the same k_mer into a single vertex an alternative formulation was proposed by gene myers and is called the string_graph the string_graph is built by first constructing a graph of the pairwise overlaps between sequence_reads and transforming it into a string_graph by removing transitive edges the string_graph shares with the de_bruijn the property that repeats are to whom correspondence should be addressed collapsed to a single unit without the need to first deconstruct the reads into k_mers because it is based on maximal overlaps which are typically longer than de_bruijn k_mers it also disambiguates shorter repeats that de_bruijn methods would only resolve in later processing_steps if at all the string_graph is much more expensive to construct however as the set of all pairwise inexact overlaps between sequence_reads must be found for this reason the majority of assemblers of short_read have been based on the de_bruijn approach a notable_exception is the edena assembler that uses a suffix_array to compute exact overlaps between reads that are then used to construct the string_graph we address the construction of a string_graph with a related approach by indexing the set of sequence_reads using the burrowswheeler_transform bwt ferragina manzini fm_index which has recently been used for the short_read problem we show how to efficiently compute the set of overlaps needed to construct the string_graph from the fmindex furthermore we show that the string_graph can be constructed directly using the fm_index without the need for explicitly finding all overlaps and a subsequent transitive removal step yielding a space and time efficient construction algorithm as a proof_of we implemented the above algorithms the program is broken into three stages index overlap and assemble the index stage constructs the suffix_array and fm_index for a set of sequence_reads the overlap stage computes the set of overlaps between the reads and the assemble stage builds the string_graph performs transitive_reduction if necessary then compacts unambiguous paths in the graph and writes out a set of contigs we tested the performance of the algorithms with two sets of simulations in both sets of simulations we compared the exhaustive overlap algorithm which constructs the set of all overlaps and the direct construction algorithm which only outputs overlaps for irreducible edges first we simulated escherichia_coli read data with mean sequence depth from to to investigate the computational_complexity of the overlap algorithms as a function of depth after constructing the index for each dataset we ran the overlap step in exhaustive and direct mode with the running_times of these simulations are shown in as expected overlap exhaustive overlap direct the running time of the direct and exhaustive overlap algorithms for simulated e coli data with sequence depth from to the direct overlap algorithm scales linearly with sequence depth as the number of overlaps grows quadratically with sequence depth the exhaustive overlap algorithm exhibits above linear scaling the direct overlap algorithm scales linearly with sequence depth the exhaustive overlap algorithm exhibits the expected abovelinear scaling as the number of overlaps for a given read grows quadratically with sequence depth to assess the quality of the resulting assembly we assembled the data using the direct overlap algorithm and compared the contigs to the reference for each level of coverage we selected to maximize the assembly n value the n values ranged from kbp data to kbp data we aligned the contigs to the reference_genome with bwa_sw and found that no contigs were misassembled we also simulated_data from human_chromosomes and to assess how the algorithms scale with the size of the genome we pre processed the chromosome sequences to remove sequence gaps then generated bp error_free reads randomly at an average coverage of for each chromosome the results of the simulations are summarized in the running time of the exhaustive and direct overlap algorithms are comparable as the sequence depth is fixed at both overlap algorithms scale linearly with the size of the input_data the final_stage of the algorithm building the string_graph and constructing contigs is much shorter for the direct algorithm as the transitive_reduction step does not need to be performed in addition this step requires considerably less memory as the initial graph constructed by the direct algorithm only contains irreducible edges the bottleneck in terms of both computation time and memory_usage is the indexing step which builds the suffix_array and fmindex for the entire read set this required h and gb of memory for chromosome extrapolating to the size of the human_genome indicates it would require days and gb of memory to index sequence_data while the computational time is tractable the amount of memory required is not practical for the routine assembly of human_genomes we address ways to reduce the computational requirements in section for the overlap and assemble rows e and d indicate the exhaustive and direct algorithms respectively the last column is the ratio between chromosome and 
