genome_analysis scarpa scaffolding reads with practical algorithms motivation scaffolding is the process of ordering and orienting con tigs produced during genome_assembly accurate scaffolding is essential for finishing draft assemblies as it facilitates the costly and laborious procedures needed to fill in the gaps between contigs conventional formulations of the scaffolding_problem are intractable and most scaffolding programs rely on heuristic or approximate solutions with potentially exponential running time results we present scarpa a novel scaffolder which combines fixed parameter tractable and bounded algorithms with linear_programming to produce near optimal scaffolds we test scarpa on real_datasets in addition to a simulated diploid_genome and compare its performance with several state of the art scaffolders we show that scarpa produces longer or similar length scaffolds that are highly_accurate compared with other scaffolders scarpa is also capable of detecting misassembled contigs and reports them during scaffolding availability scarpa is open_source and available from http compwhile assemblers developed for high_throughput hts platforms can produce high_quality draft assemblies for the genomes of bacteria and viruses de_novo assemblies of more complex genomes using short_reads are typically fragmented this fragmentation can be partially alleviated through scaffolding the process of linking contigs into longer_sequences possibly with gaps using paired_read information scaffolding not only improves the contiguity of the initial assembly but is also helpful for designing experiments for finishing of the genome through additional sequencing of selected regions with lower throughput technology such as sanger although many genome_assemblers produce scaffolds using paired_reads during the assembly process the problems of building contigs and scaffolding them are distinct a scaffolder takes as input a set of assembled_contigs and a set of paired_reads the relative orientation of two paired_reads and the approximate distance between them are known thus if the two reads can be unambiguously mapped to different contigs we can identify the relative ordering and the distance between these contigs owing to errors in the read_pair data e g chimeric pairs and in the assembly e g misassembled contigs the ordering achieved from different read_pairs can be contradictory consequently the scaffolding_problem is often defined as finding an ordering on the contigs that maximizes the number of supporting read_pairs computationally this formulation is np_hard leading most scaffolding approaches to use heuristic_algorithms with no provable guarantees some scaffolders greedily link contigs by considering them in order of strongest paired_read support or largest contig length while rejecting links that contradict those already chosen alternatively the scaffolding_problem is often represented as a graph where nodes denote contigs and edges denote paired_read links sopra partitions this graph into smaller parts and solves the scaffolding_problem in each subgraph using statistical optimization mip scaffolder partitions the graph in a similar way however it solves the problem for each subgraph exactly using mixed integer_programming to keep the algorithms tractable both of these scaffolders limit the sizes of the subgraphs opera applies an alternate partitioning scheme using a graph contraction procedure and solves the scaffolding_problem with a fixed parameter tractable algorithm based on a graph bandwidth formulation these approaches to scaffolding attempt to maximize the number of paired_reads that are satisfied implicitly assuming that paired_read links are noisy and the contigs are error_free however in larger and more complex genomes the assembled_contigs may well have misassemblies in this article we present a novel method that combines several practical algorithms for the scaffolding_problem our approach assumes that both erroneous read_pairs and contigs are possible allowing us to detect misassembled contigs and remove these from the scaffolds this formulation of the problem allows for an algorithm with practical time and memory_requirements while providing an exact solution of bounded error this algorithm is implemented within scarpa a stand alone scaffolder for hts_data we have tested scarpa on real_datasets as well as on a simulated diploid_genome and show that it builds highly_accurate and longer scaffolds compared with several state_ofthe scaffolders scaffolding improves the contiguity of an assembly and facilitates the finishing of a genome by establishing an order and orientation of contigs in this article we have presented scarpa a novel scaffolder for hts_data that combines graph algorithms with lp using simulated_and we show that scarpa produces as long or longer scaffolds than the current state of the art tools while at the same time achieving high_accuracy note for g clavigera the size of the available draft sequence is given in place of the genome_size for the assemblathon dataset the genome_size is given as an average of the haploid reference_sequences a novel feature of scarpa is the ability to detect misassembled contigs although this procedure may produce false_positives scarpa reports only a few such contigs per dataset which can be manually investigated if necessary for instance scarpa discards no contigs in the g clavigera and assemblathon datasets and only three contigs in the e coli dataset two of which are indeed found to be erroneous we also show that scarpa has favorable running time on these datasets although it is slightly slower than sspace in addition scarpa has a small memory_footprint requiring gb on the assemblathon dataset within scarpa the most time consuming step is the contig_orientation task while we believe our method typically produces more accurate scaffolds compared with greedy or heuristicbased approach and has the advantage of detecting misassemblies it can be computationally_expensive for large and complex genomes on the other hand the fixed parameter tractable algorithm we use is suitable for parallel computation although our current_implementation is single threaded we plan to explore this direction in a future version note mapping is performed using bowtie with threads and mapping time is included for all scaffolders for information the total wall clock time taken by bowtie to index the reference and write read mappings in sam format is also reported 
