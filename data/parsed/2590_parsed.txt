genome_analysis iva accurate de_novo of rna virus_genomes motivation an accurate genome_assembly from short_read sequencing_data is critical for downstream_analysis for example allowing investigation of variants within a sequenced population however assembling sequencing_data from virus samples especially rna_viruses into a genome_sequence is challenging due to the combination of viral population_diversity and extremely uneven read_depth caused by amplification_bias in the inevitable reverse_transcription amplification process of current methods results we developed a new de_novo assembler called iva iterative virus assembler designed specifically for read_pairs sequenced at highly_variable depth from rna_virus samples we tested iva on datasets from sequenced samples from human_immunodeficiency or influenza_virus infected people and demonstrated that iva outperforms all other virus de_novo assemblers availability_and the software runs under linux has the gplv licence and is freely_available from http sanger pathogens github io ivathe main_challenge of assembling sequence_data from an rna_virus sample into a consensus_sequence lies in the extremely variable read_depth from current sequencing_approaches combined with the extensive viral population_diversity an example is shown inwhere regions of the genome are represented with different read_depths caused by the separate reverse_transcription amplification of overlapping regions of the genome before library_preparation further there is a relatively high rate of single base differences in the reads throughout the genome these properties of the data cause standard assembly algorithms to produce multiple contigs covering the same region and more significantly miss regions of the genome entirely despite the availability of at least genome_assemblers http en wikipedia org wiki sequence_assembly vicuna and price are currently the only assemblers designed for virus data vicuna tackles the assembly problem by first clustering the reads that should belong to the same contig using min hashes to infer similarity contigs are generated and then merged to form the final output price begins with seed sequences which are iteratively extended by generating new sequence from local assemblies of reads at contig ends in addition the rna_seq assembler trinity has been used to assemble virus data because it can handle irregular read_depth trinity constructs de_bruijn from clusters of the reads then resolves each cluster into transcripts by tracing reads and their mates through the graphs our approach is similar to that of price except we extend contigs more conservatively using consensus kmers from the reads instead of using local assemblies also our new assembler called iva iterative virus assembler is a completely de_novo assembler whereas price must be provided with seed sequences to be extended into contigs we evaluated iva price trinity and vicuna with different parameters on illumina paired_reads from human_immunodeficiency hiv samples and influenza a and b virus samples see the supplementary_material for the full analysis to compare the assemblies for each sample we picked the closest reference from a pool of genomes using kraken for the accession_numbers and complete evaluation procedure see the supplementary_material we generated quality_metrics using i nucmer to compare contigs with a reference_genome ii gage analysis code and iii ratt to transfer annotation from the reference to the assembly the ideal assembler output is defined as one contig for hiv or exactly one contig for each influenza_virus genome segment with the expected length compared to the closest reference and no duplication iva generated ideal assemblies for of the hiv samples and of the influenza_virus samples and supplementary tables s and s significantly more than the other assemblers these low numbers are generally due to contigs of incorrect length or duplications in the assemblies supplementary figs s and s and supplementary tables s and s iva had the smallest variation in these results especially for the influenza_virus samples supplementary figs s and s and supplementary tables s and s the proportion of each reference_genome assembled into contigs was for hiv the corresponding values for influenza_virus ranged from price to iva the mean per_cent of hiv annotation_features transferred by ratt from iva assemblies was on both hiv and influenza_virus samples this was more than the other assemblers except vicuna with alternative settings that achieved mean annotation transfer at the expense of a duplication rate more than double that of iva supplementary there were few assembly errorstrinity produced none and iva and vicuna made one error each the typical run time was under h and none of the assemblers had excessive memory_requirements example hiv assemblies plots show the proportion of single base differences per mapped read compared to the iva contig the read_depth and contigs from price trinity and vicuna aligned to the single iva contig the minimum read_depth is iva supplementary iva was slightly slower on the hiv samples but was comparable to price and faster than vicuna on the influenza_virus data considering the number of ideal assemblies produced by the available tools it can be seen that assembling rna virus_genomes is challenging however iva was consistently better at producing single sequences representing the consensus_sequence of each virus population especially on the influenza_virus data in contrast the other tools tended to either produce multiple copies of parts of each genome or miss entire regions from their output in summary we developed iva specifically to assemble short_read sequencing_data from rna_virus samples and have shown that it produces significantly_higher quality assemblies than existing_approaches a for each segment of the reference the longest matching contig was found this plot shows the total length of these contigs for each assembly as a percentage of the reference length b total assembly lengths excluding contamination by only counting contigs that match the reference as a percentage of the reference length 
