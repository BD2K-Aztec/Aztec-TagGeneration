genome_analysis the masurca genome assembler motivation second_generation produce high coverage of the genome by short_reads at a low_cost which has prompted development of new assembly methods in particular multiple algorithms based on de_bruijn have been shown to be effective for the assembly problem in this article we describe a new hybrid_approach that has the computational_efficiency of de_bruijn methods and the flexibility of overlap based assembly strategies and which allows variable read_lengths while tolerating a significant level of sequencing_error our method transforms large_numbers of paired_end into a much smaller number of longer super reads the use of super reads allows us to assemble combinations of illumina_reads of differing lengths together with longer_reads from and sanger sequencing_technologies making it one of the few assemblers capable of handling such mixtures we call our system the maryland super read celera_assembler abbreviated masurca and pronounced mazurka results we evaluate the performance of masurca against two of the most widely used assemblers for illumina data allpaths_lg and soapdenovo on two datasets from organisms for which high_quality assemblies are available the bacterium rhodobacter_sphaeroides and chromosome of the mouse_genome we show that masurca performs on par or better than allpaths_lg and significantly better than soapdenovo on these data when evaluated against the finished sequence we then show that masurca can significantly improve its assemblies when the original data are augmented with long_reads following the creation of draft versions of the human_genome in many small and large_genomes were sequenced using first generation i e sanger sequencing_technology with read_lengths exceeding bp more recently a variety of types of second generation sequencing sgs technologies have appeared with read_lengths ranging from bp the lowest cost sequencers today produce bp reads at a cost many thousands of times lower than sanger_sequencing new assembly methods have been developed in response to the challenge of short_read assembly and they have steadily improved in recent_years despite this progress though the problem of determining the sequence of a genome is far from a solved problem virtually all assemblies published today are draft_genomes with varying levels of quality containing many gaps and assembly errors that present significant problems for scientists who rely on these genomes for downstream_analysis this article reports progress in assembling genomes facilitated by a new approach to genome_assembly first we briefly describe the two general approaches that have been used for assembly of whole_genome shotgun sequencing_data overlaplayoutconsensus olc assembly briefly the olc paradigm first attempts to compute all pairwise overlaps between reads using sequence_similarity to determine overlap then an olc algorithm creates a layout which is an alignment of all overlapping reads from this layout the algorithm extracts a consensus_sequence by scanning the multiread alignment column by column most assemblers for sanger sequencing_data including celera_assembler pcap arachne and phusion are based on the olc approach two of the main benefits of the olc approach are flexibility with respect to read_lengths and robustness to sequencing_errors to improve the likelihood that apparent overlaps are real and not repeat induced olc algorithms typically require them to exceed some minimum_length e g the celera_assembler requires overlaps of bp or longer allowing for a small error_rate in the overlapping region to compensate for shorter read_length and lack of uniformity in coverage sgs de_novo projects typically generate times as many reads as sanger sequencing_projects e g the original human and mouse projects generated million_reads each whereas recent human sequencing_projects generated billion reads the de_bruijn approach avoids the pairwise overlap computation entirely which is one reason why it has become the leading method for sgs assembly to whom correspondence should be addressed the de_bruijn approach the de_bruijn assembly algorithm was pioneered by who first implemented these ideas in the euler assembler although euler was designed for sanger reads the same general framework has been adopted recently by programs for assembling sgs data and for illumina read data in particular recently_developed assemblers that use the de_bruijn strategy include allpaths_lg soapdenovo velvet euler sr and abyss this approach begins by creating a de_bruijn from the read data as follows for a fixed value k every substring of length k a k_mer from every read is assigned to a directed edge in a graph connecting nodes a and b nodes a and b correspond to the first and last k nucleotides of the original k_mer any path through the graph that visits every edge exactly once formally known as an eulerian path forms a draft assembly of the reads in practice these graphs are complex with many intersecting cycles and many alternative eulerian paths and therefore creating the graph is merely the first small step in creating a good draft assembly complete assembly requires incorporating mate_pair information into the graph and attempting to disentangle the many complex cycles created by repetitive_sequences because the k_mers are shorter than reads the graph contains less information than the reads so the reads need to be retained for later use in disambiguating paths in the graph the main benefit of this approach is its computational_efficiency which it gains from the fact that the immense number of overlaps is not computed the main drawbacks are loss of k_mer adjacency information in the graph and spurious branching caused by errors in the data super reads a new alternative in this article we propose a third paradigm for assembly of short_read based on the creation of what we call super reads the aim is to create a set of super reads that contains all of the sequence_information present in the original reads despite the fact that there are far fewer super reads than original reads for the ideal error_free case see the theorem below the basic concept of super reads is to extend each original read forwards and backwards base by base as long as the extension is unique the concept can be explained as follows we create a k_mer count look up table using an efficient hash_table to determine quickly how many times each k_mer occurs in our reads given a k_mer found at the end of a read there are four possible k_mers that could be the next k_mer in a genomes sequence these are the strings formed by appending a c g or t to the last k bases in the read our algorithm looks up which of these k_mers occur in the table if only one of the four possible k_mers occurs we say the read has a unique following k_mer and we append that base to the read we continue until the read can no longer be extended uniquely i e there is more than one possible continuing base or we have reached a dead_end and no base is permissible we perform this extension on both the and ends of the read the new longer string is called a superread many reads extend to the same super read as shown in notice that if two reads have an interior difference by even one baseas for example would occur if they derived from two non identical repeats or from two divergent haplotypesthen they will generate distinct super reads of course super reads can easily be computed using a de_bruijn the point is that once the super reads are created theytogether with mate_pairs that connect super readscollectively replace the de_bruijn incorporation of mate_pair information is carried_out using the olc assembly step described below the two most important properties of the super read data computation are as follows each of the original reads is contained in a super read so no information has been lost and many of the original reads yield the same super read so using super reads leads to vastly reduced dataset hundreds of times fewer super reads than reads masurca uses a modified_version of the cabog assembler for the overlap based assembly following superread construction in creating its fundamental unit of unitigs cabog uses only maximal reads i e reads that are not proper substrings of other larger reads in principle this could cause assembly errors but in practice they seem to be rare because of this practice we carry out one extra step the only super reads we use are maximal super reads i e those that are not exact substrings of another super read we then assemble the maximal super reads along with other available data including mate_pairs with the modified cabog assembler the other data include jumping libraries and possibly read data and sanger read data and mate_pairs we observe that the coverage of the genome by maximal super reads typically varies from independent of whether the raw read_coverage is or even higher note that each heterozygous single_nucleotide increases the number of super reads for a haploid_genome super reads will tend towards coverage whereas for highly heterozygous diploid genomes the super read_coverage may be closer to in the two example genomes described in the results section rhodobacter_sphaeroides and mus_musculus the reads outnumber the maximal super reads by factors of and respectively the n lengths for the super reads themselves are and bp respectively masurca automatically chooses the k_mer size for creating super reads and in these two cases k is and respectively the following theorem lays the theoretical_foundation of equivalence of assemblies made from the original reads and the super reads for the case of perfect error_free reads the super reads theorem for the ideal case of perfect error_free reads to understand the underpinnings of the super reads approach we consider the simplest case here we ignore mate_pairs the above construction of super reads is based on a fixed k_mer size so for clarity we can call them k super reads the genome is a collection of strings chromosomes and loops plasmids or organelles with a four letter alphabet to avoid end effects we assume that all dna in the genome is circular as is often the case for bacteria but we shall still speak of their substrings a string read or super read is called perfect if it is identical to a substring of the genome such a substring of the genome together with its coordinates is called a placement a string may have multiple placements we say that a set of strings r is k perfect with respect to a genome g if i every base of the genome g is covered by some placement and ii adjacent placements overlap by at least k bases when a set of reads is k perfect we can distill the information in the reads by the usually much smaller set of k super reads the following result says that k super reads contain all of the information in the reads theorem assume a set of reads is k perfect for some genome g then the corresponding set of k super reads has the same property in other words the set of super reads contains all of the information in the reads and they have introduced no errors the proof follows from the construction of super reads because each read is contained in a super read no data are lost at the same time if the original read data are inadequate for deducing what the genome is then so are the super read data if both flanks of some copy of the repeat were not covered in the read set there would be no maximal k super read that could be placed at that copy of the repeat in practice reads are not perfect and because the super reads can only represent the information in the original reads there will always be some super reads that contain errors that were in the original reads the task of the assembly algorithm used downstream of super reads is to detect and correct most of the errors and create a mostly correct assembly assemblers have long been designed to do exactly that because reads used in assembly projects were never assumed to be perfect the masurca assembler benefits from the advanced assembly techniques in the cabog assembler for creating contigs and scaffolds from super reads velvet the best performers in gage were allpaths_lg and soapdenovo hence we have included those two programs for comparison with masurca for a more recent comparison one should see the gage b competition it reports on assemblies of bacterial_genomes by abyss cabog masurca mira v soapdenovo spades v and velvet masurca produced the best assemblies for the majority of the species spades did well especially on bp reads but is not designed for larger genomes allpathslg was not used in that competition because it requires two libraries whereas this test had only one library per species evaluating the assemblies we evaluated the performance of the assemblers using two separate techniques we evaluated the contigs using the recently_published quast software in the tables below we report the contig sizes in terms of nga reported by quast the nga size is defined as the value n such that of the finished sequence is contained in contigs whose alignments to the finished sequence are of size n or larger note that nga differs from n in that n is defined by the total size of the assembled_contigs whereas nga is defined by the actual size of the genome itself if the assembly size is close to the true genome_size then n and nga are roughly_equivalent quast does not report the scaffold statistics in the way we would prefer to look at them in evaluating the scaffolding we look for the correct order and orientation of the contigs and contiguity of the coverage allowing for reasonable shorter than a longest mate_pair gaps thus we evaluated the scaffolds separately by mapping them to the finished sequence using nucmer we then clustered the matches of each scaffold to the finished sequence_based on proximity of the matches in terms of finished sequence coordinates within each cluster of the matches of the scaffold to the finished sequence we required that the matches are in the same order in terms of finished sequence and scaffold match coordinates no rearrangements same orientation and the distance between the consecutive matches is smaller than kb the size of the longest library for the mouse_genome and kb for the bacteria then we counted the number of clusters and the number of the scaffolds the number of scaffold misassemblies is the difference between these two numbers we defined nga for the set of scaffolds as the value n such that of the finished sequence is spanned by clusters where the span of each individual cluster is of size n or larger bacteria genome_assembly for the first comparison we chose two illumina datasets i a paired_end library i e pe in which reads were generated from both ends of bp dna_fragments sra accession srr and ii a jumping library in which paired ends were sequenced from bp fragments sra accession srr we randomly down sampled both libraries to genome_coverage for lr we used sanger reads with average length_bp from the national_center ncbi trace archive entry for r sphaeroides str the sanger reads provided genome_coverage for our experiments we used randomly down sampled lr datasets of and coverage the data are summarized in supplementary table s the parameters used for the allpaths_lg masurca and soapdenovo assemblies are described in the supplementary_material because the creation of super reads is critical in the masurca design we first present the analysis of the number and correctness of the super reads for this dataset masurca reduced the original paired_end to super reads a reduction by a factor of almost in addition to those the masurca submits tobp the minimum_size was bp and the longest super read was bp the total amount of sequence in super reads was bp coverage of the genome to determine how well the maximal super reads agreed with the genome we mapped the super reads to the finished sequence by nucmer using a k_mer seed size of parameters l c maxmatch the total number of bases in the super reads that matched the finished sequence was in super reads a total of of the matching bases were in at least one of super reads that matched with at least identity over at least of their length the remaining super reads that did not match the finished sequence contained bp of sequence and their maximum_size was bp we examined the reads that were used to produce the non matching super reads and could not find a match to the genome of length bp in any of these reads it is likely that these reads primarily contained adapter sequences with errors or other contaminantsshows the comparison of the performance of the masurca assembler with the others on the r sphaeroides dataset the masurca assembler using only illumina data performs on par with allpaths_lg with nearly identical nga sizes two fewer contig errors and two more scaffold errors all scaffold errors were in small scaffolds whose sizes were well below the n scaffold size and this did not influence the nga scaffold size moreover the performance of masurca on illumina data alone is comparable with performance of cabog on only the sanger long_read data although soapdenovo had the smallest_number of contig errors its contigs were significantly_smaller than those produced by the other assemblers as we introduced additional coverage by lr into the mix the assemblies produced by masurca assembler become superior in contiguity to all other assemblers bottom three rows of in particular the contig n value increased from to kb with just sanger data and to kb with deeper sanger data we note that neither soapdenovo nor allpaths_lg allows for mixed datasets of this type mouse genome_assembly to save time and to allow for more detailed examination of the results we created a restricted dataset for a single chromosome of the mouse_genome chromosome mmu we downloaded the same data for the mouse_genome as was used in the evaluation of allpaths_lg which are available from the ncbi sra under the study mouse b genome on illumina these sequences were generated from mouse_strain c bl j the same strain used for the finished mouse sequence mouse_genome we mapped the reads to the finished sequence for the entire mouse_genome using bowtie allowing up to five best hits of identical quality for each read we then extracted the reads whose best_hit either for the read or for its mate was in chromosome we also downloaded the original sanger reads from ncbi trace archive mouse_genome and mapped them against the finished sequence masurca does not require the lr to be mated and we excluded mate_pair information for these reads during assembly supplementarylists the mouse datasets used in our experiments from the paired_end dataset containing million_reads the super reads module of masurca produced super reads containing bp with an n size of bases the reads outnumber the maximal super reads by a factor of over the original coverage by the bp paired_end reduced to just over coverage by super reads in addition the super reads module output linking mates from the pe library these are paired_reads that link together two super reads thus we reduced m reads to m super reads and linking mates a fold reduction after mapping the super read sequences to the finished sequence using nucmer we found that bp in super reads matched mmu of these matching bases were contained in at least one of the super reads that had at least identity to mmu over at least of the super reads length results for the mouse assemblies are provided in not unexpectedly the mmu dataset was more challenging than the bacterial_genome for assembly with illumina only data the nga contig size for masurca assembly was twice as big compared with the allpaths_lg assembly whereas the number of errors was larger soapdenovo produced small contigs with a large number of errors the masurca assembler produced the largest scaffolds with nga more than an order of magnitude larger than the allpaths_lg scaffolds and almost twice bigger than the soapdenovo scaffolds masurca produced progressively larger and more accurate contigs as lr were added into the mix additional lr coverage almost doubled the n contig size while reducing the number of contig misassemblies by the lr data did not have any mate_pairs by design thus we did not expect a significant_improvement in scaffolding however the scaffolds improved as well we note that for each run the same set of super reads jumping library reads and linking mates went into the cabog assembler the only difference between runs was in the number of lr as we introduced more lr the number of assembly errors decreased whereas the contig n size increased_significantly we began this project when we were faced with the prospect of assembling a gbp pine tree genome with perhaps billion illumina_reads that was far larger than anything that had been assembled along the way we have found our philosophy of reducing illumina_reads to super reads is useful we discuss possible shortcomings and problems of our approach as well as data problems that can result in a poor assembly if the user does not address them we have mentioned the gage b study of bacterial_genomes in which masurca was declared highly_effective at the end of this section we list larger genomes that have been assembled by masurca and are publicly_available overall evaluation in tables and the quast nga contig size and the nga scaffold size can be viewed loosely as n sizes after the contigs and scaffolds have been broken at each major misassembly when comparing two assemblies if after breaking at errors the n contig or scaffold size is doubled in one assembly compared with the other while introducing fewer than twice as many errors we believe the doubling is justified inon illumina data only we view allpaths as doing slightly better than masurca on scaffolds and both did significantly better than soapdenovo note that the scaffold nga for allpaths and masurca are about three fouth of the size of the genome indicating that unlike soapdenovo they both got the biggest chromosome in a correct scaffold the fact that masurca has long scaffolds mb after breaking at errors and the errors occur at roughly mb in spacing indicates that the errors lie near the ends of the big scaffold or in small scaffolds in this case they all were in small scaffolds so that the overall size of the scaffolds is not severely impacted by breaking at errors when significant amounts of long_read data are available masurca makes use of that resource and does better its contig sizes rise dramatically and the scaffold error_rates drop for r sphaeroides the high_gc of the genome results in greater_variability in the read_coverage because of biases present in illumina sequencing_technology this case shows that good assemblies are still possible even for high or low gc genomes is a better test of scaffolding as the scaffolds are not approaching the size of the genome masurcas scaffolds are roughly times larger than allpaths while introducing only about times as many errors errors seem inevitable unless contigs and scaffolds are built conservatively and remain small soapdenovos assembly suffers from small contigs again adding lr improves the assembly significantly it is clear that even if assembler a is significantly better than assembler b on a collection of genome datasets a may do worse than b on some datasets here we have chosen datasets for which the pe mate_pairs overlap each other as is required by allpaths our limited_experience masurca assemblies are better if multiple pe libraries are used varying the fragment length generally a jumping library should also be available such as one built from kb or longer fragments error_correction error_correction greatly_simplifies the de_bruijn and typically results in larger k unitigs and thus larger super reads our algorithm works best on error corrected reads but is not tied to a particular error_correction technique in the masurca software_package we use the quorum error_correction algorithm marcais et_al in preparation however one can substitute other techniques such as quake or hammer data problems a variety of problems with the input reads and libraries can reduce the quality of an assembly one of the most common issues is mislabeled or poorly size selected fragment_libraries for example we have encountered jumping libraries identified as kb made from kb fragments but later found that the sequences include a mixture of pairs created from to kb fragments similar problems often arise with long_distance paired_reads various explanations have been offered for this type of error but regardless of the source the misidentified mate_pairs create difficulties when the assembler tries to place them kb apart in the assembly an examination of the assembly may reveal the problem at which point it can be corrected and the assembly can be restarted we have observed libraries that were designed to be longer than kb but were entirely comprised of kb fragments another problem that arises with current_technology is that the forward reads might be of excellent_quality but their mates which are created in a separate run are of far lower_quality we encountered one dataset where some of the libraries had so many errors that the assembly was better when made without those libraries for example when using paired_end data if the wrong linker sequence is provided to the assembler the assembly will be severely fragmented in general severe fragmentation of an assembly is an indication of some kind of data error which in turn requires a form of data debugging to fix the errors and restart the assembly no list of possible data errors will be complete a data diagnostic u k before running an assembler one should evaluate the quality of the input_data with any tools available one strategy that we have found useful is to count the number of unique k_mers in the reads given a project with deep coverage e g or higher any k_mers that occurs just once in the set of reads almost certainly contains at least one error this is the insight used by the quake error corrector we can compare the number of unique k_mers in forward and reverse reads as a means of evaluating the quality of the reverse reads we can also use k_mer counts to estimate the real error_rate in the read data as follows a sequencing_error in the middle of a read is likely to result in k unique k_mers because every k_mer containing the error will be unique if the average number of unique k_mers per read is u then u k is a lower_bound estimate of the average number of sequencing_errors per read in the data this estimate ignores the fact that an error near the end of a read will result in fewer erroneous k_mers and it does not take into account cases when there are two or more errors per k_mer the u k value should be used as a minimum fitness criterion for the input read data if the estimated number of errors is for bp reads then it is likely that there was a problem in the sequencing run current illumina technology usual has an error_rate below it may be more effective to ignore or redo a run with a high_error than to use it for assembly polymorphic genomes differences between the two copies of homologous_chromosomes in a diploid_genome can increase the number of super reads fold this does not usually constitute a problem as long as subsequent assembly steps handle the polymorphic super reads the celera_assembler cabog will attempt to combine polymorphic regions that differ by up to if the haplotype divergence rate is higher it will result in a fragmented assembly where many scaffolds will terminate in regions of haplotype difference this occurs because even though the mate_pairs may suggest that two scaffolds representing two haplotypes should be merged the contigs within those scaffolds will not align sufficiently well and therefore the scaffolder will not make the merge in this case the assembly can be post processed to split the haplotypes and create scaffolds representing both heterozygous chromosomes available genomes assembled by masurca masurca has been used to assemble de_novo a variety of genomes sometimes improving on published genomes using added data sometimes creating the first publicly_available draft_genome for the species below is a partial list of genomes that were recently assembled with masurca including the types of read data used for each project loblolly pine pinus taeda a gbp genome draft assembly using illumina data only in collaboration with the pinerefseq consortium indian cow bos_indicus illumina mixed data in collaboration with usda ars rhesus_macaque macaca_mulatta sanger illumina mixed data in collaboration with university of nebraska water_buffalo bubalus bubalus illumina mixed data in collaboration with usda ars and caspur italy domestic_cat felis felis sanger illumina mixed data in collaboration with washington_university philippine tarsier tarsier syrichta sanger illumina mixed data in collaboration with washington_university fire ant wasmannia auropunctata illumina mixed data in collaboration with oist japan stalk eyed fly teleopsis dalmanni illumina mixed data in collaboration with university of maryland 
