long read_alignment based on maximal exact match seeds motivation the explosive_growth of next_generation datasets poses a challenge to the mapping of reads to reference_genomes in terms of alignment_quality and execution speed with the continuing progress of high_throughput read_length is constantly increasing and many existing aligners are becoming inefficient as generated_reads grow larger results we present cushaw a parallelized accurate and memory_efficient long read_aligner our aligner is based on the seed and extend approach and uses maximal_exact as seeds to find gapped alignments we have evaluated and compared cushaw to the three other long read_aligners bwa_sw bowtie and gassst by aligning simulated_and to the human_genome the performance evaluation shows that cushaw is consistently among the highest ranked aligners in terms of alignment_quality for both single_end and paired_end alignment while demonstrating highly_competitive speed furthermore our aligner shows good parallel scalability with respect to the number of cpu threads availability cushaw written in c and all simulated_datasets are available at http many biological_applications of next_generation ngs require the alignment of large_quantities of produced reads to a given reference_genome consequently a wide_variety of short_read have been developed in recent_years they can be classified into two categories according to their approaches to identify seeds hash tables and prefix suffix tries maq soap shrimp and bfast are examples of the hash_table approach bowtie bwa soap and cushaw implement the concept of prefix suffix tries using the burrowswheeler_transform bwt and the fm_index with the progress of ngs_technologies the length of produced reads continues to increase unfortunately many existing short_read are becoming inefficient as generated_reads grow to a few hundred bp in length because of two reasons first they typically perform only ungapped alignments or gapped alignments allowing a very limited number of gaps typically one gap second their speed degrades rapidly as the number of gaps increases however for long read_alignment more gaps must be allowed as indels will to whom correspondence should be addressed occur more frequently these new features of long read_alignment thus motivate the design of new aligners with fast speed and high_quality in this article we devise a new long read_aligner based on the well known seed and extend heuristic this heuristic is based on the observation that significant alignments are likely to include homologous regions containing exact or inexact short matches between the two sequences it generally works in three steps first seeds represented as short matches indicating highly_similar regions are generated between the query and the target_sequences secondly these seeds are extended and refined under certain constraints such as minimal percentage identity and extension length to filter out noisy seeds finally more sophisticated algorithms such as the needlemanwunsch algorithm or the smithwaterman sw algorithm are employed to obtain the final alignments several types of seeds have been proposed including fixed_length seeds maximal_exact mems maximal unique matches mums and adaptive seeds fixed_length seeds k_mers are the most widely used seed type the simplest fixed_length seed is the exact k_mer match some improvements have been suggested by allowing mismatches and gaps in the k_mers including spaced seeds and q gram a substring of q bases filters mems are exact_matches that cannot be extended in either direction without allowing a mismatch mums are inherently mems but require uniqueness in addition an adaptive seed has a variable seed length and also has a limitation on the number of seed occurrences in the target recently several long read_aligners have been developed based on the seed and extend approach including bwa_sw bowtie and gassst bwa_sw inspired by bwt sw identifies long gapped seeds by employing a prefix directed acyclic word graph implicitly represented by an fm_index to perform dynamic_programming dp subsequently it heuristically extends and refines the long gapped seeds to produce the final alignments bowtie extracts all mismatch allowable fixed_length seeds from a read using the bwt and then employs dp to identity alignments gassst employs hash tables to find fixed_length seeds and employs multiple filters to remove noisy seeds prior to the final dp based alignment this approach is effective to significantly reduce the number of noisy seeds but also has the risk of discarding correct ones in this article we present a new long read_aligner using mems as seeds mems have been used for whole_genome alignment however to the best of our knowledge mems have not been used for ngs read_alignment our aligner employs memoryefficient versions of the bwt and fm_index data_structures to generate mem seeds for each read each seed defines a potential mapping read region on the genome we then compute the optimal pipeline of our aligner for the se and the pe alignment the dashed lines show the additional two stages for the pe alignment local_alignment score between the read and each potential mapping region and select the highest scoring mapping region to produce the final alignment in addition our aligner provides support for paired_end pe alignment for the pe alignment a new seed pairing approach is introduced with the intention to quickly determine the potential mapping regions of a pe read_pair without performing alignments furthermore we employ vectorization and multithreading to achieve fast execution speed on standard multi core cpus the performance of our aligner is assessed and compared with bwa_sw bowtie and gassst by aligning simulated_and to the human_genome the experimental_results show that our aligner achieves favorable alignment_quality highly_competitive speed and good parallel scalability with respect to the number of threads this new aligner has been integrated into our software_package cushaw the first version of cushaw was designed for short_read bp reads using gpu computing it uses mismatch allowable fixed_length seeds and does not provide support for gapped alignments we name the aligner presented in this article cushaw to indicate the extended functionality the performance of cushaw is compared with three other long read_aligners bwa_sw v bowtie v beta and gassst v bwa_sw employs the default_settings and bowtie also employs the default_settings except for the insert_size related parameters for the pe alignment gassst uses a minimal percentage identity of and default_settings for other parameters cushaw requires the final alignment to have a percentage identity of default setting and to include default setting bases of the read all the tests are conducted on a workstation with two six core intel_xeon x ghz cpus and gb ram running the linux operating system the runtime of each aligner is measured in wall clock time for all tests where the one time construction time of the bwt and the fm_index is not counted in for cushaw bwa_sw and bowtie we use the recall and precision measures to assess all aligners using simulated_datasets where recall precision is calculated by dividing the number of reads that are correctly aligned by the total number of reads the number of aligned read if not explicitly specified a read is deemed to be correctly aligned if the mapping position has a distance of to the true position for real_datasets we use the sensitivity measure which is calculated by dividing the number of aligned_reads by the total number of reads gassst does not evaluate every seed to determine the best alignment for a single_read instead it continues reporting identified alignments until reaching the maximal limit of the number of alignments thus we consider the best of all reported alignments as the final alignment of the read and discard the others in addition gassst does not provide the support for pe alignment and thus is only evaluated for se alignment bwa_sw might report more than one alignment for a single_read in rare cases for not very long_reads where one alignment corresponds to one fragment of the read since these fragment alignments are difficult to be distinguished and ranked we take all of them into consideration 
