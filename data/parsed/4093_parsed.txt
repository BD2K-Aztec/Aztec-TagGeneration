rust bio a fast and safe bioinformatics library we present rust bio the first general_purpose bioinformatics library for the innovative rust programming_language rust bio leverages the unique combination of speed memory safety and high_level syntax offered by rust to provide a fast and safe set of bioinformatics algorithms and data_structures with a focus on sequence_analysis with ever increasing amounts of experimental_data being generated their computational_analysis becomes increasingly challenging for novel or custom problems where carefully engineered highperformance standalone tools like read_mappers are not yet available general_purpose bioinformatics libraries can help to minimize the coding effort bioinformatics libraries are published for many popular programming_languages e g seqan for c biopython bioperl and bioruby choosing the programming_language for a specific task usually entails a tradeoff between execution and development speed low_level system programming_languages like c or c provide optimal_performance at the cost of increased complexity higher_level languages like python or perl provide a more concise syntax while leading to computational_overhead introduced by online memory management e g reference counting or garbage collection type inference and not being compiled but interpreted during execution often the combination of a high_level language with some carefully engineered implementations of a bioinformatics library is a good choice to quickly solve a problem with reasonable performance however the amounts of data the bioinformatics community is facing in the coming_years and the need to handle natures resources carefully implies that using a high performance compiled language is still beneficial for certain problems recently rust http www rust lang org has gained attention as a new programming_language combining speed with memory safety and high_level syntactical features being compiled with llvm rust has many advantages of low_level system programming_languages such as speed and a small memory_footprint supporting automatic type inference its code is often less verbose than c or c code with rust type inference happens at compile time such that runtime overhead appearing with scripting languages like python can be avoided the key feature of rust is a concept of ownership and borrowing of variables that enables the compiler to automatically decide about lifetime of objects during compile time making an online memory management superfluous without requiring manual freeing of resources at the same time this concept prevents common sources of errors with low_level languages like accessing invalid memory regions finally the ownership concept enforces thread safety such that race conditions cannot occur these features make rust a promising solution to above tradeoff problem in this work we present rust bio the first general_purpose bioinformatics library for the rust programming_language rust bio provides a high_level fast and safe api for many state of the art data_structures and algorithms used in bioinformatics 
