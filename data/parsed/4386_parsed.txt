sprites detection of deletions from sequencing_data by re aligning split_reads motivation advances of next_generation and availability of short_read enable the detection of structural_variations svs deletions an important type of svs have been suggested in association with genetic_diseases there are three types of deletions blunt deletions deletions with microhomologies and deletions with microsinsertions the last two types are very common in the human_genome but they pose difficulty for the detection furthermore finding deletions from sequencing_data remains_challenging it is highly appealing to develop sensitive and accurate methods to detect deletions from sequencing_data especially deletions with microho mology and deletions with microinsertion results we present a novel method called sprites split_read realignment to detect structural_variants which finds deletions from sequencing_data it aligns a whole soft_clipping read rather than its clipped part to the target_sequence a segment of the reference which is determined by spanning reads in order to find the longest prefix or suffix of the read that has a match in the target_sequence this alignment aims to solve the problem of deletions with microhomologies and deletions with microinsertions using both simulated_and we show that sprites performs better on detecting deletions compared with other current methods in terms of f score availability_and sprites is open_source and freely_available at https github com zhangzhen sprites contact structural_variation sv was originally defined as insertions deletions and inversions larger than k bp in size and now has been extended to include much smaller variants e g those bp in length and more types of variants such as translocation and tandem_duplication these variants are prevalent in human populations and are associated with human_diseases complex_traits and evolution thus finding svs is an important task recent_advances in high_throughput make it possible to reveal more variants than ever before many efforts have been made to detect_variants from high_throughput sequencing_data for example the genomes_project v c the author published_by all_rights for permissions please_e journals permissions_oup comconsortium has released sv data of individuals from populations some methods are specially_designed for detecting a specific type of svs svseq for deletion and mindthegap for insertion a deletion indicates a dna_segment missing in an individual genome also known as a donor sample genome compared with the reference_genome eighty_percent of genetic_disorders in the disease database database chromosomal imbalance and phenotype in humans using ensembl resources decipher are caused by deletions deletions are such an important type of svs that almost every sv discovery tool has developed a module to find deletions we focus on the discovery of deletions in this article read_pairs are the most common form of current sequencing_data dna libraries are generally constructed by shearing a genome into fragments cloning and size selecting the fragments a library is a collection of fragments with a roughly_equal size the length of a fragment excluding adapters at two ends is commonly referred to as the insert_size the insert_size varies from fragment to fragment the exact value of insert_size for each fragment cannot be determined but its approximate value can be estimated by sampling the normal range of insert_sizes is specified through the library mean and standard_deviation two reads of a read_pair are generated by sequencing two ends of a fragment before calling variants are performed these read_pairs need to be mapped to a reference_genome using read_mappers such as bwa and bowtie if two reads of a read_pair are successfully mapped its insert_size is then given as the distance between two corresponding locations on the reference_genome an anomalous insert_size indicates a value beyond the normal range the corresponding read_pairs are called discordant read_pairs analyzing discordant read_pairs to reveal variants such as read_pair method is one of the most common approaches many tools adopt such approach such as breakdancer pemer variationhunter and gasv although read_pair methods can improve the resolution of calling with high coverage data they uncover variants by giving only inexact positions of breakpoints the read_depth method is another approach that gives approximate breakpoints read_depth refers to the number of reads_mapped to a particular part of the genome and can indicate how many copies of a region are present but it cannot indicate where the copies occur segseq ewt and cnvnator are some examples of algorithms that apply this approach assembly and split_read methods are two types of approaches that are able to detect_variants with base_pair breakpoint resolution assembly methods exploit aberrations from the reference_genome to identify locations where variants might be and then assemble reads just for that area comparing the assembled_contigs to the area on the reference_genome can detect_variants with exact breakpoints however assembly methods have limitations although only local_assembly is performed all reads of the library are processed in order to construct the k_mer spectrum that is required for assembly the step requires a large amount of time and memory to run it also tends not to deal well with heterozygous variants which occur on only one of a pair of homologous_chromosomes split_reads refer to those that cover breakpoints of variants whether they are single_end or paired_end split_read methods as their name implies derive variants from these split_reads read_aligners can help identify split_reads given a pair of reads r i r i if r i is mapped and r i is either unmapped or soft clipped at the or end r i may be a split_read in some cases it may not be a split_read due to either sequencing_error or mapping error there are two ways to use split_reads to detect_variants via split read_mapping and via soft clipped mapping split read_mapping focuses on unmapped reads an unmapped read was first broken up into two parts then these two parts are respectively mapped to the reference_sequence which results in the breakpoint of the corresponding variant being pinpointed examples of split read_mapping based_methods include pindel age svseq prism and delly soft clipped mapping focuses on reads with the or end soft clipped these reads are also called soft_clipping reads one breakpoint of the variant is specified by the mapping location where soft_clipping occurs the other breakpoint is determined by aligning the soft clipped segment of the read to the reference_sequence clipcrop crest svseq and socrates are representatives of soft clipped mapped based_methods split_read methods have a few disadvantages such as time and memory inefficiency and both high false_positive some of them do not perform well on low coverage data three deletion types are observed in the human_genome blunt deletions nothing special happened at the breakpoints deletions with microhomologies two small identical_sequences at deletion breakpoints and deletions with microinsertions deletion breakpoints having a small untemplated sequence inserted studied the breakpoints of deletions and found that of breakpoints have bp of microhomology of breakpoints contain bp of inserted sequence and of breakpoints have both simultaneously only a few breakpoints have blunt ends the presence of microhomology and microinsertion creates problems for re aligning the clipped part microhomology in a soft_clipping read causes the clipped part to be too short for the alignment the alignment algorithm returns multiple hits for the clipped part finding the correct one among these hits is challenging microinsertion in the clipped part causes the alignment to fail because inserted sequence cannot match the reference however split read_mapping can deal with microhomology and microinsertion pindel uses the pattern growth approach to report deletions with microinsertions age aligns the and ends of two given sequences simultaneously and creates a jumping gap to address their presence delly follows the age approach and makes changes to age despite the availability of these tools methods with high_accuracy are required for the detection of deletions with microhomologies and microinsertions in this article we present a new method called sprites split_read re alignment to detect structural_variants for detecting deletions from sequencing_data sprites can solve the problem that microhomologies and microinsertions cause it re aligns the whole read rather than the clipped part to the target_sequence a segment of the reference in order to find the longest prefix or suffix of the read that has a match in the target_sequence in the case of microhomology the length of the sequence to be matched is extended to the length of clipped part plus the length of microhomology the longest mapped prefix or suffix of the read can usually cover microhomology thus the deletion call is easy to determine in the case of microinsertion the longest matched prefix or suffix of the read can avoid the impact of microinsertion on the detection the comparison of the re alignments of the soft clipped segment and the whole read is illustrated in sprites uses alignments produced by bwa while it can also use alignments produced by other read_aligners that support or end soft_clipping like bowtie re alignment is one of most time consuming tasks in the detection a target_sequence is a segment of the reference for a soft_clipping read sprites relies on its spanning read_pairs to determine the size and location of target_sequences given that most of these target_sequences have a length of only hundreds of base_pairs re aligning soft_clipping reads to them saves a large amount of time the input_file has the size on the order of gigabytes sprites transverses it from start to end only once and only stores information about soft_clipping reads that are useful for deletion detection which reduces sprites memory_footprint besides its great performance on lowcoverage data sprites can also be used for the analysis of highcoverage data we tested it extensively on the simulated_data and real sequencing_data and compared it with four other detection_tools including svseq lumpy delly and pindel the results show that among these tools sprites is highly_sensitive at the relatively low false_discovery and thus has the greatest f scores in many cases the major_contributions of this article include our method can find the longest prefix or suffix of a soft_clipping read that has a match in the target_sequence by performing the re alignment our method solves the problem of deletions with microhomology and deletions with microinsertion which are very challenging to be found from the sequencing_data our method limits the alignment_length so that time and memory_usage are dramatically_reduced a piece of open_source is implemented based on our method and can be freely_available we compared sprites with the four most commonly used sv detection_tools i e pindel svseq delly and lumpy pindel is the first tool that relies on the concept of splitting reads to detect_variants besides deletions it is able to call other types of variants such as insertions and inversions svseq is a tool that specializes in finding deletion calls deletions are called by realigning the soft clipped sequence of reads which is similar to our tool it focuses on analyzing low coverage data the latest_version of svseq can only process one chromosome at a time when working on whole_genome data we first ran svseq for each chromosome or contig of the human_reference and then concatenated the results of individual chromosomes to obtain the final results lumpy is a probabilistic based_approach for sv discovery which integrates multiple sv_detection signals such as read_pairs split_reads thereby achieving a substantial improvement in detection as compared with other popular sv tools such as breakdancer gasvpro homozygous variants are commonly used for the detection evaluation however heterozygous variants are prevalent variants which are often less deleterious but more frequent among genetic_disorders compared with homozygous variants moreover the detection of heterozygous variants plays a substantial role in the tumor study because that real_samples tend to be a mixture of abnormal and normal genomes and tumor_samples usually to have more heterogeneous variants than homozygous ones however detecting heterozygous variants is problematic so we use heterozygous variants for the evaluation besides homozygous variants ryan layer the author of lumpy provided us with two artificial genomes one genome with randomly_generated deletions of size bp to kbp the other genome with non randomly_generated deletions the deletions were publicly released by the genomes_project svsim https github com gregoryfaust svsim an sv simulator was used to generate these genomes by introducing these deletions into the b version of human reference also known as grch version the fasta file of the b version can be found at ftp ftp genomes ebi ac uk vol ftp technical reference the location of these simulated deletions in these genomes was recorded in two bedpe files we used the first genome for homozygous_deletion detection and the second genome for heterozygous_deletion detection the first genome was intended for homozygous_deletion detection we used wgsim https github com lh wgsim a read simulator to sequence this genome with and haploid coverage respectively to generate paired_end of length_bp the insert_size of paired_end was centered at bp with the standard_deviation equal to bp generated_reads contained sequencing_errors the overall error_rate of the second genome was intended for heterozygous_deletion detection in order to generate heterozygous deletions a normal genome and an abnormal genome were required we used the b version of the human_reference as the normal genome and the genome with deletions as the abnormal genome pairedend reads were generated by using wgsim to sequence the two genomes with and sv allele_frequencies at and respectively for example we generated_reads with sv allele_frequency at coverage like this we used wgsim to sequence the normal genome at haploid coverage and sequence the abnormal genome at haploid coverage then the two sets of reads were combined to form pair_end with sv allele_frequency at coverage reads for heterozygous deletions have the same properties with reads for homozygous_deletions whether reads are for homozygous_deletions or for heterozygous deletions they need to be mapped to the reference for use with detection_tools bwa aln was used to map reads then alignment files were sorted and indexed by samtools lumpy required as input two bam_files a file that was the original bam_file and a file that represented split read_alignment the split read_alignment file was generated as follows split_reads were first extracted from the original bam_file using a custom script provided along with the lumpy program these split_reads were then realigned by yaha furthermore we used the data of the na individual released by the illumina platinum genomes_project and the data of the five other individuals na na na na and na provided by the genomes_project as the real_data for the evaluation sprites uses two micro intervals to represent the two breakpoints of a deletion micro intervals reflect the fact that microhomologies and microinsertions occur at deletion breakpoints lumpy also uses two intervals to represent breakpoints however for each deletion svseq and pindel predicted two breakpoints were converted to two breakpoint intervals with a length_bp for each known deletion the same conversion was performed since delly provides the confidence_interval of deletion breakpoints we used them as breakpoint intervals and no conversion was performed a deletion call is represented by two breakpoint intervals a and b a known deletion is represented by two breakpoint intervals a and b the deletion calls overlaps the known deletion if and only if a overlaps a and b overlaps b bedtools was used for checking such overlaps a call is a true_positive tp if the call overlaps a known deletion otherwise it is a false_positive fp false_negatives fn refer to the known deletions that sv detection_tools failed to report a comprehensive measure called f score is mainly used to evaluate the methods the f score is defined as the harmonic mean of the sensitivity and the precision fdr the sensitivity is defined as tp tpfn while the false_discovery fdr is defined as fp tpfp sprites is a new deletion detection method based upon re aligning soft_clipping reads results of tests on both simulated_and show that sprites is more sensitive in low coverage data the false_discovery of sprites is also low as a result sprites performs the best overall in terms of the f score in low coverage data furthermore there is also evidence that realigning soft_clipping reads is more effective than realigning their soft clipped segments tests on simulated_data show that sprites is able to detect deletions with microhomologies and microinsertions at breakpoints in addition to blunt deletions we have only used reads with soft_clipping at the end because end has generally higher quality than end the reason why sprites does not work well in high coverage data may be that sprites does not directly use paired_end information for the detection since there is plenty of paired_end information in high coverage data such information could play a more important role in the detection in high coverage data than in low coverage data utilizing paired_end information in order to improve its performance in high coverage data is one of directions of our future work the development of next_generation has increased read_length from to bp as a result sv_detection methods have shifted from pure pe methods to sr and to hybrid methods such pe sr methods as the trend continues we believe that re aligning split_reads based_methodology will play_an in sv_detection in population scale and cancergenome studies because such methods are applicable to these types of data 
