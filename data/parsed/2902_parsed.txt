meta idba a de_novo assembler for metagenomic_data motivation next_generation techniques allow us to generate reads from a microbial environment in order to analyze the microbial_community however assembling of a set of mixed reads from different species to form contigs is a bottleneck of metagenomic research although there are many assemblers for assembling reads from a single_genome there are no assemblers for assembling reads in metagenomic_data without reference genome_sequences moreover the performances of these assemblers on metagenomic_data are far from satisfactory because of the existence of common regions in the genomes of subspecies and species which make the assembly problem much more complicated results we introduce the meta idba algorithm for assembling reads in metagenomic_data which contain multiple_genomes from different species there are two core steps in meta idba it first tries to partition the de_bruijn into isolated components of different species based on an important observation then for each component it captures the slight variants of the genomes of subspecies from the same species by multiple_alignments and represents the genome of one species using a consensus_sequence comparison of the performances of meta idba and existing assemblers such as velvet and abyss for different metagenomic_datasets shows that meta idba can reconstruct longer contigs with similar accuracy availability meta idba toolkit is available at our websitemetagenomic research studies the genetic_information in an entire microbial_community it plays an important role in microbiology because over of microbes can neither be isolated nor cultured recent_advances in next_generation allow us to generate reads from genomes of multiple species in these samples in an effective_manner the set of reads obtained is very complicated which makes the assembling of genomes of species that exist in the sample extremely_difficult there are two main approaches to study reads from these samples one is to group called binning the reads according to some biological_markers or structural_features then reads belonging to different species are studied the other is to deduce the potential biological_functions of the whole community by studying the reads directly using gene prediction or function_annotation since the reads from the next_generation are still relatively short it to whom correspondence should be addressed is more effective if longer contigs can be constructed from the reads before conducting the study even though we are not able to assemble the genome of every species high_quality assembly results of the contigs are desirable in both approaches if the assembled_contigs are short and erroneous the accuracy of binning gene prediction function_annotation etc will be impaired thus assemblers that can generate longer and more accurate contigs will definitely facilitate the study of metagenomic_data if similar reference_genomes exist in the database one can assemble reads by first aligning them to the reference_genomes however as over of microbes in metagenomic_data are unknown de_novo assemblers are needed to assemble reads without any reference_genomes to our knowledge currently there are no de_novo metagenome specific assemblers available assemblers such as euler velvet abyss soapdenovo are for single_genome but are used in metagenomic study all these assemblers are based on the de_bruijn which is a common approach to perform de_novo in the de_bruijn a vertex represents a length k substring called k_mer and an edge connecting vertices u and v represents u and v appearing consecutively in a read all these assemblers generate the de_bruijn from reads and then apply some error removal methods e g removing tips and merging bubbles to modify the graph_based on its topological_structure simple paths in the graph are outputted as contigs and paired_end information might be applied to further merge the contigs these existing assemblers do not work well for metagenomic_datasets except for some very small_datasets containing specific species two main properties of a reasonably complicated metagenomic_dataset make these assemblers fail to produce long contigs i polymorphisms among similar subspecies and common genomic_regions shared by different species and ii uneven abundance ratios of species in a sample the polymorphism of similar subspecies especially subspecies of the same species consists of very similar sequences with few variations single nucleotide variation short insertion or deletion or genomic_rearrangements etc and each variation introduces a branch in the de_bruijn we call these branches sp branches another source of branches is due to the common or similar genomic_regions say housekeeping_genes shared by different species we call these branches cr branches these two types of branches which do not exist when assembling single genomes would make the de_bruijn for metagenomic_data very complicated since existing assemblers output simple paths in the graph as contigs these extra branches caused by common regions in different species prevent the construction of long contigs some assemblers resolve branches by merging similar sequences as bubbles into one sequence a bubble is defined as several similar paths with the same start vertex and the same end vertex in the de_bruijn bubble merging helps to merge similar regions and reduce complexity of the de_bruijn an important assumption used by assemblers to remove bubbles for single genome_assembly is that the bubble is caused by a few single_nucleotide snp or errors in reads thus the simple paths inside a bubble are very similar except for a few nucleotides however the bubbles found in the graph for metagenomic_dataset do not follow this assumption different bubbles mix together to make the start vertex and the end vertex very difficult to be identified some of these bubbles are formed by a mixture of spand cr branches shows an example of this phenomenon in which every simple path is contracted into a vertex for visualization all branches at a vertex in this graph normally lead to some other vertex in the same component but it is uncertain that these are bubbles for merging if we look closer at these bubbles even if the bubble is formed only by sp branches because of variations in subspecies the multiple paths inside the bubble may differ a lot maybe with larger insertion_deletion existing_approaches for merging bubbles for single genome_assembly do not work for this case thus they will fail to resolve these bubbles and are unable to construct long contigs even if all bubbles can be identified it is not easy to merge them together to form a consensus to resolve branches in a de_bruijn existing assemblers also try to use paired_end information to help find paths with paired_end support so as to eliminate those branches caused by erroneous reads and to construct longer contigs in the case of multiple subspecies each path will have a lot of support since they are not caused by erroneous reads but variations in subspecies and the assemblers are not able to resolve these branches easily moreover since the contigs are short applying paired_end information becomes difficult because usually paired_end information can only be applied to connect long contigs to show the complexity of a de_bruijn for metagenomic_dataset compares graphs and assembly results of simulated reads sampled from a single_genome escherichia_coli and from five different e coli subspecies genomes shows that the five e coli subspecies contain about twice the number of k_mers as that of a single e coli subspecies but times more branches as that of single subspecies this makes the graph complicated and genome_assembly difficult in fact the performance of all the assemblers is poor when there are a lot of subspecies the n values of velvet abyss and soapdenovo drop from and bp for single_genome data to and bp respectively for metagenomic_data with five subspecies uneven abundance ratios in metagenomic_data introduce another problem in assembly because existing assemblers cannot distinguish erroroneous reads sampled from genomes with high_abundance ratios and reads from genomessimulated length reads are sampled randomly from references with error and insert distance with a depth of the value of k is set to for all assemblers 
