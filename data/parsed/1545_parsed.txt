genetics_and efficient haplotype matching and storage using the positional burrows_wheeler transform pbwt motivation over the last few years methods based on suffix_arrays using the burrowswheeler_transform have been widely used for dna sequence_read matching and assembly these provide very fast search algorithms linear in the search pattern size on a highly com pressible representation of the dataset being searched meanwhile algorithmic development for genotype data has concentrated on statistical_methods for phasing and imputation based on probabilistic matching to hidden_markov representations of the reference data which while powerful are much less computationally_efficient here a theory of haplotype matching using suffix_array ideas is developed which should scale too much larger datasets than those currently handled by genotype algorithms results given m sequences with n bi_allelic variable_sites an o nm algorithm to derive a representation of the data based on positional prefix arrays is given which is termed the positional burrowswheeler_transform pbwt on large_datasets this compresses with run length encoding by more than a factor of a hundred smaller than using gzip on the raw_data using this representation a method is given to find all maximal haplotype matches within the set in o nm time rather than o nm as expected from naive pairwise_comparison and also a fast algorithm empirically independent of m given sufficient memory for indexes to find maximal matches between a new sequence and the set the discussion includes some proposals about how these approaches could be used for imputation and phasing given a large collection of aligned genetic_sequences or haplotypes it is often of interest to find long matches between sequences within the collection or between a new test sequence and sequences from the collection for example sufficiently_long identical substrings are candidates to be regions that are identical by descent ibd from a common_ancestor i will use the word substring to denote contiguous subsequences as is standard in the computer science text matching literature when using imputation approaches to infer missing_values one wants to identify sequences that are as close as possible to the test sequence around the location being imputed such as those that are ibd or at least share long matches with the test sequence maximizing the number of such long matches could also form the basis of genotype phasing naive substring match testing would take on m time for each test sequence where there are n variable_sites and m sequences and hence on m time for complete all pairs comparison within a set of sequences by keeping a running match score to find maximal matches as in blast it is straightforwardly possible to reduce this to o nm per single test and so onm across the whole collection but this is still large for large m recently suffix_array based_methods have proved powerful in standard sequence_matching as exemplified by bowtie bwa and soap here an approach based on suffix_arrays is described that can find best matches within a set of sequences in o nm time following preprocessing of the dataset also in o nm time and empirically best single haplotype matches in o n time the differences between the algorithms described here and standard suffix_array based sequence_matching are derived from the fact that there are many sequences that are all of the same length and already aligned so on the one hand there is no need to consider offsets of the test sequence with respect to the sequences in the collection but on the other hand the test sequence is long and we are looking for maximal matches of an arbitrary substring of the test sequence not of the whole test sequence here i present initial results on simulated_data a dataset of haplotype sequences covering a mb section of genome_sequence was simulated using the sequentially markovian coalescent simulator macs chen using essentially the command macs e t r in fact a larger simulation was undertaken which crashed a little beyond mb and the remaining material was trimmed down to this set there are segregating sites in this dataset the raw macs output contains essentially the haplotype sequences written in s and s and so is approximately gb in size this compresses with gzip to gb an initial_implementation pbwt of the key algorithms was produced this uses single byte run length encoding for the pbwt with the top bit encoding the value the next two bits selecting whether the length is in units of or and the remaining bits giving the number of units for runs but this typically requires bytes and for runs but k this typically requires bytes all experiments were carried_out on an apple mac air laptop with a ghz intel core duo processor using a single core encoding the dataset of sequences described above took s user plus system generating a pbwt representation that is mb in size over times smaller than the gzip compression of the raw_data further results including application to subsets of the data are given in showing that the relative gain increases with the number of sequences indicating clearly the non linear benefits of the algorithm this can be clearly seen by the observation that for each increase of a factor of ten in the number of sequences the average number of bytes used by the pbwt to store the haplotype values at a site only approximately doubles as a test on real_data similar measures were applied to the chromosome data from the genomes_project phase data release genomes_project consisting of haplotypes at sites the gzip file of this data took mb whereas the pbwt used mb nearly a factor of six smaller not far from the factor expected based on the simulated_data next algorithm was implemented to find all set maximal matches within the simulated_datasets as expected the timei have presented here a series of algorithms to generate positional prefix array data_structures from haplotype sequences and to use them for very strong compression of haplotype_data and time and space efficient haplotype matching in particular the matching algorithms remove a factor of m the size of the set of haplotype sequences being matched to from the search time taken by direct pair_wise comparison methods this makes it possible to find all best matches within tens_of of sequences in minutes and generates the potential for practical software that scales to millions of sequences although the algorithms are presented for binary_data they can be extended to multi allelic data with a little care these algorithms share aspects of their design with analogous algorithms based on suffix_arrays for general string matching but are structured by position along the string resulting in substantial differences one consequence is that unlike with suffix_array methods where linear time sorting algorithms are non trivial building the sorted positional prefix arrays in linear time using algorithm is straightforward the approach used here is reminiscent of that used byto generate a string bwt from very large sets of short strings with respect to efficient representation it is interesting to note that the original bwt was introduced byfor string data compression not search and it in fact forms the basis of the bzip compression algorithm have previously explored the use of bwt compressed self index methods for efficient compression and search of genetic sequence_data from many individuals but this does not require a fixed alignment of variable_sites as in the work presented here and is substantially different all the algorithms described here require exact matching without errors or missing_data as for sequence_matching if a more sensitive search is required that permits errors it is still possible to use the exact match algorithms to find seed matches and then join or extend these by direct testing this would typically be the approach taken by production software but having powerful_methods to identify seeds is key to performance an alternative to using suffix prefix array methods in sequence_matching is to build a hash_table to identify exact seed matches analogous to the creation of position prefix arrays described here it would be possible to build a set of positional hash tables for each position in the haplotype sequences hash based_methods when well tuned can be faster than suffix_array based_methods because the basic operations are simpler but they typically require greater memory particularly in cases where the suffix representation can be compressed as it can be here a problem with genotype data not present in standard sequence_matching is that the information content of positions varies_widely with a preponderance of rare sites with very little information which would mean that the length of hash word would need to change depending on position in the sequence an alternative would be to build hashes based on a subset of sites with allele_frequency greater than some value such as or in some frequency range but this would lose information leading to false seed matches most research into algorithms for analyzing_large sets of haplotype or genotype data has focused on statistical_methods that are powerful for inference but only scale up to a few thousand sites and sequences e g see marchini and howie recently accelerated methods have been developed that can handle data up to tens_of of sequences e g or delaneau et_al however these methods provide approximations to the statistical matching approaches and are still much heavier than the algorithms presented here over a million people have been genotyped and although there are logistical issues in bringing together datasets on that scale genotype data on sets of people are becoming available one approach to more efficient phasing and imputation may be to use computationally_efficient approaches such as the positional prefix array methods to seed matches for statistical genotype algorithms or at other computational bottlenecks for example in their beagle software browning and browning build a probabilistic hidden_markov from a variable_length markov_model of the local haplotype sequences which is essentially derived from a dynamic truncation of the positional prefix array although their algorithms using this probabilistic_model take them in a different direction i suggest that the methods described here could be used to significantly speed up the model_building phase of beagle alternatively a more direct approach may also be possible most phasing and imputation algorithms build a model from the entire dataset then thread each sequence in turn against it to provide a new phasing based effectively on a series of matches instead the positional prefix algorithms progress jointly along all sequences if we start at both ends of the data then at some position k we have information about matches in both directions based on the current phasing and can propose an assignment of alleles for all sequences at k in a single step before incrementing k approaches based on this idea may be fast and complementary to current methods 
