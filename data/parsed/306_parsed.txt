genome_analysis andi fast and accurate estimation of evolutionary_distances between closely_related genomes motivation a standard approach to classifying sets of genomes is to calculate their pairwise_distances this is difficult for large samples we have therefore developed an algorithm for rapidly computing the evolutionary_distances between closely_related genomes results our distance measure is based on ungapped local_alignments that we anchor through pairs of maximal unique matches of a minimum_length these exact_matches can be looked up efficiently using enhanced_suffix and our implementation requires approximately only s and mb ram mbase analysed the pairing of matches distinguishes non homologous from homologous regions leading to accurate distance estimation we show this by analysing simulated_data and genome samples ranging from escherichia_coli shigella genomes to genomes of streptococcus_pneumoniae availability_and we have implemented the computation of anchor distances in the multithreaded unix command_line program andi for anchor distances c sources and documentation are posted atthe spread of infectious_diseases is nowadays often monitored by sequencing the genomes of the outbreak strains since a given pandemic is usually caused by the rapid expansion of a single_clone monitoring by sequencing leads to the accumulation of hundreds to thousands of similar genome_sequences for example studied the spread of the multi_drug escherichia_coli strain st which causes extra_intestinal infections in humans the authors sequenced outbreak strains and reconstructed their phylogeny this revealed that the outbreak was caused by a single lineage of st on an even larger scale studied pneumococcal carriage in a refugee camp by sequencing strains of streptococcus_pneumoniae which causes pneumoniae in humans again phylogeny reconstruction based on these genomes was an early step in the study classifying bacteria by clustering their genomes is set to become routine for this purpose computed a multiple_sequence of their e coli st strains using the program mugsy it is based on the mummer software which makes mugsy one of the fastest multiple genome aligners available it took only h to align complete e coli genomes however the run time of mugsy becomes unacceptable when applied to the recently collected_samples of hundreds or even thousands of bacterial_genomes for their study of pneumococcal isolates mapped the sequencing_reads onto a reference_genome thereby approximating a multiple_sequence such alignment by mapping is widely used andhave shown that its accuracy can be further improved by mapping against multiple reference_genomes instead of the customary single reference their implementation of this idea realphy requires min and mb mbase analysed the genome of s pneumoniae is mbase long so realphy would run days on the s pneumoniae isolates however a more prohibitive aspect of realphy might be the ram requirement of tb perhaps surprisingly it is not necessary to compute an explicit alignment for phylogeny reconstruction this insight has sparked interest in devising alignment_free for rapidly calculating pairwise_distances between genomes haubold which can then be clustered using various quick algorithms alignment_free distance computation is either based on counting words of a certain length or recording match lengths when counting words there is a choice between the traditional approach of counting exact words and a more recent method of looking for words that enclose one mismatch the latter is implemented in the program co phylog which gives better distances than exact word counting while requiring only moderate additional resources devised an alignment_free estimator of genetic_distance based on match lengths the expected match length is the inverse of the proportion of mismatches for example if of positions between two genomes are mismatched the expected match length is domazet loo and haubold implemented this idea using a generalized suffix_tree of all input_sequences to look up the match lengths their program kr computes the distances between the complete_genomes of e coli shigella_strains in just min on a single processor however this takes gb ram and kr has been criticized for excessive ram utilization moreover yi and jin noted that co phylog gave a better phylogeny when applied to the benchmarking sample of e coli shigella genomes this has prompted us to devise a replacement for kr our new strategy is to look for mismatches that are bracketed by long exact_matches which we call anchors we show through simulation that the resulting program andi for anchor distances is accurate fast and memory_efficient moreover we apply andi to three sets of bacterial_genomes the genomes of e coli shigella yi and jin used for benchmarking co phylog the genomes of e coli st studied byof which they sequenced strainsand the genomes of s pneumoniae sequenced by in each case andi quickly recovers pairwise_distances for the e coli samples we compare the new distances to alignment based distances and find they are so similar that they yield almost identical phylogenies our new distance measure d a approximates local_alignments by anchoring them with long unique matches the requirement that the matches are equidistant in the query and the subject is equivalent to restricting the analysis to ungapped alignments andi is therefore a cross between the early version of blast and the genome aligner mummer from early blast it inherits the idea of ungapped local_alignments from mummer the idea of looking up unique matches by indexing the subject domazet loo and haubold had previously used the power of indexing algorithms to estimate the number of substitutions from the match length_distribution their program kr works on the same principle as the average common substring distance except that kr implements theory byto transform common substring lengths to mutation_rates fast as the average common substring methods are they suffer from two disadvantages first local fluctuations in the mutation_rate affect the average match length as a result the same number of mutations can lead to different distances depending on the degree to which the mutations are clustered have used this property to devise a test for recombination andi does not have this problem as it counts mutations directly rather than inferring them from match lengths the second disadvantage of match length based_methods is that matches induced by non homologousfast and accurate estimation of evolutionary distancesregions are hard to distinguish from matches induced by highly_divergent regions even a moderate divergence of k implies an average match length of compare this to the expected length of a random match in a mbase sequence which according to the theory byis to overcome_this of match length distances leimeister and morgenstern proposed a k mismatch generalization they show that this outperforms the classical zero mismatch version of their distance however it remains_unclear how to choose the critical parameter k when applying this method instead of a generalized mismatch approach we bracket mutations with paired anchors this should give more accurate results than kr and andi did compute a better tree for e coli genomes than co phylog which in turn gave a better tree than kr hence andi is substantially more accurate than kr the accuracy of andi is excellent when applied to simulated sequences with a wide_range of substitution_rates k however at k the search for suitable anchors fails increasingly often which cannot be overcome by lowering the minimum anchor length supplementary hence our method is effectively limited to k to get an intuition for the evolutionary times implied by k consider the average synonymous substitution_rate in mammals of the last common_ancestor that can occur in a tree restricted to k lived years_ago this would allow the analysis of great_apes which diverged years_ago and mice muridae years but not of these two groups together years apart from maximizing accuracy we strove to minimize time and memory_usage by implementing three ideas i streaming of query against subject as first implemented in vmatch speeds up suffix_array construction compared with the suffix_array of all input_sequences underlying kr it also uses much less memory our second idea was ii to construct only as many enhanced_suffix as there are genomes in the sample rather than constructing an enhanced suffix_array for each pairwise_comparison this means that for a sample of n genomes andi requires only n suffix_array constructions whereas a program like mugsy requires the computation of on suffix_trees the third idea was iii multithreading which allows access to the multi processor architecture of modern computers however other programmers might have chosen a different combination of time memory_consumption for example vmatch uses half as much memory as andi for suffix_array construction but is slower than the libdivsufsort library we used when clustering hundreds of genomes efficiency becomes paramount as shown in andi uses only s mbase and bytes bp when applied to simulated sequences there is an intimate connection between the efficiency of andi and its limitation to closely_related sequences andi approximates local_alignments by concatenating exact_matches looking up exact_matches is fast but this strategy breaks down for divergent sequences where homologous matches become shorter than random matches this phenomenon is also the reason why fast genome alignment programs like mauve and mugsy work best when applied to closely_related genomes the accuracy and efficiency observed with simulated_data carried over to the analysis of genomes here we compared andi to co phylog as haubold had found this to be the best alignment_free distance estimator for long_sequences however andi gave a more accurate tree when compared to the tree based on the mugsy alignment this improvement in accuracy came without a time penalty as co phylog computed its tree times_faster than mugsy while andi was a thousand times_faster than the alignment the superior speed of andi comes from the structure of its algorithm and the multithreading without multithreading andi would still be times_faster than co phylog when applied to the e coli shigella genomes the memory_consumption of andi is strictly linear in the number of threads while time is roughly inversely proportional to the number of threads this gives the a b phylogeny of stains of s pneumoniae a based on distances computed using co phylog user the opportunity to trade speed for memory and processors depending on the hardware available aligning the genomes of e coli st took mugsy days and gb ram compare this to the h min it took mugsy to align e coli genomes in other words a times larger sample took times longer to align in contrast andi took with min s only times longer yielding the correct classification of strains into clades ac in moreover the memory requirement of mugsy grew fold while that of andi grew by only to gb these comments are not meant to imply that the mugsy alignment computed in the original study was superfluous it was used for a number of analyses apart from phylogeny reconstruction including the detection of horizontal_gene however quick clustering of genomes is useful if only as a quality_control step for our final application we chose the set of genomes of s pneumoniae because here an alignment program like mugsy would run far longer than anyone is willing to wait the current method for comparing sets of bacterial_genomes this size is mapping the reads to a reference_genome there is some debate as to the accuracy of the resulting trees andi takes as input assembled_contigs which are generated from the raw_reads early on in all genome_sequencing given these contigs andi analyses them in h and min using gb ram on a processor computer such computing_resources are available in most genomics labs the three outlier strains identified by andi are identical to those found by co phylog after a days run this is gratifying and underlines the usefulness of our program 
