genome_analysis pear a fast and accurate illumina paired_end merger motivation the illumina paired_end sequencing_technology can generate reads from both ends of target dna_fragments which can subsequently be merged to increase the overall read_length there already exist tools for merging these paired_end when the target fragments are equally long however when fragment_lengths vary and in particular when either the fragment_size is shorter than a single_end read or longer than twice the size of a single_end read most state of the art mergers fail to generate reliable results therefore a robust tool is needed to merge paired_end that exhibit varying overlap lengths because of varying target fragment_lengths results we present the pear software for merging raw illumina paired_end from target fragments of varying length the program evaluates all possible paired_end overlaps and does not require the target fragment_size as input it also implements a statistical_test for minimizing false_positive tests on simulated and empirical data show that pear consistently generates highly_accurate merged paired_end a highly optimized implementation allows for merging millions of paired_end within a few minutes on a standard desktop computer on multi core architectures the parallel version of pear shows linear speedups compared with the sequential version of pear availability_and pear is implemented in c and uses posix threads it is freely_available www exelixis lab org web software pear the illumina sequencing_platform can produce millions of short_reads in a single run the deep_sequencing capability and low_cost of the sequencing by synthesis technology is useful for a plethora of applications ranging from whole_genome to profiling microbial_communities by sequencing the hypervariable_regions of the s ribosomal_rna rrna gene however single_end produced by the illumina_platform typically have a length that ranges from to bp furthermore there is an exponential_increase in error_rates ers along the reads the illumina_platform can also generate paired_end by sequencing the forward and reverse strands of each target dna_fragment if the target dna fragment_size is smaller than twice the length of the single_end that is if there exists an overlap the corresponding paired_end can be merged into a fragment by merging paired_end the overlapping region between them can also be deployed for correcting sequencing_errors and potentially yield sequences of higher quality merging paired_end is the first processing step in a plethora of sequence analysis_pipelines hence its accuracy is crucial for all downstream_analyses there exist several proof_of mergers such as itag bipes and shera some production level mergers such as flash magocandmagocand salzberg pandaseq and cope have also been recently_introduced shera merges the reads by maximizing the number of matches between the paired_end both shera and flash see later in the text ignore the quality_scores of the base calls shera merges all reads and leaves it to the user to decide which merged reads are correct because it is a proof_of implementation it is up to times slower than competing mergers flash constructs merged reads that maximize the overlap length to matches ratio flash requires the mean dna fragment_size and standard_deviation of the fragment_size as input_parameters therefore it can only merge paired_end into fragments of almost identical size furthermore our tests show that flash performs poorly when the overlaps between reads are short section cope deploys an analogous approach as flash for finding the best overlap but also takes_into the quality_scores of mismatches cope is designed to handle deep genome sequencing_datasets thus it considers that k_mers that occur infrequently are likely to be sequencing_errors cope exhibits_high memory_requirements and also relatively long execution times pandaseq merges fragments by maximizing the probability of true sequence matches given the observed sequences it combines quality_scores with sequence matches and thereby improves merging quality in contrast to flash pandaseq works well with short overlap regions and does not require prior_knowledge of the target dna fragment_size however it assumes that all paired_end can be merged thus if the sample contains to whom correspondence should be addressed the author published_by this is an open_access the terms of the creative commons attribution license http creativecommons org licenses by which_permits distribution and reproduction in any medium provided the original_work dna_fragments that are at least twice as long as the single_end pandaseq exhibits a high false_positive fpr finally most current paired_end mergers assume that the dna_fragments are longer than the individual single_end when this does not hold for example when sequencing the v region of s rrna_genes of bacterial samples fragment sizes range between and bp with read_lengths of bp see case c in current mergers will generate erroneous_results here we present pear a fast and accurate paired_end merger pear merges reads by maximizing the assembly score as of the read overlap via a scoring_matrix that penalizes mismatches with a negative value and rewards matches with a positive value our approach takes quality_scores and sequence matches into account it does not require preprocessing of the raw_data or specifying the fragment_size furthermore pear neither requires prior information on read_length nor target fragment_size it can reliably identify reads that can either be merged or need to be discarded the program is accurate on datasets with i short overlaps and ii dna target fragment sizes that are smaller than single_end read_lengths to identify false_positive merged reads we propose a statistical_test that is based on the observed expected alignment scores oess on simulated paired_end with a mean overlap of bp section pear correctly merges of the fragments with a fpr of when our statistical_test is disabled it correctly merges of the fragments with a fpr of only when the significance_level of the test is set to the best competing merger pandaseq correctly merges of the fragments but with a fpr of we implemented pear in c it includes an optimized memory management scheme that allows the user to specify the amount of random_access ram available for executing the program therefore it can be deployed on offthe shelf desktop and laptop computers as well as on high end multi core servers in section we outline why pear becomes faster when using less memory finally the parallel version of pear scales linearly with the number of cores 
