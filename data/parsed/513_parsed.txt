assembling short_reads from jumping libraries with large insert_sizes motivation advances in next_generation and sample_preparation recently enabled generation of high_quality jumping libraries that have a potential to significantly improve short_read assemblies however assembly algorithms have to catch up with experimental innovations to benefit from them and to produce high_quality assemblies results we present a new algorithm that extends recently described exspander universal repeat resolution approach to enable its applications to several challenging data types including jumping libraries generated by the recently_developed illumina nextera_mate protocol we demonstrate that with these improvements bacterial_genomes often can be assembled in a few contigs using only a single nextera_mate library of short_reads availability_and described algorithms are implemented in c as a part of spades genome assembler which is freely_available at bioinf spbau ru en spades in an article titled de_novo fragment assembly with short matepaired reads does the read_length matter argued that availability of paired_reads with long and accurate insert_sizes rather than the increase in the read_length is the most important factor for improving the quality of short_read assemblies however while paired_reads with long insert_sizes have been extensively used in many assembly projects robust generation of readpairs with accurate insert_sizes proved to be difficult and have only been achieved recently the recently_emerged sample_preparation technologies open new opportunities for genome_assembly from short_reads for example illumina nextera_mate protocol generates long inserts kb and longer that feature rather tight insert size_distribution and small rate of non circularized fragments that result in read_pairs with abnormal distances as discussed in such read_pair libraries may enable assemblies approaching the quality of assemblies from long_reads of length equal to the insert_size moreover they can potentially substitute the existing assembly approaches based on a combination of short paired_end libraries with insert_size less than kb and long jumping libraries with insert_sizes typically longer than kb by a pipeline based on a single nextera_mate library however even though the popular assembly algorithms perform well with the previously_proposed approaches to sample_preparation they have not kept up with recent experimental innovations to catch up bioinfomaticians either need to design novel tools for every technology improvement or to develop a universal assembler that can be easily modified to support new data types for example ray and spades is based on the path extension framework that was proposed by the authors of the ray assembler and later implemented in the telescoper and perga assemblers given a path p in the assembly_graph exspander iteratively attempts to grow it by choosing one of its extension edges all edges starting at the terminal vertex of the path p the assembly_graph is defined as simplified de_bruijn of k_mers in reads after removal of bulges tips and chimeric edges to extend a path p exspander computes the scoring_function score p e for each extension edge e using read_pairs with one read_mapping to p and another read_mapping to e further referred to as p e connecting read_pairs afterward exspander decides whether to select the top scoring extension edge or to stop growing p it iteratively repeats the path extension procedure starting with single edge paths until every edge in the assembly_graph is covered by at least one path and no path can be extended further to generate equivalent contigs on both strands exspander is implemented as a bidirectional approach that can extend a path in both directions while the scoring_function score p e described in prjibelski et_al works well with short libraries it appears to be rather inefficient when using jumping libraries the key limitation of the previously_defined scoring_function is that it analyses only p e connecting read_pairs where e is an extension edge of path p and ignores read_pairs that connect path p with other edges when an edge e is short and the variations in the insert_sizes are large there is a danger that no p e connecting read_pairs exist and thus scorep e even if e is the correct extension edge thus the decision_rule may stop extending path p or even select an incorrect extension edge additionally the approach described inis inapplicable for scaffolding procedure since it is unable to jump over coverage gaps in this article we extend the exspander approach to scaffolding this extension is important since scaffolding with jumping libraries may dramatically improve the assembly_quality we describe several algorithms that address these bottlenecks based on the following idea consider a set of extension paths e rather than extension edges as in that contain all sufficiently_long paths longer than the insert_size starting from the extension edges of the path p once the set e is constructed we choose the best scoring path e in e and extend path p by the first edge of e our analysis has shown that such conservative extension by the first edge of the best scoring extension path rather than by the entire path provides more accurate assemblies to perform scaffolding procedure we allow extension paths to jump over coverage gaps in the assembly_graph this intuitive approach while appealing is often impractical since the assembly_graph is usually tangled resulting in a prohibitively large number of extension paths to reduce the running time we have implemented the new algorithm based on the observation that instead of the exhaustive_search through the set of all extension paths one can significantly prune this set using single reads and paired_end libraries if available we demonstrate that the new algorithm enables assemblies of nearly complete_genomes from a single nextera_mate library we also show that spades coupled with the improved exspander algorithm outperforms other popular assemblers such as abyss idba ud ray soapdenovo and velvet on various types of datasets to evaluate how availability of nextera mate_pair affects the quality of assembly we assembled several bacterial_genomes using multicell datasets provided by illumina nextera mate_pair only in this article we describe benchmarking using seven different assemblers and three scaffolders on meiothermus ruber str t nextera_mate library and additionally on escherichia_coli st k subst mg single_cell dataset that contains both a short paired_end library and a long jumping library results for other nextera mate_pair are presented in the supplementary_material since the assemblers we used for comparison were not designed for assembling nextera mate_pair we have conducted jumping over coverage gaps in the assembly_graph from an out tip to an in tip a an extension path e marked red ending with an out tip e b the only p supported edge e is an in tip marked green c the path e is extended by an edge e with a gap red line jumping over coverage gaps in the assembly_graph from an out tip to an internal edge d the only p supported edge e is not an in tip marked green and e paths e and e that start with in tips and contain p supported edge e both paths are considered as possible extensions for e shown by red lines additional optimization and selected the optimal k_mer sizes with respect to n to ensure fair benchmarking with these assemblers we ran abyss ray soapdenovo velvet and velvet sc based on velvet released on march with the kmer sizes and respectively iterative de_bruijn assemblers idba ud spades with the previous version of exspander and spades that implements the new algorithm described in this article were run with the default_parameters in addition to scaffolds we also provide information about contigs generated by spades referred to as spades ctg we have also included results for such popular scaffolders as opera scarpa and sspace to perform a fair comparison we ran all scaffolders on the contigs that were assembled by spades using all data as single_end discarding read_pair information the resulting assemblies were evaluated with quast using standard metrics nga ng corrected for assembly errors the total number of scaffolds in the assembly the size of the largest scaffold the number of misassemblies the fraction of genome covered and the number of uncalled bases n in the assembly benchmarks various assemblers on m ruber nextera_mate library mean insert_size kb some of the assemblers used in the comparison produce rather inaccurate assemblies e g misassemblies for ray and misassemblies for soapdenovo also some assemblers generate very large number of unspecified symbols n abyss ray soapdenovo and velvet interestingly most assemblers showed rather unstable behavior with nextera mate_pair with exception of idba ud and spades originally developed as single_cell assemblers spades exspander assembles an almost complete m ruber genome with less than of unspecified nucleotides and the largest scaffold capturing more than of the genome spades generates similar high_quality assemblies on all nextera mate_pair see_supplementary and often results in assemblies of very few contigs with the quality that approaches the quality of the assemblies from long pacific_biosciences reads thus nextera mate_pair provide a valuable low_cost trade_off when compared with the assemblies that use pacific_biosciences reads in table we also present a comparison between selected tools on e coli single_cell dataset with paired_end and jumping libraries in addition we ran allpaths_lg build released on september with the default_parameters using both libraries together as 
