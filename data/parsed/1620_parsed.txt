essamem finding maximal_exact using enhanced sparse suffix_arrays we have developed essamem a tool for finding maximal_exact that can be used in genome comparison and read_mapping essamem enhances an existing sparse suffix_array implementation with a sparse child array tests indicate that the enhanced algorithm for finding maximal_exact is much faster while maintaining the same memory_footprint in this way sparse suffix_arrays remain competitive with the more complex compressed suffix_arrays availability source_code is freely_available at https github ugent be computationalbiology essamem maximal_exact mems are exact_matches between two sequences that cannot be extended to the left or right without introducing a mismatch in addition extra cardinality constraints can be imposed leading to the concepts of maximal unique matches mums and maximal almost unique matches these matches are widely used as seeds for sequence_comparisons and alignment tools such as mummer algorithms for memory_efficient mem finding can be divided_into online and indexed methods algorithms of the former type construct a compressed index structure for the concatenation of both sequences and iterate over the index to find the mems or mums essamem belongs to the class of indexed mem finding algorithms which match one sequence against an index of the other sequence the advantage of indexed mem finding over online mem finding algorithms is the reusability of the constructed index originally suffix_trees or enhanced_suffix esa were used to find mems however the size of these types of indexes is several times larger than the size of the indexed sequence esas consist of four arrays suffix longest common prefix lcp child and suffix link arrays that contain parts of the information_stored in suffix_trees and together reach the full expressiveness of suffix_trees several algorithms build on the idea of esas by using more memory_efficient variants of the arrays suggest the use of sparse suffix_arrays ssa ssas index only every kth suffix of the sequence the parameter k is called the sparseness factor their ssa based algorithm sparsemem is able to find mems faster than previous methods while using less memory as a result of this lower memory_footprint ssas can also index larger genomes than previous methods however for large values of k the execution time increases dramatically more recently an algorithm using enhanced compressed suffix_arrays csa was presented by in contrast to ssas these compressed counterparts index every kth suffix_array value it was shown how the csa based mem finding algorithm backwardmem outperforms sparsemem except when memory is abundant in this article we optimize the method by khan et_al by supplementing ssas with a sparse child array for large sparseness factors we show that the new index structure outperforms the previous design while maintaining the same memory_footprint furthermore when combining both the suffix link and child arrays we achieve a complete enhanced sparse suffix_array essa which has the same expressiveness as suffix_trees for substrings larger than k we show that essas are competitive for mem finding with the csa based method by ohlebusch et_al and outperform commonly used methods like mummer and vmatch http www vmatch de this indicates that although compressed index structures have recently become popular the use of essa based_algorithms can be a viable_option for further research essamem is open_source and can be used as drop in replacement for tools that require mem finding in particular essamem supports all mummer v options we evaluated the performance of essamem against sparsemem mummer vmatch and backwardmem using all relevant datasets provided previously the default setting of essamem features a sparse child array and an estimate for the optimized skip parameter but lacks suffix links support because the sparse child array has the same size as the inverse suffix_array only required for suffix link support essamem has the same memory_footprint as the index structure used by khan et_al for optimizing s the runtime for a maximum of five successive values of s is taken the largest value of s is set to be the largest value for which l s k timing results do not include the index construction phase and the resident set size was measured to determine the memory_footprint of the programs the program parameters are the same as used in the study conducted by however we explore a much larger interval of sparseness and compression factors than previously_reported by other authors all mem finding algorithms are tested on six pairs of megabase sized genomes and two sequencing read datasets sparsemem and essamem are also tested on two pairs of gigabase sized sequences depicts the memory time trade_offs presented by the different algorithms for finding all mems between drosophila_melanogaster and drosophila yakuba the other results which can be found in the supplementary_material depict a similar behaviour mummer and vmatch have one of the lowest mapping times among the tested programs their memory_requirements are however higher than those of the tools using compressed or sparse index structures furthermore they do not allow setting a memory time trade_off the tests show that sparsemem is clearly outperformed by essamem and backwardmem although sparsemem is fast for small values of k its performance steeply decreases when k is increased which can be explained by the diminishing use of suffix links for the largest values of k a decrease in the runtime of the mapping phase has a positive effect on the overall runtime of sparsemem a similar decrease in runtime for the mapping phase can be observed using the sparse child array in essamem this is however countered by the diminishing effect of the skip parameter and can therefore not be seen in the lower running time for the mapping phase might be explained by a combination of the use of a sparse child array that can match more than one character at the same time smaller minimum lengths in the matching phase and improved i o performance when s is increased the runtime decreases manifold this effect is however limited by the theoretical bound s k l the effects of the various improvements made to the original ssa based design are discussed in the supplementary_material the results also indicate that essamem is in general somewhat faster than backwardmem for comparable memory settings the difference in runtime is larger when either memory is abundant low values of k or the number of mems found is large as backwardmem seems to have a stronger dependency on the output size this behaviour can be seen in where the runtime of backwardmem steeply increases for k in contrast to ssa based_methods however backwardmem puts no restriction on the maximum value of k and could thus be used for small l settings in combination with a high compression factor in terms of memory_consumption backwardmem starts with a lower memory_footprint at no compression but the memory_footprint of essamem decreases faster theoretically the csa scatterplot showing the memory time trade_offs for finding all mems of minimum_length between d melanogaster mb and d yakuba mb the data_points are acquired by setting the sparseness compression factor k to the following values from right to left and there is only one data point for mummer and vmatch index requires k bytes per input character and the essa index requires k bytes per input character as a result both indexes theoretically have the same memory_requirements for k the actual allocated memory for the sparse or compressed index structures for the d melanogaster genome is given in for this dataset the index size of the mem finding tools is equal for k between and 
