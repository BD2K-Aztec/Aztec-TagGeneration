fast and accurate long read_alignment with burrows_wheeler transform motivation many programs for aligning short_sequencing to a reference_genome have been developed in the last years most of them are very efficient for short_reads but inefficient or not applicable for reads bp because the algorithms are heavily and specifically tuned for short queries with low sequencing_error however some sequencing_platforms already produce longer_reads and others are expected to become available soon for longer_reads hashing based software such as blat and ssaha remain the only choices nonetheless these methods are substantially slower than short_read in terms of aligned bases per unit time results we designed and implemented a new algorithm burrows_wheeler aligners smith_waterman alignment bwa_sw to align long_sequences up to mb against a large sequence database e g the human_genome with a few gigabytes of memory the algorithm is as accurate as ssaha more accurate than blat and is several to tens of times_faster than both availability http biofollowing the development of sensitive local_alignment software such as fasta and blast around a new generation of faster methods to find dna_sequence matches was developed since including megablast ssaha blat and patternhunter greatly speeding up matching capillary sequencing_reads against a large reference_genome when new sequencing_technologies arrived that generated millions of short bp reads a variety of new algorithms were developed which were times_faster including soap maq bowtie and bwa however roche sequencing_technology has already produced reads bp in production illumina gradually increases read length_bp and pacific bioscience generates bp reads in early testing reads coming from the new sequencing_technologies are not short any more which effectively rules out many of the new aligners exclusively designed for reads to whom correspondence should be addressed no longer than bp efficiently aligning long_reads against a long reference_sequence like the human_genome poses a new challenge to the development of alignment tools long read_alignment has different objectives from short_read first in short_read we would usually like to align the full_length read to reduce the reference bias caused by the mismatches toward the ends of the read given this requirement we can design spaced seed templates spanning the entire read or quickly filter out poor matches for example by applying q gram filtration or by bounding the search_process and thus accelerate the alignment in long read_alignment however we would prefer to find local matches because a long_read is more fragile to structural_variations and misassemblies in the reference but is less affected by the mismatches close to the ends of a read secondly many short_read are only efficient when doing ungapped alignment or allowing limited gaps e g a maximum of one gap they cannot find more gaps or the performance quickly degrades when they are tuned for this task long read_aligners however must be permissive about alignment gaps because indels occur more frequently in long_reads and may be the dominant source of sequencing_errors for some technologies such as and pacific bioscience when considering algorithms to speed up long read_alignment hash_table indexing as is used in most current software is not the only choice found a smithwaterman like dynamic_programming that can be applied between a query_sequence and the suffix_tree of the reference effectively aligning the query against each subsequence sampled from the suffix_tree via a top_down traversal as on a suffix_tree identical_sequences are collapsed on a single path time is saved by avoiding repeated alignment of identical subsequences furthered this idea by implicitly representing the suffix_tree with an fm_index which is based on the burrowswheeler_transform bwt to achieve a small memory_footprint their new algorithm bwt sw is able to deliver identical results to the standard smithwaterman alignment but thousands of times_faster when aligning against the human_genome while bwt sw is still slower than blast on long query_sequences it finds all matches without heuristics one can imagine that introducing heuristics would further accelerate bwt sw our bwa_sw algorithm follows this route to some extent bwa_sw as well as bwt sw also follows the seed and extend paradigm but different from blat and ssaha page bwa_sw is an efficient algorithm for aligning a query_sequence of a few hundred base_pairs or more against a long reference_genome its sensitivity_and tend to be higher given a long query or a query with low_error and on such query_sequences the accuracy of bwa_sw is comparable with the most accurate aligner so_far furthermore bwa_sw is able to detect chimera potentially caused by structural_variations or reference misassemblies which may pose a challenge to blat and ssaha bwa_sw blat and ssaha all follow the seed and extend paradigm the major difference comes from the seeding strategy blat and ssaha identify short exact_matches as seeds typically of length or bp for k_mer seeding between two sequences of length l and l respectively the expected number of seeds is l l k or of the order of for alignment against the human_genome extending these seeds each with the smithwaterman_algorithm is expensive to reduce unnecessary seed extension both blat and ssaha use non overlapping seeds by default and require_multiple seed matches which should work well for random_sequences but still involves many seed extensions in highly repetitive_regions bwa_sw resolves this issue by using a few long gapped seeds in unique regions on real_biological it saves many unnecessary seed extensions and leads to a better overall performance however to reduce time when identifying long seeds bwa_sw only maintains a very small fraction of the dynamic_programming matrix which may miss all seeds for true matches this heuristic is the major source of alignment errors especially for short queries when there are only few valid unique seeds between the sequences to be aligned on long alignments fortunately the chance of missing all seeds is small we have shown bwa_sw works equally well as ssaha bwa_sw differs from bwt sw in several aspects first of all bwt sw guarantees to find all local matches whereas bwa_sw is a heuristic_algorithm which may miss true hits but is much faster secondly bwa_sw aligns two fm indices while bwt sw aligns one sequence and a fm_index building a prefix dawg for the query_sequences potentially helps to avoid repeatedly aligning identical substrings in the query and thus improves the theoretical time complexity thirdly bwa_sw traverses the reference prefix trie in the inner loop while bwt sw loops through the query_sequence in the inner loop without heuristics the bwa_sw approach would hurt performance because we have to trade speed for memory in traversing the reference prefix trie and it would be more efficient to traverse it in the outer loop nonetheless applying the z best strategy requires to know the top scoring reference nodes matching a query substring without finishing the dynamic_programming and thus only works when the reference is traversed in the inner loop fourthly bwa_sw only reports alignments largely non overlapping on the query_sequence while bwt sw like blast reports all statistically_significant alignments bwa_sw retains key information of alignments and generates much smaller 
