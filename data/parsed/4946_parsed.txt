sequence_analysis yaha fast and flexible long read_alignment with optimal breakpoint detection motivation with improved short_read assembly algorithms and the recent development of long_read sequencers split mapping will soon be the preferred method for structural variant sv_detection yet current alignment tools are not well suited for this results we present yaha a fast and flexible hash based aligner yaha is as fast and accurate as bwa_sw at finding the single best alignment per query and is dramatically faster and more sensitive than both ssaha and megablast at finding all possible alignments unlike other aligners that report all or one alignment per query or that use simple heuristics to select alignments yaha uses a directed_acyclic to find the optimal set of alignments that cover a query using a biologically_relevant breakpoint penalty yaha can also report multiple mappings per defined segment of the query we show that yaha detects more breakpoints in less time than bwa_sw across all sv classes and especially excels at complex svs comprising multiple breakpoints availability yaha is currently supported on bit linux systems binaries and sample data are freely_available for download fromstructural variation sv is a major source of diversity in germline and cancer_genomes but is difficult to map relative to other forms of variation since most sequence_based studies of sv have used paired_end pem which relies upon clustering of discordant paired_end that map to either side of an sv breakpoint now with the rapid_improvement of short_read assembly algorithms and the development of thirdgeneration long_read sequencing_technologies split_read or split contig mapping we refer to both as srm will soon be the preferred method srm is significantly more precise and less error_prone than pem yet current read_mappers are not well designed for aligning breakpoint containing query_sequences here we present yaha a flexible hash based aligner that is explicitly designed for optimal sv breakpoint detection from long query_sequences to accurately determine sv breakpoints using srm an aligner must do four things well first it must accurately determine the best set of alignments that cover the length of the query the optimal coverage set ocs this is best accomplished by using an algorithm that provides provably optimal results given some objective_function our use of a best path algorithm on a directed_acyclic dag of alignments does just that the objective_function is specifically tuned to finding sv events by taking_into the length and quality of alignments the number of alignments in the ocs and the genomic_distance between those alignments second it must be able to report alignments similar to those in the ocs in order to allow for the use of combinatorial breakpoint detection_algorithms that cluster multiple mappings per read yahas use of an optimal dag algorithm for discovery of the ocs and its ability to find collections of alignments similar to the ocs are completely novel third it must be able to generate a large number of viable alignments to feed the above two algorithms long read_aligners such as bwa_sw and agile severely restrict the number of alignments under consideration early in query processing while this improves speed it reduces the likelihood of finding the ocs and precludes finding alignments similar to them yaha can produce the required large number of alignments optionally the user can choose to output all of them other aligners such as megablast and ssaha can also produce numerous alignments but have no notion of an ocs fourth the aligner must be able to run in a reasonable amount of time yaha uses a unique combination of heuristics and optimizations to accomplish this we use a hashing scheme similar to ssaha but with a considerably faster approach for sorting hash_table seeds we use banded smith_waterman sw and a modified_version of megablasts x dropoff heuristic for extensions finally we calculate the ocs without unduly impacting performance by using a time and space optimized dag algorithm yaha is the only aligner that does all four of these things well and therefore is uniquely well suited to sv breakpoint detection in addition it is important to score alignments using a metric that is capable of accommodating a wide_range of error profiles in order to perform well on queries from diverse sources including existing and future long_read sequencing_technologies to accomplish this yaha utilizes affine gap scoring ags with user specified cost reward parameters in the next section we explain yahas algorithms in more detail in section we show the efficacy of these algorithms in three comparison tests first we compare yaha with to whom correspondence should be addressed the author s published_by this is an open_access the terms of the creative commons attribution license http creativecommons org licenses by which permits unrestricted use distribution and reproduction in any medium provided the original_work megablast and ssaha in their capacity to generate a large number of accurate alignments in a reasonable amount of cpu time second we compare yaha with bwa_sw in their ability to find the single best alignment over a range of read_lengths and error_rates third we compare yaha with bwa_sw in their ability to accurately identify sv breakpoints over a range of sv event categories to demonstrate yahas power and flexibility we measure its performance in three test scenarios first we show that yaha is sufficiently sensitive to find large_numbers of alignments for queries with repeated sub sequences second we measure yahas ability to accurately find alignments when using the oqc algorithm for non chimeric queries third we test the oqc and fbs algorithms by measuring yahas ability to detect sv breakpoints in chimeric queries for each test we compare yaha to what we believe to be best of breed among commonly used aligners for that specific task in the sensitivity test we compare against megablast because it is generally considered one of the most sensitive heuristic aligners for finding a large number of alignments in a practical amount of time because we use the same indexing strategy as ssaha we also include it in this test bwa_sw only reports primary alignments so cannot be included in the sensitivity comparison we do not include megablast or ssaha in the accuracy or sv_detection tests because neither has any strategy for finding an ocs for these tests we compare our results to bwa_sw which is the most widely used long read_aligner and the most challenging competitor to yaha for finding primary alignments on either chimeric or non chimeric queries in particular it has already been shown that bwa_sw outperforms ssaha and blat on non chimeric reads in all these tests cpu time is an important metric as any alignment task is easy to perform by brute_force if an aligner is given unlimited computer resources finally we note that it is difficult to compare results from different aligners because most are highly parameterizable but do not share all the same parameters we have made a considerable effort to select the most effective parameters to use for yaha and the other aligners but we cannot exclude the possibility that untested parameter combinations might produce superior results to those we present here the data for the accuracy test was generated using wgsim to sample reads from the hg reference_genome with the lengths and error_rates shown in for the sensitivity test we focus on the first of these datasets queries of length with a error_rate for the sv_detection test we used our own tool svsim to simulate sv events of various types all tests were run on a server class machine with xeon x processors gb of shared ram running centos yahas index and compressed reference total gb ssahas total gb and bwa sws index and reference total gb however we believe that index size is a minor concern given modern computing environments we have shown that yaha is a fast and effective all purpose aligner that outperforms best in class tools for very three different tasks i reporting all mappings per query ii reporting the single best mapping and iii identifying split mappings that define one or more sv breakpoints within a query yahas main strength as a general alignment_tool is that it simply shown are graphs of the percentage of queries with which each aligner correctly verified an sv breakpoint for various types of sv events versus the amount of cpu time consumed note the large improvement with the inclusion of yahas secondary alignments in the alu dataset also note the marked improvement for both bwa_sw and yaha in the cgr dataset with error_rate by changing the ags parameters to lower the penalty for indels relative to replacements still yaha outperforms bwa_sw with both sets of ags parameters graphs c and d are shown with the same axes to ease comparison 
