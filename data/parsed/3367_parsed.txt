optimal seed solver optimizing seed selection in read_mapping motivation optimizing seed selection is an important problem in read_mapping the number of non overlapping seeds a mapper selects determines the sensitivity of the mapper while the total frequency of all selected seeds determines the speed of the mapper modern seed and extend mappers usually select seeds with either an equal and fixed_length scheme or with an inflexible placement scheme both of which limit the ability of the mapper in selecting less frequent seeds to speed up the mapping_process therefore it is crucial to develop a new algorithm that can adjust both the individual seed length and the seed placement as well as derive less frequent seeds results we present the optimal seed solver oss a dynamic_programming that discovers the least frequently occurring set of x seeds in an l base_pair read in ox l operations on average and in ox l operations in the worst_case while generating a maximum of ol seed frequency database lookups we compare oss against four state of the art seed selection schemes and observe that oss provides a fold reduction in average seed frequency over the best previous seed selection optimizations availability_and we provide an implementation of the optimal seed solver in c at https github com cmu safari optimal seed solverthe invention of high_throughput hts platforms during the past_decade triggered a revolution in the field of genomics these platforms enable scientists to sequence mammalian sized genomes in a matter of days which have created new opportunities for biological_research for example it is now possible to investigate human_genome diversity between populations genomes find genomic_variants likely to cause disease and study the genomes of ape species and ancient hominids to better understand human evolution however these new sequencing_platforms drastically increase the computational_burden of genome data analysis first billions of short dna_segments called reads are aligned to a long reference_genome each read is aligned to one or more sites in the reference based on similarity with a process called read_mapping reads are matched to locations in the genome with a certain allowed number of errors insertions deletions and substitutions which usually constitute less than of the reads length matching strings approximately with a certain number of allowederrors is a difficult problem as a result read_mapping constitutes a significant portion of the time spent during the analysis of genomic_data pigeonhole principle based seed and extend mappers are one kind of popular mappers that have been widely used to aid many biological_applications in pigeonhole based seed and extend mappers such as mrfast razers gem shrimp and hobbes each read is partitioned into one or more short segments called seeds here we define seeds as substrings of a read this definition is different from the spaced seeds definition which can be a subsequence rather than a substring a concept we will explain in the related works section seeds are used as indices into the reference_genome to reduce_the and speed up the mapping_process since a seed is a substring of the read that contains it every correct mapping for a read in the reference_genome will also be mapped by the seed assuming no errors in the seed therefore mapping locations of the seeds generate a pool of potential mappings of the read mapping locations of seeds in the reference_genome are pre_computed and stored in a seed database usually implemented as a hash_table or burrows_wheeler transformation bwt with fm indexing and can be quickly retrieved through a database lookup when there are errors in a read the read can still be correctly mapped as long as there exists one seed of the read that is error_free the error_free seed can be obtained by breaking the read into many non overlapping seeds in general to tolerate e errors a read is divided_into e seeds and based on the pigeonhole principle at least one seed will be error_free alternatively a mapper can use overlapping seeds such mappers follow the q gram approach in order to achieve full mapping sensitivity finding all valid mappings that have fewer errors than permitted or simply select overlapping seeds without guaranteeing the full mapping sensitivity under the given error threshold e g bowtie bwa mem compared to the pigeonhole principle a special_case of the q gram approach selecting overlapping seeds using the q gram approach could generate longer less frequent seeds however in order to guarantee full mapping sensitivity this approach_requires selecting a larger number of seeds which may increase the total number of potential mappings there by reducing the speed of a mapper in this work we focus on seed selection mechanisms based on the pigeonhole principle that provide full mapping sensitivity by selecting non overlapping seeds for each selected non overlapping seed its locations are further verified using weighted edit_distance calculation mechanisms such as smithwaterman and needleman wunsch algorithms to examine the similarity between the read and the reference at each potential mapping site locations that pass this final verification step i e contain fewer than e substitutions insertions_and are valid mappings and are recorded by the mapper for use in later stages of genomic analysis computing the edit_distance is an expensive operation and is the primary computation performed by most read_mappers in fact speeding up this computation is the subject of many other works in this area of research such as shifted hamming_distance gene myers bit vector algorithm and simd implementations of edit_distance algorithms to allow edits mappers must divide reads into multiple seeds each seed increases the number of locations that must be verified furthermore to divide a read into more seeds the lengths of seeds must be reduced to make space for the increased number of seeds shorter seeds occur more frequently in the genome which requires the mapper to verify even more potential mappings therefore the key to building a fast yet error tolerant mapper with high_sensitivity is to select many seeds to provide greater tolerance while minimizing their frequency of occurrence or simply frequency in the genome to ensure fast operation our goal in this work is to lay a theoretically solid foundation to enable techniques for optimal seed selection in current and future seed and extend mappers selecting the optimal set of non overlapping seeds i e the least frequent set of seeds from a read is difficult primarily because the associated search_space all valid choices of seeds is large and it grows exponentially as the number of seeds increases a seed can be selected at any position in the read with any length as long as it does not overlap with other seeds we observe that there is a significant_advantage to selecting seeds with unequal lengths as possible seeds of equal lengths can have drastically different levels of frequencies our goal in this paper is to develop an inexpensive algorithm for seed and extend mappers based on the pigeonhole principle that derives the optimal placement and length of each seed in a read such that the overall sum of frequencies of all seeds is minimized this paper makes the following contributions bullet it examines the frequency distribution of seeds in the seed database and provides how often seeds of different frequencies are selected using a navenave seed selection scheme we confirm the discovery of prior works that frequencies are not evenly_distributed among seeds and frequent seeds are selected more often under a navenave seed selection scheme we further show that this phenomenon persists even when using longer seeds bullet it provides an implementation of an optimal seed finding algorithm optimal seed solver which uses dynamic_programming to efficiently find the least frequent non overlapping seeds of a given read we prove that this algorithm always provides the least frequently occurring set of seeds in a read bullet it provides a comparison of the optimal seed solver and existing seed selection optimizations including adaptive seeds filter in the gem mapper cheap k_mer selection in fasthash optimal prefix selection in the hobbes mapper and spaced seeds in patternhunter we compare the complexity memory traffic and average frequency of selected seeds of optimal seed solver with the above four state of the art seed selection mechanisms we show that the optimal seed solver provides the least frequent set of seeds among all existing seed selection optimizations at reasonable complexity and memory traffic to build a fast yet error tolerant mapper with high mapping coverage reads need to be divided_into multiple infrequently occurring seeds in this way a mapper can find all correct mappings of the read mappings with small edit distances while minimizing the number of edit_distance calculations that need to be performed to achieve_this we have to overcome two major challenges i seeds are short in general and therefore frequent in the genome and ii the frequencies of different seeds vary significantly we discuss each challenge in greater detail assume a read has a length of l base_pairs bp and x of it is erroneous e g l and x implies that there are edits to tolerate x l errors in the read we need to select x l seeds which renders a seed to be l x l base_pair long on average given that the desired error_rates for many mainstream mappers have been as large as the average seed length of a hash_table based mapper is typically not greater than bp seeds have two important properties i the frequency of a seed is monotonically non increasing with larger seed lengths and ii frequencies of different seeds typically differ sometimes significantly shows the static distribution of frequencies of bp to bp fixed_length seeds from the human_reference grch this figure shows that the average seed frequency decreases with the increase in the seed length with longer seeds there are more patterns to index the reference_genome thus each pattern on average is less frequent from we can also observe that the frequencies of seeds are not evenly_distributed for seeds with lengths between bp to bp many seeds have frequencies below as the figure shows a high number of unique seeds often over correspond to seed frequencies below however there are also a few seeds which have frequencies greater than k note that such unique seeds are very few usually per each frequency this explains why most plots infollow a bimodal_distribution except for bp seeds and perhaps bp seeds where the frequency of seeds peaks at around although ultra frequent seeds seeds that appear more frequently than times are few among all seeds they are ubiquitous in the genome as a result for a randomly_selected read there is a high chance that the read contains one or more of such frequent seeds this effect is best illustrated in which presents the numbers of frequencies of consecutively selected seeds when we map over million randomly_selected bp reads from the genomes_project genomes to the human_reference unlike in in which the average frequency of bp unique seeds is the average frequencies of selected seeds in we can observe that the ultra frequent seeds are selected far more often than some of the less frequent seeds as the selected seed count increases with seed frequencies higher than as opposed to where seed frequencies over usually have seed counts below this observation suggests that the ultra frequent seeds are surprisingly numerous in reads especially considering how few ultra frequent seed patterns there are in total in the seed database and the plots inno longer follow a bimodal_distribution as in we call this phenomenon the frequent seed phenomenon the frequent seed phenomenon is explained in previous_works to summarize highly frequent seed patterns are ubiquitous in the genome therefore they appear more often in randomly_sampled reads such as reads sampled from shotgun_sequencing frequency distributions of other seed lengths are provided in the supplementary_materials section the key takeaway from figures and is that although longer seeds on average are less frequent than shorter seeds some seeds are still much more frequent than others and such more frequent seeds are very prevalent in real reads therefore with a navenave seed selection mechanism e g selecting seeds consecutively from a read a mapper selects many frequent seeds which increases the number of calls to the computationally_expensive verification process during read_mapping to reduce the total frequency of selected seeds we need an intelligent seed selection mechanism to avoid using frequent patterns as seeds more importantly as there is a limited number of base_pairs in a read we need to carefully choose the length of each seed extension of an infrequent seed does not necessarily provide much reduction inupon selection each seed contributes to the frequency counter individually duplicating seeds will be counted multiple times by each selection the total frequency of all seeds but it will consume base_pairs that could have been used to extend other more frequent seeds besides determining individual seed lengths we should also intelligently select the position of each seed if multiple seeds are selected from a small region of the read as they are closely_packed together seeds are forced to keep short lengths which could potentially increase their seed frequency thus seed selection must be done carefully to minimize the total frequency of seed occurrence based on the above observations our goal in this paper is to develop an algorithm that can calculate both the length and the placement of each seed in the read such that the total frequency of all seeds is minimized we call such a set of seeds the optimal seeds of the read as they produce the minimum number of potential mappings to be verified while maintaining the sensitivity of the mapper we call the sum of frequencies of the optimal seeds the optimal frequency of the read as shown in the section oss requires ol seed frequency lookups in order to derive the optimal_solution of a read for a non trivial seed database implementation such as bwt with fm_index this can be a time consuming process for reads that generate equally frequent seeds in oss and other seed selection mechanisms oss could be less beneficial as it generates more queries of seed frequencies to the seed database without reducing the total seed frequency when such reads are prevalent very unlikely oss might not be the ideal seeding mechanism one workaround under this event is to combine oss with other greedy seed selection algorithms e g cks ops in such a configuration oss will only be invoked when greedy seed selection algorithms fail to deliver infrequent seeds however how to combine different seeding mechanisms is beyond the scope of this paper and will be explored in our future_research the optimal seed solver also revealed that there is still great_potential in designing better greedy seed selection optimizations from our experiment we observe that the most effective greedy seed selection optimization still provides more frequent seeds on average than optimal better greedy algorithms that provide less frequent seeds without a large number of database lookups are also part of our future_research optimizing seed selection is an important problem in read_mapping the number of selected non overlapping seeds defines the error tolerance of a mapper while the total frequency of all selected seeds in the reference_genome determines the performance of the mapper to build a fast yet error tolerant mapper it is essential to select a large number of non overlapping seeds while keeping each seed asoptimal seed solverinfrequent as possible in this paper we confirmed the frequent seed phenomenon discovered in previous_works which suggests that in a navenave seed selection scheme mappers tend to select frequent seeds from reads even when using long seeds to solve this problem we proposed the optimal seed solver oss a dynamic_programming that finds the optimal set of seeds that has the minimum total frequency we further introduced four optimizations to oss optimal divider cascading early divider termination divider sprinting and optimal_solution forwarding using all four optimizations we reduced the average case complexity of oss to ox l where x is the total number of seeds and l is the length of the read and achieved a ox l worst_case complexity we compared oss to four prior studies adaptive seeds filter cheap k_mer selection optimal prefix selection and spaced seeds and showed that oss provided a fold seed frequency reduction over the best previous seed selection scheme optimal prefix selection we conclude that oss is an efficient algorithm that can find the best set of seeds which can potentially improve the performance of future read_mappers 
