genome_analysis bless accurate memory_efficient and fast error correction_method the most important features of error_correction tools for sequencing_data are accuracy memory_efficiency and fast runtime the previous version of bless was highly memory_efficient and accurate but it was too slow to handle reads from large_genomes we have developed a new version of bless to improve runtime and accuracy while maintaining a small memory_usage the new version called bless has an error_correction algorithm that is more accurate than bless and the algorithm has been parallelized using hybrid mpi and openmp programming bless was compared with five top performing tools and it was found to be the fastest when it was executed on two computing nodes using mpi with each node containing twelve cores also bless showed at least higher gain while retaining the memory_efficiency of the previous version for large_genomes correcting errors in sequencing_reads is a time consuming and memory intensive process the occurrences of patterns k_mers in many tools in reads should be counted and patterns with a small number of occurrences have to be replaced with ones having a large number of occurrences storing patterns requires a lot of memory and searching for alternative patterns takes a long time for large_genomes therefore memory_efficiency and fast runtime are as important as accuracy in error_correction methods to provide a memory_efficient error correction_method bless which uses a bloom_filter as the main data_structure was developed while bless could generate accurate results with a much smaller amount of memory than previous tools it was too slow to be applied to reads from large_genomes recently some new error_correction methods that can correct errors in a large dataset in a short period of time have been developed however to the best of our knowledge none of the present tools satisfy all the three constraints i e memory_efficiency runtime and accuracy to address the three requirements we have developed a new version of bless in bless the accuracy of the error_correction algorithm has been further improved over that of bless by adding new algorithmic steps bless corrects errors even in solid k_mers k_mers that exist multiple times in reads using the quality_score distribution of input reads solid k_mers were originally treated as error_free k_mers there is also a new algorithm introduced in bless for trimming reads where errors cannot be corrected or corrections are ambiguous in addition to quality_improvements the overall execution has been parallelized using hybrid mpi and openmp programming which make bless the fastest tool when executed on multiple computing nodes all these improvements were made without hurting the memory_efficiency of the predecessor 
