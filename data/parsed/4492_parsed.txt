genome_analysis svseq an approach for detecting exact breakpoints of deletions with low coverage sequence_data motivation structural_variation sv such as deletion is an important type of genetic_variation and may be associated with diseases while there are many existing_methods for detecting svs finding deletions is still challenging with low coverage short_sequence existing deletion finding methods for sequence_reads either use the so_called split_reads mapping for detecting deletions with exact breakpoints or rely on discordant insert_sizes to estimate approximate positions of deletions neither is completely satisfactory with low coverage sequence_reads results we present svseq an efficient two stage approach which combines the split_reads mapping and discordant insert_size analysis the first stage is split_reads mapping based on the_burrows bwt which finds candidate deletions our split_reads mapping method allows mismatches and small_indels thus deletions near other small_variations can be discovered and reads with sequencing_errors can be utilized the second stage filters the false_positives by analyzing discordant insert_sizes svseq is more accurate than an alternative approach when applying on simulated_data and empirical data and is also much faster availability the program svseq can be downloaded ata deletion is a structural_variation sv in which a segment of dna is missing comparing with a reference_genome we focus on developing computational_methods for finding deletions in this article previously comparative_genomic with whole_genome tiling arrays was the primary method for characterizing structural_variations now highthroughput_sequencing hts technologies such as the roche flx illumina_genome and abi solid become more available these hts technologies have been applied in generating huge amount of sequence_data and newer_methods for finding svs are mainly developed for sequence_data for example the pilot_study of the genomes_project uses multiple methods to discover svs from whole_genome sequence_data collected by different technologies from hundreds of individuals as more individuals to whom correspondence should be addressed are being sequenced at low coverage for the purpose of finding variations at a population level it is important to develop sv detection_algorithms that are efficient for processing large amount of sequence_reads and accurate given low coverage short_sequence these algorithms should be able to handle sequencing_errors that are hard to avoid due to technological limitations refer to for discussions on the latest methods for discovering svs using sequence_data in this article we develop a new approach_called svseq for finding deletions with exact breakpoints from low coverage next_generation data different from methods for estimating approximate positions of beak points svseq finds the breakpoints of deletions in resolution of bp which is similar to the program pindel mapping the breakpoints of deletions to nucleotide_resolution facilitates the analysis of the origin and functional impact of the deletions different from pindel svseq takes a two stage approach for discovering deletions the first step applies an enhanced split_reads mapping_approach to identify candidate deletion sites from sequence_reads the second step uses mapped paired_end spanning candidate deletions as supports to filter false_positives in some sense svseq exploits more information i e both the split_reads and discordant paired_end in the sequence_data than existing_approaches which often use only one source of information better utilizing the given data is the key to achieve_higher when dealing with low coverage data to evaluate the accuracy and efficiency of svseq we test our method on both simulated_data and compare with the program pindel there are two versions of pindel bullet pindel v called pindel v in this article it only allows perfect matches in mapping split_reads bullet pindel v called pindel v in this article this version has been released but not yet described in a paper it allows mismatches and small_indels in mapping split_reads pindel v has a default cutoff value c and pindel v has a default cutoff value c we compare with pindel v in finding the deletions up to mbps but for pindel v since its running time is significantly_longer than pindel v when finding larger svs we only compare with it in finding deletions up to bp in this article we focus on deletions that are at least bps although the algorithm of svseq can be used to find smaller deletions we note that there are existing_methods e g the program dindel which are dedicated for finding smaller indels we only compare with pindel in finding deletions while pindel can also find insertions inversions and tandem_duplications assuming paired_end are properly mapped the reads picked out for the first step of svseq are the ones with the anchors mapped as a whole read but the reads themselves could not the reads are stored in the fastq format the positions and strands of the anchors are provided in another file to svseq there is a demo on the svseqs website in the second step svseq take the bam_files as input for spanning pairs for both steps svseq takes the reference in fasta_format as input 
