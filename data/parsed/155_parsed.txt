genome_analysis age defining breakpoints of genomic structural_variants at single_nucleotide through optimal alignments with gap excision motivation defining the precise location of structural_variations svs at single nucleotide breakpoint resolution is an important problem as it is a prerequisite for classifying svs evaluating their functional impact and reconstructing personal genome_sequences given approximate breakpoint locations and a bridging assembly or split_read the problem essentially reduces to finding a correct sequence_alignment classical algorithms for alignment and their generalizations guarantee finding the optimal in terms of scoring global or local_alignment of two sequences however they cannot generally be applied to finding the biologically correct alignment of genomic_sequences containing svs because of the need to simultaneously span the sv e g make a large_gap and perform precise local_alignments at the flanking ends results here we formulate the computations involved in this problem and describe a dynamic_programming for its solution specifically our algorithm called age for alignment with gap excision finds the optimal_solution by simultaneously aligning the and ends of two given sequences and introducing a large_gap jump between the local end alignments to maximize the total alignment score we also describe extensions allowing the application of age to tandem_duplications inversions and complex events_involving two large gaps we develop a memory_efficient implementation of age allowing application to long contigs and make it available as a downloadable software_package finally we applied age for breakpoint determination and standardization in the genomes_project by aligning locally assembled_contigs to the human_genome availability_and age is freely_available sv gersteinlab org age the problem of single nucleotide breakpoint resolution for genome structural_variations svs deletions insertions inversions etc to whom correspondence should be addressed is of great_importance for a number of reasons first as recently demonstrated single nucleotide breakpoint resolution is absolutely necessary for sv classification and annotation it is also important for genotyping known svs in newly_sequenced second precise breakpoints are required to evaluate the functional impact of svs for example uncertainty in breakpoints in just a few bases may lead to ambiguous conclusions when an sv is close to a splicejunction and or regulation sites or overlaps exon s last but not least construction of personal diploid genomes one of the ultimate long_term goals of human genome_analysis cannot be done properly without precise knowledge of sv breakpoints it might seem obvious but the only plausible way to achieve single nucleotide breakpoint resolution is to align two sequences one without an sv e g a region in the reference human_genome and another containing an sv e g locally assembled contig completely_sequenced and assembled fosmid clone or long_read most commonly used methods for sv_detection provide only approximate breakpoint locations paired_end also called read_pair approaches inherently have uncertainty in breakpoint resolution due to uncertainty in the distance between sequenced ends and the possibility of read mismapping resolution of breakpoints by array_comparative analysis and read_depth approaches is limited by the probe density for array and the genomic bin size for read_depth used to produce the subsequently_analyzed signal while being imprecise in breakpoint resolution the approaches mentioned above yield approximate sv locations where a local_assembly of a haplotype bridging an sv region could be accomplished subsequently alignment of the assembled contig to the predicted sv region identifies precise sv breakpoints the described strategy is employed by the genomes_project where tens_of of local haplotype assemblies in the sv regions are made proper alignment of those contigs will and already is an important challenge that must be fulfilled precisely and computationally efficiently given the number of expected local assemblies single_nucleotide of sv breakpoints will allow their standardization and analysis in a single framework the problem of aligning two sequences containing svs might seem to be trivial but upon deeper consideration it is not the major_complications are due to possible repeats within aligned sequence page schematics of the expected optimal alignment around a structural_variation left and alignments produced by global needlemanwunsch nw and local smithwaterman sw algorithms right the structural_variation i e deletion is in red in b the deletion is accompanied by a small insertion blue throughout the figure alignable flanking_regions are shown in green and orange both sw and nw algorithms generally cannot arrive at a biologically correct alignment sequence_homology identity around breakpoints and the often complex nature of svs where for instance a deletion insertion is accompanied by smaller insertion_deletion more specifically classical algorithms which guarantee the finding the optimal global needlemanwunsch and local smithwaterman alignments generally cannot arrive at a biologically correct solution when aligned sequences contain svs the major_problem with those algorithms is the gap penalty a large_gap penalty does not allow for the extension of alignment across an sv reducing the gap penalty interferes with the alignment scoring_scheme and jeopardizes the construction of the proper alignment in regions flanking the sv and when the sequence s contains repeats in addition it offers only a partial solution to the problem and cases when the sv is not a pure deletion or insertion are still not solved a generalized global_alignment algorithm is generally also unable to solve the formulated problem the algorithm works by introducing the concept of a difference block e g large_gap and imposing a cap on the penalty for having such a block in an alignment when a block is small e g small gap it is penalized as it would be in the classical needlemanwunsch algorithm for a large block e g large_gap the penalty is constant therefore it can only be applied to the alignment of sequences where the sv size is large enough for the algorithm to work in the non classical mode more importantly the algorithm can be misled by sequence_similarity around sv breakpoints specifically when sequences around breakpoints are homologous the algorithm has to choose between aligning with a higher sequence identitybut introducing a large gapor aligning with a lower sequence_identity and no gap only the former scenario is correct but either one can be chosen by the algorithm considered to be optimal depending on the scoring_scheme size of deletion length and percent of homology around breakpoints and the lengths of aligned sequences flanking the breakpoints longer flanking_sequences allow one to resolve breakpoints within longer and higher homologous_sequences incidentally this problem is inherent to all algorithms employing a concave piecewise gap penalty it is also inherent to needlemanwunsch and smithwaterman algorithms therefore the described problem may hamper the discovery and characterization of a particular class of nahr svs that are characterized by long similar homologous_sequences around breakpoints the sandwich dynamic_programming introduced to align cdnas to exons could be useful but even if adopted for aligning sequences containing svs it does not offer a general solution as it has the same problems as the needlemanwunsch algorithm when handling events that are not pure deletions or insertions also none of the mentioned algorithms could be applied to determine tandem_duplication and inversion breakpoints hence with the aim of achieving single nucleotide sv breakpoint resolution and standardization we have developed an algorithm for the correct alignment of sequences containing svs this article first describes an algorithm for optimal sequence_alignment containing only a single sv deletion or insertion we then describe algorithm extensions to align sequences containing other svs to accomplish the first aim we formulated it as a problem of finding the optimal local_alignment of two sequences containing one unaligned and unpenalized region gap corresponding to one sv between two aligned regions the rationale is that flanking_regions of an sv are very similar and can be aligned collinearly end_to and end_to using a local smithwaterman_algorithm to yield the final alignment the two local ones should simply be combined however if the alignments of the flanking_regions overlap combining two local_alignments becomes complicated page conceptually to produce correct alignment one has to find an optimal jump between overlapping local_alignments however local_alignment calculation and jump finding have to be done simultaneously rather than successively to guarantee finding the optimal alignment supplementary and an optimal jump from one local_alignment to another must be foundthat is a gap must be introducedto maximize the alignment score the optimal highest scoring alignment may not be found if the jump is searched between already calculated local_alignments because trimming a local_alignment does not guarantee that it is still optimal a simple example demonstrating the concept is shown in supplementary therefore the calculation of flanking sequence_alignments and finding the optimal jump between the two must be done simultaneously rather than successively when formulated this way the problem explicitly addresses only the issue of the largest gap in the alignment and does not require adjustment or modifications of the alignment scoring_scheme therefore substitution matrices and gap penalties tuned to a particular alignment purpose e g contig or short long read_alignment can be used unchanged we have described an algorithm for the correct alignment of two nucleotide_sequences containing svs i e deletion insertion tandem_duplication or inversion called age the algorithm does not require the adjustment or modification of the alignment scoring_scheme s that is usually tuned for a particular alignment purpose e g cross_species contig or read_alignments thus the algorithm can be universally applied in various biological studies relying on alignment its distinguishing_feature is that it produces correct alignments in cases that are challenging for methods utilizing concave piecewise gap penalty i e cases with long sequence_homology around breakpoints and or a short sv region and or short flanking_sequences the algorithm naturally handles certain cases of complex sv events such as when deletion is accompanied by insertion the most straightforward application of age is single nucleotide sv breakpoint resolution and standardization as has just been demonstrated by using the algorithm implemented in age software while the algorithm can be generalized to align sequences containing any number of svs its most practical due to computational scalability application is to align sequence with one sv which are also the most common sequences containing more svs are very rare even when aligning long_sequences of fosmid clones still age can also be useful in aligning such sequences one may envision a strategy in which sv breakpoints are approximately localized e g by analysis of local_alignments and then precisely identified using age to align only subsequences that flank svs of perhaps equal importance the algorithm can be used to refine read_alignment once a read has been heuristically mapped to a particular genomic location that is expected to contain an sv such read realignment has potential implications for genotyping known svs in newly_sequenced individuals and or discovering page comparison of assembled contig alignments in the region of predicted deletions the first line in each alignment is the sequence for the genomic_region while the second is for the contig sequence nucleotide numbering is sequential starting from one in both compared sequences each alignment is accompanied by a schematic representation underneath a the predicted deletion is chr the contig that is bp in length has been aligned by the age gap crossmatch and blat programs to the predicted region of deletion which is extended by kb in each direction i e from the first sequence genomic_region has two pairs of homologous_sequences orange to yellow and dark green to light green age alignment clearly identifies a large unaligned region confirms a predicted deletion and derives deletion breakpoints as chr coordinates are for the first and the last deleted bases note that the resulting breakpoints are in excellent_agreement within bp with the prediction no other program was able to produce the correct alignment b predicted deletion is chr the contig of bp in length has been aligned by the age and gap programs to the predicted region of deletion which is extended by kb in each direction i e from to age alignment clearly identifies a large unaligned region confirms a predicted deletion and derives deletion breakpoints as chr coordinates are for first and last deleted bases gap is not able to align the left flanking_sequence as the penalty for a long gap outweighs the matches at the left flanking_sequence all coordinates are for human hg reference 
