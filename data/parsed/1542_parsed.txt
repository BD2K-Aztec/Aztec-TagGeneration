data_and efficient comparison of sets of intervals with nc lists motivation high_throughput produces in a small amount of time a large amount of data which are usually difficult to analyze mapping the reads to the transcripts they originate from to quantify the expression of the genes is a simple yet time demanding example of analysis fast genomic comparison algorithms are thus crucial for the analysis of the ever expanding number of reads sequenced results we used nc lists to implement an algorithm that compares a set of query intervals with a set of reference_intervals in two steps the first step a pre_processing done once for all requires time or logr q logq where q and r are the sets of query and reference_intervals the search phase requires constant space and time or q m where m is the set of overlaps we showed that our algorithm compares_favorably with five other algorithms especially when several comparisons are performed availability the algorithm has been included to smart a versatile_tool box for rna_seq analysis freely_available urgi versailles inra fr tools s mart the algorithm can be used for many kinds of data sequencing_reads annotations etc in many formats gff bed sam etc on any operating system it is thus readily useable for the analysis of next_generation data with the advent_of bioinformatics must analyze a large amount of data every day modern sequencers can generate several hundred millions of sequences in a week for a price that is affordable to more and more labs when a reference_genome is available the first task is to map the reads on the genome many mapping tools are now available and research is active on this topic for rna_seq the second step may be the assignment of the mapped read to the transcripts they originate from to estimate the expression of the genes in general the genomic comparison of the mapped_reads with a reference annotation is the basis of many analyses comparison of putative_transcription with up regulated_genes detection of the single_nucleotide that are located in coding_regions processing de_novo transcript sequences to determine if they represent known or novel genes these three examples involve a comparison of two annotations and the problem has been addressed often however high_throughput for the amount a data it produces requires optimized algorithms for its analysis most tools model the reads or annotation as intervals or lists of intervals when different elements are modeled exons utrs etc these intervals are considered along a reference which usually is a chromosome or a scaffold thus comparing rnaseq reads with known transcripts reduces to comparing a set of query intervals the reads with a set of reference_intervals the exons of the transcripts every efficient algorithm requires a dedicated data_structure such as an indexed database an indexed flat file such as a bam_file an r tree or nc lists nested containment lists these structures are usually built once during the pre_processing and can be reused for other analyses although these structures may take considerable amount of time to build the balance is usually favorable to pre processed structures when several comparisons are performed as the time spent for the comparison itself is considerably_reduced this observation leads to the conception of the bam format now widely used in the bioinformatics community with the notable_exception of the fjoin algorithm almost all the algorithms previously described only get all the reference_intervals that overlap with one given query interval most algorithms have been designed to retrieve all the intervals a user can see when he selects a given window in a genome_browser whereas these algorithms can be used to compare two sets by comparing each query interval one after the other with the reference_intervals we will show here how comparing the whole query set with the reference_set can be more efficient among the possible data_structures presented to compare intervals nc lists are one of the most promising nc lists have been first described to retrieve all the reference_intervals that overlap with a single interval their structure is compact a simple set of two arrays l and h the algorithm is fast in practice and the search phase requires only constant space which is compulsory when handling several hundreds of millions of reads the key idea of nc lists is to perform binary dichotomic search on the list of reference_intervals but dichotomic search cannot be performed when some intervals are contained or nested inside other intervals so nc lists arrange intervals into liststhe l arraywhere no two intervals are nested if some intervals are nested inside an ancestor interval to whom correspondence should be addressed the author published_by all_rights for permissions please_e journals permissions_oup com they are stored in a separate sublist using the h array see nc lists can be built in linearithmic time i e of the form on log n using linear space actually only five integers are stored per interval in their article the authors presented a recursive dichotomic algorithm equivalent to alg which uses nc lists it is claimed that getting all the reference_intervals that overlap with a query interval could be done in time ologr m where r is the reference_set and m the pairs query reference that overlap but this is not accurate for some cases see section in this article we will present an algorithm which relies on nc lists and provides all the pairs query intervals reference_intervals that overlap in a pre_processing the algorithm sorts the query and the reference_intervals it then builds a nc list for the reference_intervals in the search phase the algorithm compares every query interval with the reference_intervals in time or q m all together the algorithm takes or logr q logq m although the complexity of the whole algorithm is not better than already known algorithms the runtime complexity is significantly_lower than other constant space algorithms as such our algorithm is especially useful when performing multiple_comparisons on large sets of data such as in an rna_seq comparison to other implementations we show here the results of our algorithm when compared with several other published_methods the first is a simple nc list algorithm as presented by which does not use any information between two consecutive query intervals hereafter called nc the second method implements binning using an indexed sqlite table hereafter called bin we also implemented another flavor of this algorithm called has where the database has been replaced by a hash structure such that the keys are the bins and the values are lists of intervals a forth algorithm is a binning table with segment tree as described in segtor called seg we also added fjoin fj which scans the previously sorted query intervals and reference_intervals simultaneously to find overlaps our algorithm will simply be called new among the presented algorithms only bin nc and new have constant space complexities the other algorithms has seg where the trees are stored in memory and fj which has a linear space complexity are thus not likely to work on the large amount of data modern sequencers generate with a standard computer for instance in our implementation the has algorithm fills our ram gb when the reference dataset contains m intervals still as they rely on in memory data they usually run faster on the sets they can handle for a fair comparison of all the algorithms and to exclude any bias that would originate from the choice of the programming_language used by the different methods we re implemented all the algorithms carefully as described by the articles all the algorithms have exactly the same input output and functionalities which reflect a usual mapped_reads annotation comparison study first strand is ignored as many rna_seq have no strand information and most algorithms when described in their original_articles do not deal with this case second each feature hereafter a read or a transcript is stored as a single interval if an overlap is detected the transcript is extracted from the input_file each method keeps track of the memory address of the features and a second comparison is performed to check if the overlap is not located in the introns of the transcript in which case the overlap is not reported last the output_file is a gff file which contains the query intervals that overlap with at least one reference element and the list of the overlapping elements are added in the tags of the ninth field these implementations as well as the benchmark itself are available in the smart toolbox see supplementary_materials for more information about these implementations example on a real_dataset we downloaded three different publicly_available rna_seq on yeast fly and cress available as srr srr and srr datasets in geo we mapped the reads with bowtie on the reference_genome and we compared the mapped_reads with the annotation the genome_sequence and the annotations are both available from the bowtie website for each dataset we reported the number of annotated transcripts which are the reference_intervals as well as the number of reads the query intervals we used the six different algorithms previously mentioned run time results are shown in the first columns give the characteristics of the datasets number of reads number of transcripts and number of overlaps the following columns give the run time spent by the algorithms when the genes are the reference and the reads are the query as expected has and the fj algorithms usually perform well on this dataset because the intervals are stored in memory our algorithm is still among the fastest ones however the preprocessing of our algorithm is by far the slowest one see supplementary data this is a typical trade_off between run time speed and pre_processing time speed because the bin algorithm the slowest algorithm in the comparison step is the fastest algorithm in the pre_processing among constant space methods example on simulated_datasets we also generated several datasets to compare the algorithms in detail the intervals ranged from to nt the genome contained a single chromosome ranging from k to m bp the number of reference and query intervals varies from to k and to m elements respectively each configuration was generated five times the results ingive the run time results of each method our algorithm is still the fastest among the constant space complexity algorithms the fj required too much ram more than gb to work on the largest datasets regarding the pre_processing our algorithm is the slowest one see supplementary_information but overall the balance is always favorable to our algorithm after three comparisons when compared with the bin the seg or the nc algorithm insertion in smart smart is a versatile_tool box for the analysis of rna_seq it contains many useful tools for the comparison of rna_seq with respect to a given annotation number of reads for each transcript distance distribution between the reads and the closest transcripts discovery of previously_unknown transcribed loci etc we added a new tool called findoverlapsoptim which implements the algorithm presented in this article as a consequence the algorithm can be used for many kinds of data such as rna_seq but also annotation of any feature in many formats gff bed sam etc we included a so_called nclist format in smart which contains several nclists one per chromosome so that preprocessing can be done once for all this pre_processing can be performed using a separate tool called convertton clist these files can be used as input_file by most tools of the smart suite much like bed or gff files we also implemented a second version of our algorithm in the smart tool called compareoverlapping this version is more flexible and accepts many different parameters it may output the query elements only if they are collinear or antisense to the overlapping reference element the query elements that are nested inside reference elements the query elements that overlap the first bp of the reference elements etc because compareoverlapping is much more flexible than findoverlapsoptim it is also substantially slower last we added two versions of the much faster has algorithm in smart to be used when the query or the reference have moderate sizes the encapsulation of the algorithms within smart ensures that the presented method is not only a theoretical work but also used in a tool that is readily available to biologists for the computer scientists we also implemented an api and executables in c so that they can embed them in their algorithms the method presented here uses nc lists and provides a fast algorithm that compares two large sets of intervals efficiently to our knowledge it is the first time that an algorithm with both linear time complexity and constant space complexity during the search phase is presented this low run time complexity comes at the cost of a high pre_processing time complexity where the intervals should be sorted however this step is done only once and is far from untractable the samtools sort algorithm is used routinely to sort bam_files as a result the algorithm presented in this article is adapted to multiple_comparisons when we designed the algorithm we had the idea in mind that it could help comparing features such as rna_seq which can amount to several hundreds millions reads while this algorithm presents a theoretical interest by itself we also encapsulated it in the smart tool box which includes all the features to handle usual file_formats as a consequence we hope this work will be useful for both computer scientists and biologists 
