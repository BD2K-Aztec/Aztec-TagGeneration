genome puzzle master gpm an integrated pipeline for building and editing pseudomolecules from fragmented sequences motivation next_generation have revolutionized our ability to rapidly and affordably generate vast quantities of sequence_data once generated raw sequences are assembled into contigs or scaffolds however these assemblies are mostly fragmented and inaccurate at the whole genome_scale largely due to the inability to integrate additional informative datasets e g physical optical and genetic_maps to address this problem we developed a semi_automated software toolgenome puzzle master gpm that enables the integration of additional genomic signposts to edit and build new gen assemblies that result in high_quality an notation ready pseudomolecules results with gpm loaded datasets can be connected to each other via their logical relationships which accomplishes tasks to group merge order and orient sequences in a draft assembly manual editing can also be performed with a user_friendly graphical_interface final pseudomole cules reflect a users total data package and are available for long_term project_management gpm is a web_based pipeline and an important part of a laboratory_information lims which can be easily deployed on local servers for any genome research laboratory availability_and the gpm with lims package is available at https github com jianwei zhang lims contacts illumina and pacbio smrt sequencing_technologies are the two most widely_accepted sequencing_platforms currently used for large_scale genomics driven data generation illumina representing the most widely used second generation sequencing_technology produces short_reads base read_lengths that are highly_accurate with base call outputs that can yield hundreds of millions of bases from a single lane over several days depending upon complexity pacbio produces hundreds of thousands of long_read error corrected sequences up to kb average read_lengths that can be produced in h per smrt cell data generated by either platform can be used independently or in combination to successfully assemble genomes de_novo many assemblers have been developed to assemble raw sequence_reads into sequence contigs i e minimum sequence units for an assembly such as soapdenovo allpaths hgap or falcon https github com pacificbiosciences falcon integrate a few programs or packages e g bambus abacas mauve aligner allmaps etc are also available for scaffolding contigs however software_tools that can be used to inspect edit ngs sequence assemblies as well as integrate other evidence types i e physical and genetics maps to produce an assembly that more accurately and completely reflects the native_structure of a given genome are currently lacking to analyze manage and incorporate genome datasets for diverse sequencing_projects such as pseudomolecule construction for the maize and several wild oryza genome_sequencing schnable et_al j stein et_al submitted for publication we developed a software_tool called genome puzzle master gpm gpm does not require sophisticated bioinformatics skills or support and the final products are ready to use in the form of annotation ready pseudomolecules gpm can also facilitate the incorporation of additional datasets as new refinements are generated here we make gpm available to researchers who have ngs genome_assemblies and other unlinked genomic_datasets and are struggling to generate annotation ready or submission ready pseudomolecules of the gpm pipeline to assemble two high_quality reference genome_sequences for indica_rice a case study recently our consortia published two high_quality reference genome_sequences for the two main varietal groups of indica_rice zhenshan zs and minghui mh these genomes were primarily sequenced using pacbio long_read of minimum tiling path bac pools combined with illumina wgs assembled_contigs to fill gaps once individual bac sequences were assembled they were loaded into gpm for assembly editing and pseudomolecule construction following is a summary of how these data were used to assemble two of the highest quality indica_rice genome_assemblies produced to date to assemble the zs and mh genomes the following datasets were loaded in to gpm i whole_genome profiling wgp van sequence_based pms for each genome and ii assembled bac sequences including duplicates for the same bac clones sequenced in multiple jobs or pools from hgap jobs for zs and from jobs for mh here we take zs as an example to demonstrate the assembly procedure once these data were loaded supplementary to start a new assembly we set the fpc zs v pm as the physical reference and the irgsp msu i e o sativa subsp japonica cv nipponbare genome_sequence as the reference_genome we checked assign chromosome_number for contigs and orient contigs based on reference_genome since both zs and nipponbare belong to the same genus and species i e o sativa and minor differences between the to be assembled and reference_genomes would not mislead the results because they are so closely_related seq toseq alignment was used to pre build all possible overlapping relationships among all bac sequences since it was expected that those should be connected seq to genome alignment was also used to map all bac sequences to the reference_genome we also utilized the end_to merge auto orient sequences and filter redundant sequences and overlaps options note a similar process was used to assemble the mh genome except we used the fpc mh v pm as the physical reference after manual checking editing and removing redundancies the final assembly products yielded zs composed of assemblyseqs and mh composed of assemblyseqs assemblyctgs that were ordered oriented and assigned to their appropriate chromosomes the assemblyctg sequences were used as the primary frameworks to build pseudomolecules after gap_filling sequences were integrated during the second round of gpm assembly gpm is an integrated pipeline for generating and editing pseudomolecules from existing next gen sequence assembles using evidencebased guides such as reference_sequences physical_maps genetic_maps and paired bess we demonstrated how gpm can be used to generate high_quality submission ready pseudomolecules for two indica_rice accessions zs and mh by the integration of bac based physical_maps and reference_sequence guides to perform an assembly with gpm not all the resources like those used for zs and mh are required but gpm does require at least one guide type e g genetic physical or genome reference since gpm does not reassemble sequence_data from the original short long_reads the kind and quality of the evidence_based guides will greatly affect the amount of time required for editing and will impact the final quality of an assembly using a reference_genome in a gpm assembly is quite valuable however the utilization of more evidence guides can greatly enhance the ability to build high_quality pseudomolecules and to avoid the overuse of the reference_sequences in conforming a gpm assembly to mimic a refseq if a reference_genome is the only evidence to guide an assembly then reference_sequence overuse mistakes cant be avoided however using other information that is available could detect overuse errors which would be corrected during a manual check step which is not labor_intensive and strongly recommended with gpm hence evidence data are key_factors used to build high_quality gpm assemblies in the current version of our lims we can track each processing step from bac library_construction to the final genome_assembly seamlessly during the entire phase of a sequencing project bac_library resources and wet_lab sequencing runs are recorded in our system as a part of the lims gpm supports fasta formatted sequences however the ability to deal with raw_reads has been limited due to their huge data size some additional features such as paired_end mate and mtp information are partially adapted for assembly manipulation in the current version of gpm pseudomolecules in fasta_format with an agp file can be generated as the final output for further downstream_analysis and public repository sequence submissions e g genbank a gpm assemblyctg view of a kb_region assemblyseqs top and bottom are shown as overlapping yellow and fully redundant assemblyseqs are gray the retained green and removed gray portions of assemblyseqs are indicated b chromosome scale view of a kb_region that compares two genome_assemblies to a reference_sequence the reference_sequence is shown in the middle bright green with alignments yellow to each assemblyctg violet at the top and bottom the assemblyctg order can be changed by drag and dropthe lims can be expanded to integrate new functions for a specific project as needed for example we built a pipeline called posthgap to perform circularization and identification of bac sequences for the two rice_genome sequencing_projects described above as reported in our data descriptor we used a map based bac pool sequencing strategy to produce sequence_data that were assembled into a set of sequences termed unitigs by hgap for each pool we were able to process the output of each corresponding hgap job to circularize and identify bac sequences properly using related data information in the lims as follows i posthgap first filtered unitigs with lengths shorter than kb then ii trimmed vectors and circularized plasmid or bac sequences according to pairs of sequences at specific breakpoints and iii assigned bac ids to each sequence according to wgp tags or bes information during the posthgap processing step two parameters default minoverlap bp overlapidentity could be set for sequence circularization and four optional parameters default minclonetagnumber tagmatchidentity tagmatchpercent besmatchidentity if no wgp tags available for bac id assignment the program blastn ncbi_blast was used to perform sequence comparison and alignment analysis in posthgap as a result a total of hgap jobs multiple runs for the same pool count multiple times for pools were run through posthgap in this study and produced bac id ready sequences including duplicates for the same bac processed in multiple jobs or pools for both zs and mh all bac id ready sequences were seamlessly converted as input datasets for both gpm assemblies technically the use of a one main table database schema design may simplify query processing however one possible disadvantage for this schema is that the response time to query might be longer with increasing amounts of data based upon our lims structure we used the new container option for less complicated data and created new tables for large_datasets e g clones to date we are able to operate gpm smoothly on a core cluster with more than million data records these kinds of strategies are recommended for other users we can provide free host services to academic projects of medium_size genomes up to gb with full technical_support several wgs scaffolding packages e g bambus mauve aligner abacas allmaps etc treat assembled contig sequences as nonoverlapping and single_copy sequences unfortunately these packages are not focused toward the handling of inherent sequence redundancies and are not programmed to produce incremental assemblies further these scaffolding tools are all file based and do not provide a flexible process for manual checking and editing especially if the input_data has been modified or updated in contrast gpm is a relationship based pipeline which has the flexibility to edit and visualize assembled data not only by showing the order and orientation of contig sequences and sequence redundancies but also by displaying the necessary guide information for easy user confirmation one thing gpm cannot do is to assemble a genome de_novo from raw_reads this deficit can be compensated for by its ability to import results sequences and agps from other assembly programs to guide new and improved assemblies the final quality of a gpm assembly relies heavily on the quality and richness of the guide information used for example if a draft genome_assembly is used as the guide rather than a map based bac by bac assembly the quality of the gpm assembly will suffer dna_sequencing and assembly programs change rapidly and the gpm pipeline presented here is no exception we will continue to improve the interactive functionalities of gpm as well as integrate additional tools to support more data types with gpm data types are seamlessly linked and logically integrated into an encompassing lims for all genomic_data gpm is an open_source dynamically developed for the genomics research_community and can be extensively adapted improved by different research groups for their own applications 
