yoabs yet other aligner of biological_sequences an efficient linearly scaling nucleotide aligner motivation explosive_growth of short_read sequencing_technologies in the recent_years resulted in rapid development of many new alignment_algorithms and programs but most of them are not efficient or not applicable for reads bp because these algorithms specifically_designed to process short queries with relatively low sequencing_error however the current_trend to increase reliability of detection of structural_variations in assembled_genomes as well as to facilitate de_novo sequencing demand complimenting high_throughput short_read platforms with long read_mapping thus algorithms and programs for efficient mapping of longer_reads are becoming crucial however the choice of long read_aligners effective in terms of both performance and memory are limited and includes only handful of hash_table blat ssaha or trie burrows_wheeler transform smith_waterman bwt sw burrows_wheeler alignerr smith_waterman bwa_sw based_algorithms results new o n algorithm that combines the advantages of both hash and trie based_methods has been designed to effectively align long biological_sequences bp against a large sequence database with small memory_footprint e g gb for the human_genome the algorithm is accurate and significantly more fast than blat or bwt sw but similar to bwt sw it can find all local_alignments it is as accurate as ssaha or bwa_sw but uses times less memory and times_faster than ssaha several times_faster than bwa_sw with low_error and almost two times less memory availability_and the prototype implementation of the algorithm will be available upon request for non commercial use in academia local hit table binary and indices are atdevelopment of sensitive local alignment_algorithms was started in late with several pioneering tools such as fasta and blast for alignments of highly_similar sequences to genomes they were followed later by a new generation of faster methods e g megablast ssaha blat and patternhunter next_generation pushed development of new algorithms even further for efficient processing of millions of short bp reads these ultra_fast tools were orders_of and included soap maq bowtie bwa stampy etc however emerging single_molecule sequencing_technologies are constantly pushing read_lengths into longer and longer realm k base_pairs and more most of these ultra_fast short_read tools do not perform well on these not so short_reads as the tools were exclusively designed for reads bp but efficiently aligning long_reads bp against a long reference_sequence gb like e g the human_genome has different overall objectives and hence represents a different challenge to the development of alignment tools in contrast to short_read when the best match is deduced by the end_to mapping of the query to the reference that minimizes a number of mismatches long read_alignment is often based on several local matches and thus is being able to detect both structural_variations in the query and erroneous assemblies in the reference additionally short_read are optimized for ungapped alignment and introduction of even limited number of short several base_pairs gaps impose heavy performance penalties on these short_read algorithms long read_aligners on the contrary should be able and optimized to deal with arbitrary number of gaps of arbitrary size each the majority of currently available long_read alignment_algorithms may be classified as either using hash_table indexing like in blat or in ssaha or using some sort of compressed trie indexing based on burrows_wheeler transform bwt for example in bwt sw or in bwa_sw but in spite of using different indexing strategies all the above long alignment_algorithms follow the seed andextend paradigm i e they first search for one or more of the so_called seeds either short exact_matches as in ssaha and blat or longer gapped matches in unique regions as in bwasw the found seeds are then extended to cover the whole query_sequence using the smithwaterman_algorithm bwa_sw uses this algorithm for identifying long gapped seeds as well this extension algorithm is computationally_expensive and although long read_aligners introduce various heuristic accelerations to limit use of this computationally penalizing phase by reducing unnecessary seed extensions especially in highly repetitive_regions the resulting tollremains heavy even in currently fastest heuristically accelerated bwt based_algorithms e g bwa_sw this toll is indirectly present through a large constant associated with each bwt operation this article outlines a new long alignment algorithm yet other aligner of biological_sequences yoabs that does not use the seedand extend paradigm and hence does not bear those computational expenses imposed by the smithwaterman_algorithm as a matter of fact it does not use the dynamic_programming at all the algorithm is designed to combine the advantages of both hash and trie based_algorithms similar to hash based_algorithms it uses a series of look ups to build a correspondence between a query and a reference and hence has low associated computational_overhead similar to compressed trie algorithms it compresses highly repetitive_regions and suppresses short repetitive matches that poison the performance of hash based_algorithms the high_accuracy the low computational_complexity as well as low memory_requirements make the algorithm a candidate for specialty implementations with graphics_processing gpus or field programmable gate arrays fpgas the article also presents some preliminary evaluation of algorithms possible practical performance using work in progress test implementation along with bwa_sw and ssaha on both simulated_and yoabs is an efficient algorithm both memory and performancewise for aligning a several hundred or more base_pairs query_sequence to a long reference_genome it has high_sensitivity especially given a long query or a query with low_error the accuracy of yoabs is comparable with the most accurate long sequence aligners so_far e g bwa_sw or ssaha by design yoabs is well suited to detect arbitrary gaps and chimeras therefore it can be used to facilitate detection of structural_variations or reference misassemblies in contrast to the majority of long sequence_alignment e g bwa_sw ssaha or blat yoabs does not use the seed and extend paradigm instead it records all local hits between all l prefix m suffix base_pairs index entries for the reference_sequence organized as a forward and a backward tries and all l m base_pairs subsequences including l and l gapped of the query_sequence the local hits are stored as a table of l scaled modulo k query subtracted location in the reference versus modulo l location in the query as a result the algorithm avoids using the expensive dynamic_programming stage the smithwaterman_algorithm altogether replacing it with linearly scaling simulated_annealing type of procedure the overall complexity of the algorithms is bounded by the complexity of the local hit table building step that is o k q where q is the query length or o q for k used in prototype implementation hence it does not depend on the size r of the reference it would be interesting to estimate the value of a constant in the complexity expression but i would expect it to be much lower than r taking_into relatively low_cost of lookup operations that comprise most of the local hit table construction efforts when comparing with o r q complexity expressions for bwa_sw or bwt sw or with o rq of the dynamic_programming step in general this low complexity also makes the algorithm compelling for gpu and or fpga implementation an important difference of the algorithm from various band accelerated modifications of the smithwaterman_algorithm that is from approaches maintaining a small fraction of the dynamic_programming matrix and hence allowing better than o rq scaling at the expense of missing some of the possible matches for example for gaps larger than chosen band size is that it records all the local hits and therefore will not miss any of the true matches other interesting projects to pursue consist in detailed comparison of performance and accuracy of the simulated_annealing stage of the algorithm with the dynamic_programming for ranges and errors typical for resequencing projects as well as introducing a query indexing to make it sublinear complexity suitable for de_novo sequencing 
