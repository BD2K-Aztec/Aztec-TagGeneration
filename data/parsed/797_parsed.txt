blindcall ultra_fast base_calling of high_throughput sequencing_data by blind_deconvolution motivation base_calling of sequencing_data produced by high_throughput is a fundamental_process in current bioinformatics_analysis however existing third_party probabilistic or machine_learning that significantly improve the accuracy of base calls on these platforms are impractical for production use due to their computational inefficiency results we directly formulate base_calling as a blind_deconvolution problem and implemented blindcall as an efficient solver to this inverse_problem blindcall produced base calls at accuracy comparable to state of the art probabilistic methods while processing data at rates times_faster in most cases the computational_complexity of blindcall scales linearly with read_length making it better suited for new long_read sequencing_technologies availability_and blindcall is implemented as a set of matlab scripts available for download atsecond generation sequencing_technology has revolutionized high_throughput genomics in life_science and clinical research the sheer scale of sequence generated by these instruments has allowed unprecedented views into a number of molecular phenomena including population_genetics transcriptomics epigenetics and translational profiling both the throughput and accuracy of second generation sequencing instruments has increased at an accelerated pace in the last few years due to the use of high_resolution optics and biochemical_methods that allow sequencing of billions of dna_fragments in parallel by generating fluorescence_intensity signals that can be decoded into dna_sequences however due to experimental and hardware limitations these raw signals are inherently noisy base_calling is the essential step of converting these noisy fluorescent intensity signals into sequences used in downstream_analysis providing accurate base calls greatly_reduces many difficulties in downstream bioinformatics_analysis like genome_assembly and variant_calling sequencing by synthesis generates millions of reads of short dna_sequences by measuring in parallel the fluorescence_intensity of billions of pcr_amplified and labeled clusters of dna from a sample of interest the dna_fragments attach to a glass_surface where it is then pcramplified in situ to create a cluster of dna_fragments with identical nucleotide_composition sequence_reads are generated from these dna clusters in parallel and by cycles a single nucleotide is sequenced from all dna clusters in parallel by adding labeled nucleotides that incorporate to their complementary nucleotide this synthesizes dna_fragments complementary to the fragments in each cluster as sequencing progresses a set of four images is created measuring the fluorescence_intensity along four channels to detect incorporation at each cycle these images are then processed to produce fluorescence intensity_measurements from which sequences are then inferred by basecalling in the default base_calling process for illumina sequencers called bustard the highest_intensity in each quadruplet of intensity_measurements determines the base at the corresponding position of the corresponding read for current illumina technologies sequencers can produce up to gb per run the raw intensity signals generated by this process are known to be subject to several biases and b i cross_talk there are significant correlations between different nucleotide channels ii phasing pre phasing the signal in one cycle can spread to the cycles ahead and the cycles after it iii signal decay where signal_intensities become lower in later sequencing cycles iv background_noise the signal_to becomes lower in later sequencing cycles a significant challenge in base_calling is accounting for these biases existing base_calling methods can be classified into two major groups i unsupervised model based_methods that capture the sequencing by synthesis process in a statistical_model of fluorescence_intensity from which base call probabilities can be extracted directly and ii supervised methods that train a statistical_model on a set of base calls whereby fluorescence intensity_measurements are classified into base calls the former methods have been shown to significantly improve the accuracy of bustard base calls these model based_methods aim to capture the sequencing_process described above in a statistical_model from which base call probabilities are usually obtained while these probabilistic or machine_learning improve to whom correspondence should be addressed the author published_by this is an open_access the terms of the creative commons attribution license http creativecommons org licenses by which_permits distribution and reproduction in any medium provided the original_work the accuracy of base calls they are impractical for use due to their computational inefficiency which usually scales quadratically with read_length since most of them resort to dynamic_programming for model_fitting in this article we show that the base_calling problem can be formulated as an optimization_problem called blind_deconvolution based on this observation we developed blindcall as a method that treats base_calling as a blind_deconvolution problem we model intensity signals b output by the sequencer as the convolution of a latent sparse signal of interest x and a convolution kernel k modeling crosstalk and phasing biases plus background_noise n b k x n the blind_deconvolution problem is to recover the latent signal x given only the observed b this reduces the base_calling problem into solving an inverse_problem that admits computationally_efficient solutions the blind_deconvolution problem has been a research hotspot in recent_years and we adapt methods for its solution to the base_calling problem blindcall was able to provide base calls at comparable accuracy to state of the art probabilistic methods while processing data at rates ten times or faster in most cases it scales linearly with read_length and is thus better suited for new long_read sequencing_technologies direct blind_deconvolution modeling and the ultra efficient processing based on optimization_methods presented here are essential for bioinformatics_analysis workflows to cope with increased throughput and read_lengths in new sequencing_technologies blindcall is implemented as a set of matlab scripts available at http cbcb umd edu hcorrada secgen as an example of its computational_efficiency running blindcall on a single core matlab instance on an intel i qm laptop with ghz processor and gb of memory we found that it was able to process million bases s or billion bases cpu day we note that a significant portion of its running time is spent on disk io to read intensity data and write the fasta fastq outputs to the best of our knowledge blindcall is one of the fastest base callers available at this time even though it is implemented in a scripting language a port of this algorithm into a lowerlevel language c c will give further improvements on speed over the current matlab version we compared the running time of blindcall to the state of the art probabilistic base caller ayb and the state of the art supervised_learning method freeibis on a dataset of million_reads from a phix run on an illumina_hiseq we found that blindcall was able to process this dataset times_faster than ayb and times_faster than freeibis while retaining similar accuracy a plot of per cycle error_rate of these basecallers shows that all methods produce significant improvements over bustard especially in later sequencing cycles we observed a similar pattern when testing other datasets we also obtained better assemblies especially at low coverage using blindcall ayb and freeibis relative to bustardayb accuracy and run times for bustard freeibis and blindcall for a dataset of million_reads from a hiseq run of phix blindcall fast corresponds to noniterative version of the blind_deconvolution method running_times for blindcall are reported as processing time total time where the total time includes reading intensity data from disk and writing base calls to disk for freeibis we report the time as predicting time with single thread training time with threads blindcall was able to produce base calls of comparable accuracy to ayb and freeibis at significantly_faster computational time min min versus min and min respectively it is also faster than bustard min min versus min ayb freeibis and blindcall all improve on bustard base calls we also compared assemblies of the phix genome using reads generated by bustard blindcall freeibis and ayb the reported n s and max contig lengths are averages random_samples with the corresponding coverage or while blindcall is able to process data at a significantly_lower computational_cost the assemblies obtained using blindcall are of comparable quality to those obtained using ayb or freeibis blindcall is a simple and ultra_fast non probabilistic base_calling method for illumina high_throughput sequencing_data based on blind_deconvolution we have shown that it provides comparableaccuracy for bustard ayb and blindcall on various datasets blindcall was able to produce comparable accuracy to state of the art base callers at significantly_faster computational time all methods improve on bustard base calls run times for blindcall are reported as training time processing time total time in minutes where the total time includes reading intensity data from disk and writing base calls to disk base_calling by blind_deconvolution is scalable to long read_lengths we compare the computational time of blindcall with a stateof the art probabilistic base caller ayb the state of the art supervised_learning method freeibis and illuminas bustard on the phix dataset reported inas a function of the number of sequencing cycles since most model based base callers resort to a dynamic_programming solution running time is quadratic with respect to the read_length in contrast blindcall scales linearly with read_length base callers based on the blind_deconvolution framework will be able to scale as sequencers produce longer_reads freeibis also scales linearly but is much slower than blindcall third_party base callers improve bustard per cycle error_rate we plot error_rate of each base caller per sequencing cycle on the phix test data all three base callers significantly improve accuracy over bustard especially in later cycles blindcall is able to achieve comparable accuracy while processing data at a much faster rate 
