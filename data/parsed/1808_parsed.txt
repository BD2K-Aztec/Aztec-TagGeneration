fermikit assembly based variant_calling for illumina resequencing data fermikit is a variant_calling pipeline for illumina whole_genome germline data it de_novo assembles short_reads and then maps the assembly against a reference_genome to call snps short insertions_deletions and structural_variations fermikit takes about one day to assemble fold human whole_genome data on a modern core server with gb ram at the peak and calls variants in half an hour to an accuracy comparable to the current_practice fermikit assembly is a reduced representation of raw_data while retaining most of the original information availability_and https github com lh fermikit contact hengli broadinstitute orgdeep resequencing of a human sample typically results in a bam_file of gb in size storing distributing and processing many such huge files is becoming a burden for sequencing facilities and research labs while better compression helps to alleviate this issue it adds processing time and can barely halve the size which does not keep up with the rapidly increasing sequencing throughput illumina and gatk use gvcf as a reduced representation of raw_data however gvcf is reference dependent and it is nontrivial to encode both large and small variants consistently we still need to go back to raw_data for long events and when upgrading the reference_genome another idea from the past practice is to assemble sequence_reads into contigs that ideally retains all information in the raw_data but whether this approach is practical to illumina human resequencing remains to be confirmed we have run fermikit on multiple whole_genome datasets of sample na along with gatk haplotypecaller hc in brief and freebayes we used genome in abottle giab as truth data to evaluate the accuracy recent illumina data have excessive systematic errors around poly a which hc does not handle well it called over false indels from sample s and s with the vast_majority around poly a we excluded these regions to avoid one simple error source greatly affecting the metrics after this treatment variant callers are broadly comparable when the same set of hard filters are applied vqsr as is advised in gatk best practice does not work well with single sample calling giab was generated from multiple na call sets it is potentially biased against new callers and biased towards easier regions that can be called by the existing callers for example the gatk which is overly good and is worrying we turned to the chm na dataset for an unbiased evaluation in this evaluation fermikit produces calls of higher specificity at the cost of sensitivity this is probably because fermikit is less powerful in repetitive or duplicated regions or regions affected by systematic artefacts nonetheless in wellbehaved regions that are outside unimask the loss of sensitivity is minor the gain in precision is significant if we consider that there may be k real heterozygous snps in chm which should not be counted as fps fermikit performs well in calling long deletions while it does not use read_pairs it achieves comparable sensitivity and higher specificity in comparison to the popular tools fermikit also called insertions over bp and identified multiple kb_long contigs having poor alignments to grch but nearly perfect alignment to a pacbio assembly of chm ac gca we also mapped the chm fermikit unitigs to the pacbio assembly and called long deletions insertions and other events as pacbio assemblies are generally of higher quality these numbers give a rough estimate on the number potential false_positives of fermi on a haploid dataset 
