pardre faster parallel duplicated reads removal tool for sequencing studies current next_generation often generate duplicated or near duplicated reads that depending on the application scenario do not provide any interesting biological_information but can increase memory_requirements and computational time of downstream_analysis in this work we present pardre a de_novo parallel tool to remove duplicated and near duplicated reads through the clustering of single_end or paired_end sequences from fasta or fastq_files it uses a novel bitwise approach to compare the suffixes of dna strings and employs hybrid mpi multithreading to reduce runtime on multicore systems we show that pardre is up to times_faster than fulcrum a representative state of the art tool on a platform with two core sandy bridge processors availability_and source_code in c and mpi running on linux systems as well as a reference manual are available at https sourceforge net_projects pardre the progress of next_generation ngs_technologies has led to large_datasets that are used in a wide_range of bioinformatics applications preprocessing of ngs_datasets is often required to either reduce their sizes or improve data_quality one such preprocessing_step is the removal of duplicated and near duplicated reads there are two approaches to remove these type of reads mapping based and de_novo strategies the first approach initially maps the reads to a reference_genome and discards those reads that are aligned to the same position unfortunately it requires a complete genome as reference which is not always available the de_novo approach only needs the ngs input_data and has gained attention in recent_years examples of de_novo tools include fastuniq not able to remove near duplicated reads fulcrum parallelized for multicore and distributed systems with mapreduce and g cnv parallelized for cuda enabled gpus in this paper we describe pardre a fast de_novo tool to remove duplicated and near duplicated reads with support for both singleend and paired_end datasets pardre uses a novel bitwise approach to compare dna strings and exploits the computational power of current multicore cpus by employing both multithreading and message_passing mpi mutithreading support is part of all compilers that follow the c standard while there exist many mpi open public compilers i using only threads one mpi process and ii using the hybrid_approach with the best combination of processes and threads we also include in our table the runtime for g cnv on an nvidia k gpu obtained from the selected configurations are the same as in the g cnv reference in order to provide a fair comparison the results show that pardre consistently outperforms fulcrum firstly our c suffix comparison based on bitwise operations is faster than the python implementation included in fulcrum additionally fulcrum uses mapreduce for parallelization thus it needs intermediate files to distribute the clusters among threads pardre uses an efficient on demand multithreaded implementation that only requires main_memory and avoids the overhead of i o operations moreover the experimental_results also show that launching mpi processes instead of only threads further improves_performance this is due to two reasons on the one hand as explained in section the efficient parallel mpi i o routines allow us to parallelize the reading and clustering of the input dataset as well as the writing of the results on the other hand the hybrid_approach reduces the thread synchronization overhead to know which clusters have not been analyzed yet but it still exploits all the available cores in the machine thanks to the mpi parallelization furthermore we can assert that pardre executed on both systems is also faster than g cnv running on specialized hardware an nvidia k gpu regarding the memory_consumption pardre requires less than gb in the worst_case for all tests in while fulcrum and g cnv require and gb respectively conflict of interest none declared 
