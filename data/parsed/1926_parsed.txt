genome_analysis gap editing the billion fragment sequence_assembly motivation existing sequence_assembly editors struggle with the volumes of data now readily available from the latest generation of dna_sequencing instruments results we describe the gap software along with the data_structures and algorithms used that allow it to be scalable we demonstrate this with an assembly of billion sequence_fragments and compare the performance with several other programs we analyse the memory cpu i o usage and file sizes used by gap with the latest wave of dna_sequencing the number of individual fragments readily available for both mapping and de_novo assemblies has grown many fold this has often been coupled with a shortening of each individual fragment as a consequence a full mapping of the entire_human may conceivably have as many as a billion fragments while many applications of new sequencing_technologies make use of mapped assemblies de_novo sequence_assembly is still common these may contain misassemblies or require further finishing work to resolve gaps to progress from the draft standard toward finished sequence we need tools capable of both viewing and editing our large_scale assemblies traditional algorithms used in earlier sequence_assembly viewers and editors such as gap consed hawkeye and eagleview tend to scale poorly with the number of fragments for example gap s memory and cpu usage typically scale linearly with the number of fragments in the assembly it became clear that the underlying data_structures in these older tools are insufficient for the data_volumes that we now routinely see recently several viewers including samtools mapview igv http www broadinstitute org igv tablet and ngsview have been released that aim to reduce the algorithmic complexity to whom correspondence should be addressed and memory_footprint however the solutions typically employed by these programs are only amenable for read only access with the exception of ngsview that can perform some minor editing tasks in addition to algorithmic efficiency the large increase in the number of dna_fragments has put a strain on our storage requirements by using data compression_methods the storage burden can be greatly_reduced with the bam file_format being one such recent example when coupled with an index compressed bam_files can be randomly accessed we present the gap program a sequence_assembly viewer and editor this encompasses both base by base editing operations as well as high_level contig rearrangements complementing breaking and joining being able to change data has a substantial impact on the choice of data_structures and file_formats which are described below we also demonstrate the compression techniques used in gap and compare their effectiveness to existing_tools for an initial test we chose to use the data presented in the mapview paper million bp reads aligned in a single mb contig we converted this file to a variety of formats taking_care to include the appropriate data including sequence names bases and quality supported by all formats and no more we then measured the cpu time taken to start up the program open the assembly and view sequence_assembly at the start of the first contig presents these results as dataset a along with the programs native file sizes see the supplementary_material for a more complete break down on the assembly file sizes as can be seen the programs mostly cluster into two groups with eagleview gap and consed being very demanding on both memory and cpu these three also had the largest disk_space requirements the last fourmapview igv samtools and gap all demonstrate acceptably low resource requirements for both cpu and memory while also using substantially less disk_space ngsview is very cpu and memory_efficient but is inefficient on disk_space usage note that the cpu time and memory also includes the constant overhead of launching the programs so it may not accurately_reflect the relative positions of the last five programs when faced with much larger datasets to further test scalability we used a genomes http www genomes org project sam file containing billion reads from the na sample note that this bam_file contained only mapped data with the only auxiliary records being the read page uses a simple database rather than a flat file i o efficiency could be a concern so to test i o efficiency we compared gap with gap and samtools tview on the million read dataset a the results indemonstrate that the start up cost of gap is low as it does not load the entire index into memory but a consequence of using a database means that we require many more disk seeks than samtools gap in comparison is very i o intensive as it loads partial information about every sequence when it opens the database when scrolling along a contig view both gap and gap demonstrate a minimal amount of additional data loaded due to onthe fly caching in gap and having preloaded most of the data in gap it is clear that gap s approach of blocking sequences together per database record dramatically_reduces the number of i o calls samtools demonstrates an apparent lack of data caching in this test but was still fast and responsive the complexity of editing operations is where gap really stands out against gap the inability to reposition large_numbers of sequences without individually editing each one causes gap to generate millions of i o calls when breaking contigs in two or joining them together to verify the efficiency of gap against a billion read assembly we repeated these tests on dataset b as can be seen in edits still require a relatively small amount of i o the speed was also acceptable to perform all breaks joins substitutions and insertions took s of cpu time we could not compare editing of this dataset against gap due to time and memory constraints but for viewing purposes we also tested samtools in contrast with the smaller set we observe that samtools reads far more data whenopening the assembly this is due to completely loading the bam index file into memory the lack of caching in samtools is again evident during the scrolling test to evaluate storage size we experimented with a variety of compression algorithms on the sam_files exported from gap and compared these with gap s native format using both the lz zlib and lzma xz utils algorithms for speed reasons we only tested this with the smaller dataset a presents these findings the paq algorithm and variants have won the hutter prize for compression multiple times and can be considered as at the cutting_edge for general_purpose compression regardless of the cost in cpu while not practicalit took h to compress the sam file it is a useful baseline to compare ourselves against for comparison tg index produced the gap database in s when using lz and s using lzma it is clear that gap has not had to compromise greatly on storage space in order to achieve both random_access and editability of data tg index has the ability to ignore certain types of data or to replace them with blank data such as producing minimal names setting all quality values to zero or even replacing all base calls page with n from this an analysis of the storage per type of data is presented in it is clear that the quality values constitutes the bulk of the file size with the dna_sequence taking up less than bit per base call this figure is substantially less than the expected bits_per due to redundancy in the sequence depth and so clearly the results will differ when tested on other datasets we have demonstrated that we can keep and sometimes improve upon the cpu memory and i o efficiency of the next generation assembly viewers while also supporting editing capabilities this is a marked improvement over the gap program however it is clear that performance is just one aspect and utility also needs to be considered currently gap offers a much richer set of tools than gap and is also available on a broader range of platforms over time we expect to duplicate the most important gap features in gap and also plan to port gap to microsoft windows there are still some performance issues even with gap as intrinsically certain algorithms will not be possible to get below o n complexity such as plotting an entire chromosome or identifying all local_alignments in an entire_genome some algorithms can benefit from precomputation of results at a cost of increased storage which so_far we have only implemented for consensus caching we have outlined ways that the binning tree can be used to store additional precomputed depth data this aspect of gap is still largely_unexplored but we envisage a variety of additional cached tracks for rapid visualization in the template display further analysis of the i o patterns reveals that the bulk of i o calls while breaking contigs are manipulating the bin tree samtools and the ucsc_genome both use trees with eight children per node rather than the binary tree implemented in gap implementing a similar change to gap should further improve i o performance it is likely that users will want to keep both their standard alignment format data such as bam_files as well as using gap for viewing and possibly editing the fact that gap is efficient in space helps but it is clear that this is an additional_cost over and above the storage requirements for the input_data one possible solution to this is to observe that indexing just the sequence_positions tg index d blank is only an extra on top of the bam format it may be possible to get gap to extract names sequences and qualities from bam while still retaining the positional index for use in the template display the next logical step is to implement a copy on write scheme where only edited sequences get added to the gap database this will bring the additional overheads of editing to an acceptable level 
