protein threading using context specific alignment potential motivation template_based including homology_modeling and protein threading is the most reliable method for protein_d however alignment errors and template selection are still the main bottleneck for current template base modeling_methods especially when proteins under consideration are distantly_related results we present a novel context specific alignment potential for protein threading including alignment and template selection our alignment potential measures the log odds_ratio of one alignment being generated from two related proteins to being generated from two unrelated proteins by integrating both local and global context specific information the local_alignment potential quantifies how well one sequence residue can be aligned to one template residue based on context specific information of the residues the global_alignment potential quantifies how well two sequence residues can be placed into two template positions at a given distance again based on context specific information by accounting for correlation among a variety of protein features and making use of context specific information our alignment potential is much more sensitive than the widely used context independent or profile_based scoring_function experimental_results that our method generates significantly better alignments and threading results than the best profile based_methods on several large benchmarks our method works particularly well for distantly_related proteins or proteins with sparse sequence_profiles because of the effective integration of context specific structure and global information protein_structure is essential for the understanding of protein functions predicting the d structure of a protein from its sequence remains one of the grand challenges confronting computational_biologists template_based tbm such as homology_modeling and protein threading is the most reliable method and can produce reasonable d models for about twothird of the proteins without solved structures tbm is based on the observation that protein_structures are much more conserved than sequences that is given a target protein_sequence we can predict its d structure by aligning it to structurally_similar protein_structures in pdb the model quality of tbm depends on sequence template alignment and template selection both of which are challenging when only distantly_related templates are available for a protein_sequence under prediction the threading accuracy critically depends on the choice of a threading scoring_function most of current methods make heavy use of position specific information such as sequence_profile which is usually represented as a positionspecific scoring_matrix or a profile hmm although sequence_profile is effective on homolog detection it is only position specific but not context specific further it is also lack of structure information e g secondary_structure and solvent_accessibility context specific information refers to the information in the sequential neighborhood of one residue the neighboring residues of a given residue play_an in shaping the mutation pattern of the residue few alignment_methods such as cs blast biegert and sodingsoding are developed to make use of context specific information even cs blast makes use of only sequence but not context specific structure information to the best of our knowledge no protein threading method has integrated well both context specific sequence and structure information although many protein alignment_methods use only local information a few protein threading methods were developed to use global information such as pairwise contact potential which quantifies how well two sequence residues can be placed into two template positions in a contact however the gain from pairwise contact potential is not significant as compared with the impact of sequence_profile on protein_alignments the underlying reason may be that the contact based pairwise potentials used in these threading methods do not carry too much extra signal to significantly improve the effectiveness of global information especially pairwise potential in protein threading this article studies a context specific distance based pairwise potential our pairwise potential is built on context specific information and much more sensitive than the context independent contact based pairwise potentials and thus greatly helps improve protein threading this article_presents a novel context specific alignment potential for protein threading including both alignment and template selection our alignment potential measures the log odds_ratio of one alignment being generated from two related proteins to being generated from two unrelated proteins by integrating context specific local and global information an alignment is assumed to be optimal if it maximizes the alignment potential the local_alignment potential quantifies how well one sequence residue can be aligned to one template residue based on contextspecific information of these two residues the global_alignment potential quantifies how well two sequence residues can be placed into two template positions at a given distance again based on residue context specific information in this article the context of one residue includes a variety of correlated protein features such as sequence_profile information predicted_secondary and solvent_accessibility amino_acid physic chemical_properties in a local window centered at the residue we integrate these correlated protein features into an accurate alignment potential using advanced statistical_learning methods including conditional neural fields to whom correspondence should be addressed the author published_by this is an open_access the terms of the creative_commons http creativecommons org_licenses which permits non commercial re use distribution and reproduction in any medium provided the original_work for commercial re use please_contact permissions_oup com experimental_results show that our contextspecific alignment potential is much more sensitive than the widely used context independent or profile_based which is position specific scoring_function generating significantly better alignments and threading results than the best profile based_methods on several large benchmarks our method works particularly well for distantly_related proteins or proteins with sparse sequence_profiles because of the effective integration of contextspecific structure and global information training and validation_data we constructed the training and validation_data from bc a subset of pdb in which any two proteins share_sequence in total we use a set of protein pairs as the training data which covers most of the folds in the scop database and a set of protein pairs as the validation_data there is no redundancy between the training and validation_data i e sequence_identity the training and validation_data have the following properties i all the proteins have lengths and contain of residues with missing coordinates ii the tm_score of a protein pair is uniformly_distributed from to and iii we use our in house structure alignment_tool deepalign to generate the reference alignment for a protein pair each alignment has fewer than middle gaps and the number of terminal gaps is of the alignment_length test data for alignment we use the following three datasets to test the alignment_accuracy of our method set k a set of protein pairs any two target_proteins in this set share_sequence the tmscore of a protein pair is uniformly_distributed between and two proteins in a pair have small length difference the protein pairs in set k have of overlap with our training and validation_data by overlap we mean that the proteins in one pair have sequence_identity with those in another pair set k a set of protein pairs any two target_proteins in the set share_sequence the protein pairs in set k have of overlap with our training and validation_data two proteins in a pair have length difference therefore this set can be used to test whether the domain boundary is correctly aligned set k a very large set of protein pairs any two proteins in most pairs share_sequence the tm_score of a protein pair is uniformly_distributed between and note that the size of our training_set is only of this large set therefore the test result on this set is unlikely biased by the training_set test data for threading we use the following two datasets to test the threading accuracy of our method set a large set constructed from pdb which consists of proteins all the proteins in pdb are used as templates and of them are randomly_chosen as the target_proteins we predict the d structure for all the targets using the templates but excluding self threading casp a set of test proteins we use the casp official domain boundary definition for each test protein evaluation criteria and programs to compare we evaluate our threading method using both reference dependent and referenceindependent alignment_accuracy the reference dependent accuracy is defined as the percentage of correctly aligned positions judged by the reference alignments which are built using our in house tool deepalign we also built the reference alignments using other structure alignment tools such as dali matt and tmalign and observed similar performance trend to evaluate the reference independent alignment_accuracy we build a d model for the target protein using modeller s ali et_al from its alignment to the template and then evaluate the quality of the resultant d model using tm_score tm_score ranges from to indicating the worst and best model quality respectively as our ultimate_goal is to predict d structure for a target protein referenceindependent alignment_accuracy is more important than reference dependent accuracy we compare our method with the top notch profile_based method hhalign which is run with the option mact as shown in our method outperforms hhalign in terms of both reference dependent and reference independent alignment_accuracy on the two benchmarks set k and set k on these two sets our method outperforms hhalign by and respectively in terms of the model quality i e referenceindependent accuracy in terms of reference dependent accuracy our method is better than hhalign by only and which is not as big as reference independent accuracy we also calculate the reference dependent accuracy on set k and set k by allowing four position off the exact match as shown in which indicates that our method is still much better than hhalign when four position off the exact match is allowed as shown in on the very large set k set our method yields slightly better performance than hhalign when two proteins under consideration are similar this is not surprising as most methods can generate pretty good alignments for two closely_related when the tm_score of two proteins under consideration falls into our method outperforms hhalign by in terms of the reference dependent accuracy and by in terms of the reference independent accuracy when the tm_score of two proteins under consideration falls into our method outperforms hhalign by in terms of the reference dependent accuracy and by in terms of the reference independent accuracy when the tm_score of two proteins falls into our method outperforms hhalign by a very large margin in terms of reference dependent alignment_accuracy however in terms of the reference independent alignment_accuracy the advantage of our method is not as big although it is still substantial this may be because that modeller cannot build a reasonable model from an alignment with too many errors by the way when the tm_score of two proteins is it may not be so important to generate an accurate alignment for them as the resultant d model has low quality and thus will not be useful threading performance on a large test_set we test the threading performance of our method and hhpred on set we run both our method and hhpred to predict the d structure for each of the targets using the templates hhpred is run with its realign option that is hhpred first searches through the template database using local_alignment and then re aligns a target to the top templates using global_alignment by doing so hhpred can improve its modeling accuracy a little bit over the default mode to speed up our method first aligns a target to all the templates using only the local_alignment potential and then ranks all the templates using both the local and global_alignment potentials described insection after ranking only the first ranked templates are used to build a d model by modeller for each target as shown in our method is significantly better than hhpred when the targets are not so easy i e the hhpred model has tm_score on the targets our method and hhpred obtain average tm_score and respectively our method outperforms hhpred no matter whether the target is easy or hard if we exclude the easy targets i e either our model or hhpred model has tm_score from consideration the accumulative tm_score obtained by our method and hhpred is and respectively that is our method is better than hhpred further as indicated by the yellow lines in our method can generate models with tm_score for many targets for which hhpred fails to generate a model with tm_score we use tm_score as a cutoff because when a model has tm_score its overall fold is basically correct as shown in our method generates models better than hhpred by at least for targets whereas hhpred is better than our method by this margin for only targets further the number of targets for which our method generates models better than hhpred by at least is whereas hhpred is better than our method by this margin for only targets in summary our method has a large advantage over hhpred on hard targets threading performance on casp data_set we further evaluate the threading performance of our method on the most recent casp_targets we use the casp official domain boundary definition for each target and in total there are test proteins to make the test as fair as possible both our method and hhpred used the same set of templates and the same protein_sequence database i e nr which were constructed before casp started as shown in similar to what we have observed on the large threading test_set our method significantly_outperforms hhpred when the targets are not so easy our method generates a model with tm_score for a few targets for which hhpred fails to generate a model with tm_score on the whole testnote reference independent alignment_accuracy is measured by tm_score the protein pairs are divided_into four groups depending on their structure similarity measured by tm_score we exclude the server targets from consideration and only look at the more challenging human server targets the average tm_score obtained by our method and hhpred is and respectively that is our method is better than hhpred it is challenging to fairly compare our single_template threading method with the casp participarting servers because that most of the casp servers used a hybrid method instead of an individual threading method for example the first ranked zhang server integrated both consensus analysis of individual threading programs and fragment based d model_building technique the top_ranked hhpred server integrated new profile generation method multi template alignment and a better d model_building technique the top_ranked robetta server used consensus results from three programs including hhpred raptorx and sparks and also a new d model_building method our raptorx server which is ranked no overall used multiple template threading which can generate better d models than single_template threading for many targets especially the easy ones in summary the accumulative tm_score obtained by our single_template threading method described in this article is only less than what was obtained by raptorx in casp it can be ranked no among all the casp participating servers p value it is desirable that any structure_prediction program can assign a confidence_score to predicted models here we use p value to quantify the relative quality of the top_ranked templates and alignments to calculate the p value we use a set of reference templates which consist of single domain templates with different scop folds given a target we first thread it to this reference template database and then estimate an extreme value distribution from the alignment scores i e alignment potentials based on this distribution we calculate the p value of each alignment when threading the target to the real template database the p value actually measures the quality of the template and the alignment by comparing it with the reference templates to measure the real model quality we use both gdt global distance test and ugdt i e un normalized gdt gdt has been used as an official measure by casp for many years it measures the quality of a model by comparing it with the native and outputs a value from to indicating the worst and the best quality respectively ugdt is equal to gdt times the target length divided by ugdt is more suitable when a large or multi domain target protein can only be partially covered by good templates in this case gdt is likely to be small and not a good indicator even if the templates are closely_related to the target as gdt is normalized by the whole target length however ugdt is not good for a target with length smaller than for example when a target of residues is covered by a template perfectly on of the residues the ugdt of this alignment is whereas the gdt is in this case gdt is more suitable than ugdt in summary we use max ugdt gdt to measure the model quality we say one alignment is reasonable when its resultant model has ugdt or gdt we use as a cut_off because that many proteins similar at only the fold level have gdt or ugdt as shown in the p value is a reliable_indicator of model quality when p value is small i e the models have ugdt or gdt even if p value is there are few models that have both ugdt and gdt that is the prediction from our threading method is reliable when the p value is contribution of the distance based pairwise potential to evaluate the contribution of our pairwise potential to alignment_accuracy we calculate the accuracy improvement resulting from adding our pairwise potential to the alignment potential using two benchmarks set k and set k as shown in our pairwise potential can improve reference dependent accuracy by and reference independent accuracy by respectively we have not fully exploited the power of our pairwise_alignment potential because it is computationally_expensive we just used our pairwise potential to refine the alignment generated by local_alignment potential as follows for each aligned position generated by our local potential we allow it to move at most four positions to improve the total potential i e local potential pairwise potential we expect that a more efficient pairwise potential optimization_algorithm that can search a larger alignment space will further improve the alignment_accuracy we also evaluate the contribution of our pairwise potential to template selection to speed up we generate alignments using our local_alignment potential and then rank all the templates using a linear combination of our local and pairwise_alignment potentials with equal weight experimental_results on the threading set and the casp set indicate that the pairwise potential indeed improves template selection as shown in figures and on the set the average tm_score increases from to when the pairwise potential is used to rank the templates on the casp set the accumulative tmscore increases from to when the pairwise potential is used as shown_inand the context specific pairwise potential is particularly helpful to hard targets case study here we use two specific examples to further demonstrate the strength of our method both of these two cases are from our set k benchmark the first example is to align two proteins qnra and gffa which have tmscore between and according to the structural_alignments generated by tm_align matt dali and our in house tooldeepalign that is these two proteins are similar in structures but not much in sequences meanwhile gffa contains two and two segments that are similar to one domain in qnra as shown in our method can correctly align of the positions judged by the reference alignment regardless of which structural_alignment tools are used to generate it in contrast hhalign fails to align the second and segments this is partially because hhalign favors generating short alignment if we choose qnra as the template to build a d model for gffa the resultant models from our method and hhalign have tm_score and respectively we use another two proteins k a and cb a to showcase that our method and hhalign generate two alignments of nearly the same length but our alignment has much better quality as shown in our method aligns nearly of positions correctly whereas hhalign fails to align any position correctly if we use k a as the template to build models for cb a the resultant d models from our method and hhalign have tmscore and respectively we can also examine the alignments visually as shown_inand b our method aligns the local structure well whereas hhalign seemingly produces a totally wrong alignment in this case both k a and cb a have pretty good sequence_profile information and the predicted_secondary for cb a is also accurate this article has presented a novel protein threading method using a context specific alignment potential which measures the two alignments between qnra and gffa generated by our method and hhalign the blue and red colors demonstrate correctly aligned regions judged by the reference alignment to save space only one of the domains of qnra is shownof the distance based pairwise_alignment potential to set each point represents the quality measured by tmscore of two models one is generated using the local_alignment potential only x axis and the other using both the local and global_alignment potentials y axis contribution of the distance based pairwise_alignment potential to the casp set each point represents the quality measured by tmscore of two models one is generated using the local_alignment potential only x axis and the other using both the local and global_alignment potentials y axis the relationship between p value and the model quality on the casp_targets the x axis is the model quality measured by max gdt ugdt and the y axis is log p value note reference independent alignment_accuracy is measured by tm_score 
