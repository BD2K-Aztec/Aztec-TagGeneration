genome_analysis a memory_efficient data_structure representing exact match overlap graphs with application for next generation dna assembly motivation exact match overlap graphs have been broadly used in the context of dna assembly and the shortest super string problem where the number of strings n ranges from thousands to billions the length of the strings is from to depending on the dna_sequencing however many dna assemblers using overlap graphs suffer from the need for too much time and space in constructing the graphs it is nearly impossible for these dna assemblers to handle the huge amount of data produced by the next_generation where the number n of strings could be several billions if the overlap_graph is explicitly stored it would require n memory which could be prohibitive in practice when n is greater than a hundred million in this article we propose a novel data_structure using which the overlap_graph can be compactly stored this data_structure requires only linear time to construct and and linear memory to store results for a given set of input strings also called reads we can informally define an exact match overlap_graph as follows each read is represented as a node in the graph and there is an edge between two nodes if the corresponding reads overlap sufficiently a formal description follows the maximal exact match overlap of two strings x and y denoted by ov max x y is the longest string which is a suffix of x and a prefix of y the exact match overlap_graph of n given strings of length is an edge weighted graph in which each vertex is associated with a string and there is an edge x y of weight ov max x y if and only if where ov max x y is the length of ov max x y and is a given threshold in this article we show that the exact match overlap graphs can be represented by a compact data_structure that can be stored using at most logn log n bits with a guarantee that the basic operation of accessing an edge takes o log time we also propose two algorithms for constructing the data_structure for the exact match overlap_graph the first algorithm runs in o nlogn worse case time and requires o extra memory the second one runs in o n time and requires o n extra memory our experimental_results on a huge amount of simulated_data from sequence_assembly show that the data_structure can be constructed efficiently in time and memory availability our dna_sequence assembler that incorporates the data_structure is freely_available on the web atan exact match overlap_graph of n given strings of length each is an edge weighted graph defined as follows each vertex is associated with a string and there is an edge x y of weight ov max x y if and only if where is a given threshold and ov max x y is the length of the maximal exact match overlap of two strings x and y ov max x y is called the overlap threshold the formal definition of the exact match overlap_graph is given in section storing the exact match overlap graphs efficiently in term of memory becomes essential when the number of strings is very large in the literature there are two common data_structures to store a general graph g v e the first data_structure uses a d array of size v v we refer to this as an array based data_structure one of its advantages is that the time for accessing a given edge is o however it requires v memory the second data_structure stores the set of edges e we refer to this as an edge based data_structure it requires v e memory and the time for accessing a given edge is o log where is the degree of the graph both these data_structures require e memory if the exact match overlap graphs are stored using these two data_structures we will need e memory even this much of memory may not be feasible in cases when the number of strings is over a hundred million in this article we focus on data_structures for the exact match overlap graphs that will call for much less memory than e we have implemented a dna_sequence assembler named largescale efficient dna assembly program leap that incorporates our data_structure for the overlap graphs the assembler has three stages preprocess input dna_sequences construct overlap_graph and assemble in the context of dna sequence_assembly the input dna_sequences are called reads in the first stage we add the reverse complement strings of the reads then we sort them and remove contained reads the second stage is the main focus of our article constructing the data_structure of the overlap_graph the last stage basically analyzes the overlap_graph then retrieves unambiguous paths and outputs the contigs accordingly we tested our assembler on simulated_data as follows first we simulated a genome g then each read of length is drawn from a random location in either g or the reverse complement of g reads drawn from the genome are error_free reads the number n of the drawn reads is determined by the coverage depth c by the equation n c g we considered three datasets with the same read_length the same coverage depth c and different genome_sizes mb gb and gb the number of reads in the datasets is million million and million respectively the size of the first genome is approximately the size of human_chromosome the size of the third genome is approximately the whole human genome_size for the first and the second dataset we have run our assembler with varying values of the overlap threshold or we only tried the overlap threshold for the last dataset because the run time was quite long about days to assess the quality of the contigs we aligned them to the reference_genome and found that all the contigs appeared in the reference_genome we have run our assembler on a ubuntu linux machine of ghz cpu and gb ram to save memory_usage we choose the binary search based algorithm to construct the overlap_graph in the second stage the details are provided in tables and the dna_sequence assembler developed by simpson and durbin also employs the overlap_graph approach their assembler named string_graph assembler sga uses the suffix_array and fm_index for the entire read set to construct the overlap_graph this article reported that the bottleneck in terms of time and memory_usage was in constructing the suffix_array and fm_index that required h and about gb of memory on the first dataset the total processing time was h on the third dataset they estimated by extrapolation that the step of constructing the suffix_array and fm_index would require about days and gb of memory the total processing time on the third dataset would be more than that however sga has been improved in terms of memory_efficiency since its first version was released unfortunately while the second version of sga improves memory_usage its run time increases we were able to run the latest_version of sga on the same machine on the datasets the source_code of the latest_version of sga can be foundprovides the time and memory comparison between the assemblers for all of the datasets we have run the two assemblers with the same overlap threshold the contigs output by the two assemblers were almost the same we have described a memory_efficient data_structure that represents the exact match overlap_graph we have shown that this data_structure needs at most logn log n bits which is a surprising result because the number of edges in the graph can be n also it takes o log time to access an edge through the data_structure we have proposed two fast algorithms to construct the data_structure the first algorithm is based on binary search and runs in o nlogn time and takes o extra memory the second algorithm based on the trie runs in o n time which is slightly faster than the first algorithm but it takes o n extra memory to store the trie the nice thing about the first algorithm is that the memory it uses is mostly for the input strings this feature is very crucial for building an efficient dna assembler we are also developing our assembler leap that incorporates the data_structure for the overlap_graph the experimental_results show that our assembler can efficiently handle datasets of size equal to that of the whole human_genome currently our assembler works for error_free reads in reality reads usually have errors if the error_rate is high our assembler may not work well however with improving accuracy in sequencing_technology the error_rate has been reduced if the error_rate is low enough we will have many error_free reads which means that our assembler will still work in this case also an alternative way to use our assembler is to first correct the reads before feeding them to our assembler in future we would like to adapt our assembler to handle reads with errors as well 
