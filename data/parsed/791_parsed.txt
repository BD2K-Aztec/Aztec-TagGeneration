sequence_analysis bitpal a bit parallel general integer scoring sequence_alignment algorithm motivation mapping of high_throughput sequencing_data and other bulk sequence comparison applications have motivated a search for high_efficiency sequence_alignment the bit parallel approach represents individual cells in an alignment scoring_matrix as bits in computer words and emulates the calculation of scores by a series of logic operations composed of and or xor complement shift and addition bit parallelism has been successfully_applied to the longest common subsequence lcs and edit_distance problems producing fast algorithms in practice results we have developed bitpal a bit parallel algorithm for general integer scoring global_alignment integer scoring_schemes assign integer weights for match mismatch and insertion_deletion the bitpal method uses structural_properties in the relationship between adjacent scores in the scoring_matrix to construct classes of efficient algorithms each designed for a particular set of weights in timed tests we show that bitpal runs times_faster than a standard iterative algorithm availability_and source_code is freely_available for download at http lobstah bu edu bitpal bitpal html bitpal is implemented in c and runs on all major operating_systems sequence_alignment are critical tools in the analysis of biological sequence_data including dna rna and protein_sequences the demands placed on computational_resources by high_throughput experiments require new more efficient methodologies while the standard algorithms of smith andand needleman andcalculate the score in each cell of the alignment scoring_matrix sequentially a newer technique called bit parallelism partially overcomes score dependencies so that scores can be calculated in parallel to achieve much higher efficiencies bit parallel algorithms have been developed for exact and approximate string matching problems early examples_include the algorithms of baeza yates and which finds exact_matches to a simple string pattern and which finds approximate matches to a string pattern or a regular expression where the number of differences between the pattern and the text is at most k counting single character substitutions and single character insertions_and or indels the latter is implemented as the unix command agrep additional k differences examples_include which finds matches to limited expressions i e regular expressions without kleene closure which finds matches to simple string patterns and emulates the dynamic_programming solution used in alignment and which allows arbitrary integer weights for substitution of each pair of characters insertion of each character and deletion of each character and finds occurrences of regular expressions where the sum of the edit weights is at most k in most k differences algorithms the complexity and computing time increases with increasing k bit parallel methods have been successfully_applied to the longest common subsequence lcs problem and to unit cost edit_distance hyyr o and by modifications of myerss method these algorithms compute the alignment score de linking that computation from the traceback which produces the final alignment in the lcs scoring_matrix scores are monotonically non decreasing in the rows and columns and bit parallel implementations use bits to represent the cells where an increase occurs in edit_distance scoring adjacent scores can differ by at most one and the binary representation stores the locations of two of the three possible differences and zero these algorithms are ad_hoc in their approach relying on specific properties of the underlying problems making_it to directly adapt them to other alignment scoring_schemes below we present a bit parallel method for similarity and distance based global_alignment using general integer scoring allowing arbitrary integer weights for match mismatch and indel other approaches have been suggested byand bergeron and hamel the method ofis more flexible in scoring and applies to both simple patterns and regular expressions but is much slower than our method in practice our contribution is based on an observation of the regularity in the relationship between adjacent scores in the scoring_matrix section and the design of an efficient series of bit operations to exploit that regularity section because every distinct choice of weights requires a different program we show how to construct a class of efficient algorithms each designed for a particular set of weights and provide an online c code generator for users to whom correspondence should be addressed the author published_by this is an open_access the terms of the creative commons attribution license http creativecommons org licenses by which_permits distribution and reproduction in any medium provided the original_work the complexity of our algorithms depends on the weights not the ultimate score of the alignment our method works for general alphabets but our interest derives from frequent use of dna alignment when analyzing high_throughput sequencing_data to detect genetic_variation the bitpal and bitpal packed algorithms outlined above can be extended in several ways computers now in common usage have special bit simd registers single instruction multiple data using these with the addition of several bookkeeping operations would essentially double the efficiency and the speed of computation another extension derives from the unexploited parallelism of the operations there are no dependencies on prior computations after the v vectors in zone a are computed this means that all the computations in zones b c and d for v and all the subsequent computations for h can be done simultaneously an ideal situation for the use of general_purpose graphical processing units gpgpu another possible extension expands the types of scoring_schemes allowed blosum type scoring which is useful for protein_alignments eliminates match and mismatch scoring and instead assigns different substitution weights to each pair of characters affine gap scoring replaces single character indel scoring with gap initiation and gap extension weights extension to local_alignment is also possible this is a different class of problem in that the best final alignment score can occur in any cell of the alignment matrix if all the cells have to be examined then the time complexity shifts back to o nm hyyr o and navarro had some success with this problem using unit cost weights and identifying columns in which the score of at least one cell exceeds a predefined threshold k the bitpal methods have already been used to accelerate software for detecting tandem_repeat variants in high_throughput sequencing_data and are well suited to other dna_sequence comparison tasks that involve computing many alignments funding this work was supported by the national_science iis to g b dge to j l and y h 
