genome_analysis eloper elongation of paired_end as a pre_processing tool for improved de_novo motivation paired_end resulting in gapped short_reads is commonly used for de_novo assembly methods use paired_end sequences in a two step process first treating each read end independently only later invoking the pairing to join the contiguous assemblies contigs into gapped scaffolds here we present eloper a pre_processing tool for pair end sequences that produces a better read library for assembly programs results eloper proceeds by simultaneously considering both ends of paired_reads generating elongated reads we show that eloper theoretically doubles read_lengths while halving the number of reads we provide evidence that pre_processing read libraries using eloper leads to considerably improved assemblies as predicted from the landerwaterman model availability http sourceforge net_projects eloper sequencing a genome involves the production of a large number of relatively short_sequences termed reads which collectively comprise the entire genomic_sequence several fold over reconstructing the genomic_sequence from a set of such reads constitutes the assembly problem a typical de_novo assembler iteratively merges overlapping reads until no additional overlap is detected to predict how a given library of reads will perform in the assembly process the lander waterman lw statistical_model is generally invoked paired_end refer to the sequencing of short bp portions of both ends of a dna_fragment paired_end was used extensively in sanger_sequencing of most large_genomes and is also common for genome_sequencing using high_throughput methods a paired_end amounts to more than two independent single_end as the two map to proximate regions in the genome where the proximity is defined by the known size of the library of fragments as useful as this information is however methods to assemble paired_end data generally disregard the pairing information in the first stage of assembly that generates contigs and invoke the pairing only later to build scaffolds here we present eloper a pre_processing tool for a library of reads to be invoked before their submission to any assembler eloper exploits the notion that the paired_end information essentially doubles the read_length permitting the detection of up to double the original overlap while maintaining the minimum required sequence overlap thus eloper detects gapped overlap where sub threshold overlaps occurring in both ends reach significant thresholds eloper then returns the elongated paired_end according to the gapped overlap detected with all other reads in the library the result is a new library of paired_end longer than the original reads the eloper processed library can be assembled using de_novo assemblers although arachne uses a similar approach as part of a full assembler eloper allows an elongation pre_processing followed by assembly using any assembler here we show both empirically and mathematically that eloper processing leads to better assemblies the lw model_predicts the expected length of a contig and the number of contigs as to whom correspondence should be addressed where n is number of reads l is the length of the reads c is the expected coverage ln g and g is the genome length finally is where is the fraction of the read required for an overlap t l in this formulation contigs and reads are treated synonymously the equal sign here represents almost sure convergence as arises from ergodic theorems the lw model bases expectation analyses on the probability of covering a base in the genome we show that using paired_end information provides the same expectation for covering a base as single_end of twice the length given two paired_end each of length l which both map to a previously uncovered region in the genome let us assume that the overlap between the pairs of ends is of length t and t where t t t the number of newly covered bases is then l t l t or l t this is equivalent to the number of newly covered bases by two single_end of length l and overlap t we further considered the probability for erroneous read merges the probability of observing an overlap of t t between a pair of paired_end is g f t t where f is the fragment_size assuming it is constant of the paired_reads and g is the genome_size this is roughly_equal to the probability of finding an overlap of length t at random between two single_end g t t thus using both ends of the paired_end sequences simultaneously to detect overlap effectively halves the number of reads in the library but doubles the length of each read in terms of the detection and error_rate substituting these parameters in the lw model we arrive at the following theoretical improvement to the number of contigs and to their expected length eloper pre_processing and its performance a schematic of the eloper method library of three paired_end is shown in the top reads are marked in gray and ends belonging to the same fragment are connected by a dashed_line overlap among reads is indicated in red eloper converts to after elongating using and the overlap between and is less than the threshold in either end of the read however taking both overlaps into account eloper is able to merge these reads b and c dashed and continuous lines represent the theoretically expected and empirically measured values respectively red and blue lines represent soapdenovo results starting from a pre processed library of bacteriophage reads and the unprocessed library respectively b the number of contigs and the average length of a contig are shown as a function of coverage discrepancies between theoretical and observed values occur because the assembly includes a scaffolding step the theoretical_model is skewed when the average contig length is greater than the genome length g c a comparison of the n and the fraction of ns in the scaffolds as a function of coverage the parameters for eloper and soapdenovo were t and k respectively per minute per thread with gb ram with a chosen k_mer of the runtime scales linearly with the size of the library such that the limit on the size of the library for pre_processing is restricted only by the computational_resources eloper thus provides a valuable pre_processing for improved de_novo assemblies of short paired_end libraries 
