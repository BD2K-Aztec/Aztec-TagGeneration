idba_tran a more robust de_novo de_bruijn assembler for transcriptomes with uneven expression levels motivation rna_sequencing based on next_generation is effective for analyzing transcriptomes like de_novo de_novo transcriptome_assembly does not rely on any reference_genome or additional annotation_information but is more difficult in particular isoforms can have very uneven expression levels e g which make it very difficult to identify low expressed isoforms one challenge is to remove erroneous vertices edges with high multiplicity produced by high expressed isoforms in the de_bruijn without removing correct ones with not so high multiplicity from low expressed isoforms failing to do so will result in the loss of low expressed isoforms or having complicated subgraphs with transcripts of different genes mixed together due to erroneous vertices edges contributions unlike existing_tools which remove erroneous ver tices edges with multiplicities lower than a global threshold we use a probabilistic progressive approach to iteratively remove them with local thresholds this enables us to decompose the graph into disconnected components each containing a few genes if not a single gene while retaining many correct vertices edges of low expressed iso forms combined with existing techniques idba_tran is able to assemble both high expressed and low expressed transcripts and outperform existing assemblers in terms of sensitivity_and for both simulated_and recent development of massively_parallel cdna sequencing rna_seq provides a more powerful and cost_effective way to analyze transcriptome_data rna_seq has been used successfully to identify novel genes refine and ends of genes study gene_functions locate exon_intron boundaries and estimate expression levels of isoforms however transcriptome reconstruction the reconstruction of all expressed transcripts from rna_seq remains a challenging unresolved problem when there is splicing i e when different combinations of regions exons of a single gene are decoded to multiple_transcripts isoforms currently there are two computational_approaches to solve this problem alignment_based such as cufflinks and scripture first align_reads to reference_genomes using splice_junction mappers such as tophat to identify exonintron boundary and then build a graph in which exons are the nodes and two exons are connected if reads connect them cufflinks attaches weights to edges and models the isoform reconstruction problem as a minimum path cover problem while scripture creates a statistical_model to identify significant segments as isoforms in contrast de_novo methods such as trinity oases trans abyss and t idba assemble transcripts directly from reads alignment based transcriptome_assembly methods which rely on reference_genomes and additional annotation_information may suffer from missing erroneous information also the quality of these methods depends heavily on the accuracy of the alignment tools which is also complicated by splicing and sequencing_errors as rna_seq technology becomes more mature there will be an increasing need to reconstruct unknown transcriptomes without reference_genome information and de_novo transcriptome_assembly will become increasingly more important difficulties at first glance the de_novo transcriptome_assembly problem looks similar to the de_novo problem in fact many existing_methods for de_novo transcriptome_assembly like genome_assembly apply the de_bruijn approach with fragments of transcripts being simple paths in graph in which a vertex is a k_mer and an edge exists between two vertices u and v if u and v appear consecutively in a read however two main aspects make the two assembly problems different exons shared by multiple_isoforms in this paper we focus on transcriptome_assembly for eukaryotes with splicing since without splicing the problem is much easier consider the example loc os g from rice in a to i represent different exons forming isoforms in red shared exons e g d and h look like repeats and most genome_assemblers try to resolve repeats at the branch level i e each branch needs to be supported by paired_end in our case since all five isoforms are real branches bd and cd as well as de and df will be supported some assemblers may stop at the junctions reporting b c d e and f as separate short contigs or falsely regard cde as a transcript provided both cd and de have enough support for example running velvet on the rice data to whom correspondence should be addressed the author published_by this is an open_access the terms of the creative_commons http creativecommons org_licenses which permits non commercial re use distribution and reproduction in any medium provided the original_work for commercial re use please_contact permissions_oup com see section for details results in contigs of mean length_bp only while the mean length of transcripts is about bp some metagenomic and single_cell assemblers try to find a path with maximum paired_end support however as the insert distance of transcriptome_data usually cannot cover more than one branch splicing junction and there are multiple correct paths isoforms with paired_end support these assembliers also fail to reconstruct the isoforms different expression levels of isoforms of the same gene isoforms of the same gene may have very different expression levels there are two problems first low expressed isoforms may have little support from reads and thus are missed by the assembler for example in if there are only a few paired_end supporting branch bd and fh isoform abdfh is unlikely to be obtained second support from reads of erroneous k_mers from high expressed transcripts may be higher than that of correct k_mers from low expressed transcripts these erroneous k_mers introduce branches in the de_bruijn and make the graph very complicated shows an example from a real rice transcriptome dataset loc os g this subgraph k is supposed to contain only two isoforms shows the conceptual view of the isoforms there are and erroneous k_mers and branches respectively in the de_bruijn when we simulated reads with sequencing_error details shown in section existing_approaches usually employ a global threshold to remove erroneous k_mers and branches if the multiplicities of these components are smaller than the threshold this simple approach will not work for transcriptome_data since the error positions of each read are known we can count the number of correct and erroneous k_mers for simulated_data on rice section for different multiplicities no matter how we set the threshold of multiplicity for removing erroneous k_mers draw a vertical_line and consider all k_mers on the left with lower multiplicities as erroneous k_mers some erroneous kmers will remain and correct k_mers will be removed these complicated components will make isoform finding extremely_difficult as there are many paths to be considered in the ideal case the de_bruijn should have many isolated components each representing isoforms from one gene unless there are repeats in different genes in most cases the structure of the component should be simple as most genes do not contain many isoforms to tackle this issue we need a method to separate components that are falsely connected by erroneous k_mers and we need to remove erroneous k_mers from each component existing solutions oases and trinity are two popular de_novo transcriptome assemblers for rna_seq in order to solve the splicing problem both apply a dynamic_programming to identify potential paths in the graph which are supported by many reads or paired_end in other words they try to identify isoforms more globally through a path level analysis instead of a local branch level analysis the results are much better than those of genome_assemblers however since the problem is np complete proved in the supplementary appendix the running time of the dynamic_programming increases exponentially with the number of branches in the de_bruijn due to issue erroneous reads sampled from high expressed transcripts introduce many branches with more support than reads sampled from low expressed transcripts and thus dynamic_programming takes a long time in practice these tools fall back on heuristic_search instead of dynamic_programming for large components to tackle issue t idba uses another approach to isolate components based on the observation that transcripts from different genes share less common vertices when k value is large t idba builds a de_bruijn from small k and iteratively updates the graph with larger k values it then finds transcripts in the de_bruijn with large k value where transcripts from the same gene usually form a single component however it does not perform very well for low expressed transcripts because there are more missing k_mers when k is large there is no dedicated solution in t idba that solves the issue of erroneous k_mers within a component and methods for isolating components are not sensitive to low expressed isoforms to recover low expressed transcripts several post_processing methods were developed for velvet and abyss they are all based on the observation that lower k values make the assembler more sensitive to low expressed transcripts while larger k values make it more specific to high expressed transcripts in order to combine the advantages of different values of k the resultant contigs generated by different k_mer lengths independently are merged together however merging assembly results from different runs is not a straightforward task although output transcripts are clustered and duplicated transcripts are removed many duplicates are difficult to detect and errors can accumulate in the cluster remove step as a result multiple contigs with errors are generated for the same transcripts and the number of resulting contigs is much more than the number of expressed transcripts oases m an extension of oases makes use of multiple k to improve its assembly result and is now the best tool using this approach however since the fundamental problem of removing erroneous vertices from high expressed isoforms while keeping correct vertices from low expressed isoforms is not solved there are still many false_positives as well as duplicated transcripts section some single_cell genome_assemblers also have a problem with uneven multiplicities of correct k_mers they resolve the problem based on the assumption that although the multiplicities of these erroneous k_mers are high their multiplicities should be lower than the nearby correct k_mers thus they calculate a local threshold based on example of de_bruijn for five isoforms from the same gene i idba_tran the multiplicities of nearby k_mers or contigs for removing erroneous k_mers however as a k_mer representing the common exon of several expressed isoforms can have relatively higher multiplicity than nearby correct k_mers calculating the local threshold from only one or two nearby kmers or contigs may be misleading and the algorithms may remove many correct k_mers near these high multiplicity k_mers our contributions if issue can be resolved issue can be tackled by existing path level analysis as the components will be simple enough thus our core contribution is handling issue as mentioned before the traditional filtering method of using one single global threshold for multiplicity cannot separate correct k_mers sampled from low expressed transcripts from erroneous k_mers sampled from high expressed transcripts and single_cell genome_assemblers calculating local thresholds from nearby k_mers may remove many correct k_mers thus we propose a probabilistic progressive approach to solve this problem our proposed assembler idba_tran calculates the probability that a k_mer or short simple path contigs contains error using not only the multiplicity of the k_mer or contig or their neighboring k_mers or contigs but also uses a multi normal distribution to model the multiplicities of all k_mers in the whole connected component based on the multi normal distribution and the contig length as a short simple path is more likely to have error than a long one idba_tran calculates a local threshold for determining whether a k_mer or contig has error by progressively removing erroneous k_mers connected components representing isoforms from a single gene are identified since we successfully remove many erroneous k_mers the size of each component is small we can employ a path level analysis similar to oases and trinity to identify transcripts from each component thus idba_tran can perform better than oases and trinity producing more contigs particularly for lowexpressed transcripts results show that idba_tran outperforms other de_novo transcriptome_assembly approaches in terms of both sensitivity_and for both simulated_and idba_tran also makes use of other techniques used in genome_assemblers such as tips pruning path merging and error_correction shows the workflow of idba_tran for assembling a set of paired_end in the first iteration when k k min h k is equivalent to a de_bruijn for vertices whose corresponding k_mers have multiplicity of at least m by default times in all reads during all subsequent iterations sequencing_errors are first removed according to the topological_structure of h k in a slightly different way to other assemblers section the tips dangling paths in h k of length shorter than k are likely to be false_positives similar paths bubbles representing very similar contigs with the same starting vertex and ending vertex are likely to be caused by errors or snps and they should be merged then the depth_information for contigs and components is used to decompose the graph into components section paths with high support for the paired_end are reconstructed as transcripts in each component section errors in the assembled_contigs are corrected by aligning_reads to the contigs section when constructing h ks from h k each length s path in h k is converted into a vertex k s mer and there is an edge between two vertices if the corresponding k s mer appears f by default times in reads or once in contigs in c k lc k t k where c k represents the set of contigs lc k is the set of contigs constructed by local_assembly using paired_end information section and t k is the set of transcripts when considering h k in the following subsections we describe each step of idba_tran in detail each branch in the graph idba_tran checks each outgoing and incoming edge keeps the branch which leads to the longest path and removes all other branches tips which lead to paths shorter than k usually the correct branch leads to longer paths than tips and this method preserves correct branches as transcriptome sequencing_data contains more errors and insertions_deletions than genome sequencing_data idba_tran identifies and merges paths with same starting_point and end_point and higher than similarity including insertions_and to evaluate the performance of idba_tran experiments were carried_out on both simulated_and we compared idba_tran with the latest transcriptome assemblers trinity and oases we also compared idba_tran with the single_cell genome assembler idba ud and velvet sc which apply multiple depths when assembling genomes idba_tran and idba ud were run with k ranging from to with step_size for oases and velvet sc k values ranging from to with step_size were used and the best result was selected as output as the k value of trinity was fixed to the default_parameters were used to run it for transcriptome_assembly the most important indicator of assembly_quality is the number of correct transcripts an assembler can reconstruct in the experiments known transcript references were used for benchmarking a known transcript is reconstructed successfully if a certain portion say referred as completeness of its sequence is covered by a contig with similarity similarly the contig is considered correct if it can be aligned to at least of a transcript with similarity the alignment of contigs to transcripts was performed by blat without considering long gaps representing introns as we aligned contigs to transcripts instead of genome the sensitivity_and were calculated to measure performance sensitivity is the percentage of reconstructed transcripts over all expressed transcripts specificity is the percentage of correct contigs over all reported contigs we also compared the performance of idba_tran and cem on estimating expression levels of reconstructed transcripts cem requires the genome_sequence as additional information by aligning_reads to the reference_genome cem can predict the expressed transcript sequences and estimate the expression_level of each transcript based on a statistical_model quasi multinomial model since some transcripts may align to multiple contigs and some contigs may align to multiple_transcripts we considered only those transcripts and contigs with one to one correspondence the pearsons_correlation between the predicted expression levels and the exact expression levels was calculated as suggested in we also calculated the pearsons_correlation between the logarithm of predicted expression levels and the logarithm of exact expression levels we have identified one key issue in transcriptome_assembly namely how to remove erroneous vertices edges of high multiplicity due to high expressed isoforms from the de_bruijn while keeping correct ones with relatively lower multiplicity due to low expressed isoforms we developed a probabilistic progressive approach with local thresholds to solve the problem we proposed idba_tran combined with other techniques to assemble transcriptome sequencing_data experiments on both simulated_and confirm that idba_tran can outperform existing de_novo transcriptome assemblers in terms of both sensitivity_and in particular for low expressed transcripts the improvement of idba_tran is substantial recall that there is another approach to recover both low expressed and high expressed transcripts namely run the assembler for different k values and merge all contigs as output oasesm which runs oases several times with multiple k values is a post_processing tool based on this approach oases m can reconstruct many transcripts for both simulated_and however since erroneous contigs cannot be merged oases m produces many incorrect contigs and has a low_specificity see supplementary moreover contigs representing some transcripts may appear multiple times with small difference in the output such that the number of correct contigs is double the number of reconstructed transcripts the large number of erroneous contigs and redundant contigs may make analysis difficult and it is very hard to distinguish the erroneous contigs from the correct ones on the other hand we found that oases m had slightly better performance than idba_tran for high expressed transcripts for real_data see supplementary thus it may be a good idea to investigate how to integrate both approaches to reconstruct more transcripts 
