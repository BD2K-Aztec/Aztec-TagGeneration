fastsp linear time calculation of alignment_accuracy motivation multiple_sequence is a basic part of much biological_research including phylogeny estimation and protein_structure and function prediction different alignments on the same set of unaligned sequences are often compared sometimes in order to assess the accuracy of alignment_methods or to infer a consensus alignment from a set of estimated alignments three of the standard techniques for comparing alignments developer modeler and total column tc scores can be derived through calculations of the set of homologies that the alignments share however the brute_force technique for calculating this set is quadratic in the input size the remaining standard_technique cline shift score inherently requires quadratic time results in this article we prove that each of these scores can be computed in linear time and we present fastsp a linear time algorithm for calculating these scores even on the largest alignments we explored one with sequences fastsp completed min and used at most gb of the main_memory the best alternative is qscore a method whose empirical running time is approximately the same as fastsp when given sufficient memory at least gb but whose asymptotic running time has never been theoretically established in addition for comparisons of large_alignments under lower memory conditions at most gb of main_memory qscore uses substantial memory up to gb for the datasets we studied took more time and failed to analyze the largest datasets availability the open_source and executables are available online atestimation of multiple_sequence for molecular datasets is fundamental to many problems in biology including the prediction of protein_function and structure and phylogeny estimation estimated alignments are often compared with other alignments in order to assess accuracy or to determine the features shared by two or more alignments in addition since different alignment_methods can produce alignments that differ enough to introduce phylogenetic uncertainty and alignment error increases with the size of the dataset the use of several alignments and comparisons of these alignments is advisable for large_scale phylogenetic_studies to whom correspondence should be addressed of the various methods for comparing an estimated alignment to a reference alignment four are generally in use the developer score also called the sp score for sum of pairs modeler score total column score and cline shift score the sp score and modeler scores are quite similar the sp score is the percentage of the homologies in the reference alignment that appears in the estimated alignment and the modeler score is the percentage of the homologies in the estimated alignment that appears in the reference alignment thus each can be obtained by computing the number of shared homologies and then normalizing by either the number of homologies in the reference or true alignment the total column score is the number of alignment columns shared by both alignments and can also be normalized by the number of columns in one of the alignments finally the cline shift score is computed by averaging the cline shift scores for each of the induced pairwise_alignments each of these normalized scores ranges from to with indicating that the two alignments are maximally dissimilar for the criterion and indicating that the two alignments are considered identical with respect to the criterion thus these scores represent accuracy_measures and complementing these scores subtracting them from produces the corresponding error metrics while several methods have been developed for comparing alignments only qscore and lobster available online at http www drive com qscore and http www drive com lobster respectively correctly compute the sp score however the computational_complexity of these methodsi e their asymptotic running timehas never been established clearly all four scores can be computed in quadratic time using bruteforce techniques and the cline shift score by definition requires quadratic time however the sp score modeler score and total column scores might not require quadratic time in this article we show that the sp score modeler score and total column scores can each be computed in linear timetime where n is the number of sequences and k is the length of the longer alignment we present a method fastsp to compute the number of shared homologies between two alignments and prove that it runs in linear time the result then follows since each of the three scores can be obtained directly from this number since error scores are complements of these accuracy scores fastsp can be used to compute error_rates such as sp fn the percentage of true homologies missing in the estimated alignment and sp fp the percentage of predicted homologies that are not present in the true alignment furthermore fastsp can be used to evaluate the reliability of a given alignment with respect to a set of alignments since it enables fast all pairs comparisons thus fastsp is a basic tool for analyzing sets of multiple_sequence the main observations we can make are these when run on machines with sufficient memory at least gb for these datasets we studied fastsp and qscore have very close running_times but qscore has higher peak memory_usage thus even though the two methods are not distinguishable by running time in this case they differ substantially in terms of memory_usage on the other hand when memory is limited to gb the two methods have substantially different running_times for large_alignments thus in general the two methods cannot be distinguished on alignments with small numbers of taxa but are distinguished on large_alignments either with respect to running time if memory is limited to gb or with respect to memory_usage when memory is not limited although the methods have different running_times it is evident that the differences in running time are a result of differences in their memory_usage but why do we see these differences recall that fastsp has memory_usage that grows only linearly with the reference alignment size and does not need to keep the estimated alignment in memory this can reduce the memory_usage substantially the most likely explanation is a simple one qscore uses more memory simply because it was not implemented with memory_usage optimization as one of its objectives 
