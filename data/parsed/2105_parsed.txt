sequence_analysis gpu blast using graphics processors to accelerate protein sequence_alignment motivation the basic_local blast is one of the most widely used bioinformatics_tools the widespread impact of blast is reflected in over citations that this software has received in the past_two and the use of the word blast as a verb referring to biological sequence comparison any improvement in the execution speed of blast would be of great_importance in the practice of bioinformatics and facilitate coping with ever increasing sizes of biomolecular databases results using a general_purpose graphics_processing gpu we have developed gpu blast an accelerated version of the popular ncbi_blast the implementation is based on the source_code of ncbi_blast thus maintaining the same input and output interface while producing identical results in comparison to the sequential ncbi_blast the speedups achieved by gpu blast range mostly between and availability the source_code of gpu blast is freely_available atblast was introduced as a sequence_alignment heuristic that was an order of magnitude faster than earlier approaches for analyzing biological_information very quickly this software became a landmark enabling technique for bioinformatics according to the web_of the paper that describes the first version of ungapped blast has been cited more than times in addition the paper that describes the gapped version of the algorithm and a technique to speed up the earlier version by a factor of three has been cited more than times the level of usage of blast suggests that any improvement in its execution speed will result in significant impact in bioinformatics research_efforts in this direction have been substantial and have relied mainly on custom_designed hardware and parallel supercomputing even though these efforts have resulted in impressive speedups of up to three orders_of neither custom hardware nor supercomputers are easily_accessible by the majority of blast users to whom correspondence should be addressed with the advent of multicore processors there have been several efforts to parallelize blast and speedup its execution on commodity hardware the national_center ncbi has developed a version of blast that exploits multicore processors for the first phase of the algorithm another parallel version of blast exploits two features of modern microprocessors sse instructions and multithreadingand achieves speedups of up to times compared with ncbi_blast however the resulting protein_alignments are up to different than those produced by ncbi_blast in recently graphics_processing gpus became available as a general_purpose processing platforms we were drawn to gpus because of their exceptionally_high performance to cost_ratio for around it is possible to combine a personal computer with a gpu and achieve trillions of peak floating point operations per second flops performance gpu technology brings supercomputing power to the desktop thus facilitating the widespread use of parallel algorithms by bioinformaticians however algorithms that perform well on a cpu may not perform as well on a gpu c f algorithm developers must develop new algorithms in order to harvest the gpus massive parallel nature gpus were designed to accelerate graphics processing and quickly outperformed cpus by over an order of a magnitude in terms of flops and memory bandwidth performance this potential was initially difficult to harness in applications beyond graphics the situation changed in with the introduction of nvidias compute_unified cuda a software and hardware environment that facilitates the adoption of gpus in general_purpose computing since then the use of gpus has proved advantageous in a number of computationally_intensive bioinformatics problems including the smithwaterman alignment algorithm molecular_docking the protein_folding problem dna_sequencing computational proteomics statistical phylogenetics biological_systems simulation and cellular_level simulation several gpu based bioinformatics software can be found at http the database used for computations was the latest releases of the env nr ftp ftp ncbi nlm nih gov blast db protein database which contains sequences and its size is gb the queries were mouse sequences with lengths from to these sequences were obtained from the uniprot database http www uniprot org and are provided in the queries directory of the gpu blast distribution depicts the speedups achieved by the ungapped and gapped versions of gpu blast in comparison to one threaded and six threaded ncbi_blast for the env nr database these speedups depend on the query length the speedups increase for query lengths page and average speedups as a function of cpu threads working in parallel with gpu blast b speedups were calculated based on start to finish wall clock times of approximately up to amino_acids for the one threaded and for the six threaded implementations after which the speedup remains essentially constant for shorter queries the speedup is slightly_lower because the seed identification and the extension steps consume a smaller percentage of the total execution time as seen in the scattering of the speedups incan be attributed to several factors including the number of seeds identified the extension length around each seed and the number of ungapped and or gapped extensions which affect the thread divergence on the gpu and consequently its performance the gpus theoretical peak performance is gflops in single precision and gflops in double precision the corresponding numbers for the cpu are gflops and gflops although the gpus peak performance in gflops is about eight times_higher than the cpus the speedups achieved by gpu blast are currently around four the reason for this difference is that the simt architecture of the gpu executes concurrently multiple threads that operate on different data and follow the same execution path in each warp whenever the execution paths within a warp diverge the threads are serialized and overall performance is reduced the one threaded gpu blast is faster for ungapped than gapped alignments because it is possible to transfer of the computations to the gpu in the ungapped case compared with only in the gapped case as shown in for the six threaded gpu blast the total speedup is smaller and the difference between the ungapped and gapped version diminished because the cpu can handle a bigger workload leaving a smaller margin to the gpu to speedup the total running time for the one threaded gpu blast the speedup is always bigger than one except for the first sequence which has length two the six threaded gpu blast offers speedup for sequences longer than amino_acids in we present average gpu blast speedups when using up to six cpu threads in parallel with the gpu the times used to calculate each speedup are elapsed times to carry out a sequence_alignment which start from the beginning of gpublasts execution and finish with the writing of the output alignments to a file we can see that gpu blast achieves the largest speedups compared with single threaded ncbi_blast and the speedups decrease as the number of cpu threads increase finally in we present speedups relative to a single threaded cpu both multi_threaded cpu and cpu gpu combinations are considered as a function of the number of available cpu threads in all cases speedups were calculated based on the total time to align the entire set of queries as this figure shows the multithreaded ncbi_blast itself does not scale linearly for instance with six cpu threads the ncbi_blast speedup is less than four gpu blast inherits some of these limitations as it is built on top of ncbi_blast in order to guarantee the same output results nonetheless in all cases the addition of the gpu considerably increases the observed speedups for instance the sixthreaded gpu blast achieves a speedup of nearly six for both gapped and ungapped alignments 
