shifted hamming_distance a fast and accurate simd friendly filter to accelerate alignment verification in read_mapping motivation calculating the edit_distance i e minimum number of insertions deletions and substitutions between short dna_sequences is the primary task performed by seed and extend based mappers which compare billions of sequences in practice only sequence pairs with a small edit_distance provide useful scientific data however the majority of sequence pairs analyzed by seed and extend based mappers differ by significantly more errors than what is typically allowed such error abundant sequence pairs needlessly waste resources and severely hinder the performance of read_mappers therefore it is crucial to develop a fast and accurate filter that can rapidly and efficiently detect error abundant string pairs and remove them from consideration before more computationally_expensive methods are used results we present a simple and efficient algorithm shifted hamming_distance shd which accelerates the alignment verification procedure in read_mapping by quickly filtering out error abundant sequence pairs using bit parallel and simd parallel operations shd only filters string pairs that contain more errors than a user_defined threshold making it fully comprehensive it also maintains high_accuracy with moderate error threshold up to of the string length while achieving a fold speedup over the best previous algorithm gene myerss bit vector algorithm shd is compatible with all mappers that perform sequence_alignment for verification availability_and we provide an implementation of shd in c with intel sse instructions at https github com cmu safari shd the emergence of massively_parallel commonly called high_throughput during the past_decade triggered a revolution in the field of genomics these platforms enable scientists to sequence mammalian sized genomes in a matter of days which has created new opportunities for biological_research for example it is now possible to investigate human_genome diversity between populations genomes_project find genomic_variants likely to cause disease and ancient hominids to better understand human evolution however these new sequencing_platforms drastically increase the computational_burden of genome data analysis in the first step of data analysis billions of short dna_segments called reads are aligned to a long reference_genome each read is mapped to one or more sites in the reference based on similarity with a process called read_mapping read_mappers typically fall into one of two main categories suffix_array and backtracking based langmead and salzberg li and durbin or seed and extend based suffix_array based mappers use the burrows_wheeler transformation and are efficient at finding the best mappings of a read mappers in this category use aggressive algorithms to build their candidate pools which may miss potentially correct mappings although mappers in this category can also be configured to achieve_higher sensitivity by systematically inspecting all possible error scenarios of a read such configuration increases their execution times superlinearly langmead and salzberg li and durbin alternatively seed and extend based mappers build comprehensive but overly large candidate pools and rely on filters and local alignment_techniques to remove incorrect mappings i e potential mappings with more errors than allowed from consideration in the verification step mappers in this category are comprehensive find all correct mappings of a read and accurate do not provide incorrect mappings but waste computational_resources identifying and rejecting incorrect mappings as a result they are slower than suffix_array based mappers fast and accurate filters which detect and reject incorrect mappings using cheap heuristics can increase the speed of seedand extend mappers by speeding up the verification procedure while maintaining their high_accuracy and comprehensiveness an ideal filter should be able to quickly verify the correctness of a mapping yet require much less computation than rigorous local_alignment which precisely calculates the number of errors between the read and reference using dynamic_programming methods more importantly a filter should never falsely remove a correct mapping from consideration as this would reduce the comprehensiveness of the mapper recent work has shown the potential of using single instruction multiple data simd vector execution units including general_purpose gpus and intel sse intel to accelerate local alignment_techniques however these publications only apply simd units to existing scalar algorithms which do not exploit the massive bitparallelism provided by simd platforms in this article we present shifted hamming_distance shd a fast and accurate simd friendly bit vector filter to accelerate the local_alignment verification procedure in read_mapping the key idea of shd is to avoid wasting computational_resources on incorrect mappings by verifying them with a cheap simd friendly filter before invoking canonical complex local alignment_methods our studies show that shd quickly identifies the majority of the incorrect mappings especially ones that contain far more errors than allowed while permitting only a small fraction of incorrect mappings to pass shd which are later filtered out by more sophisticated and accurate filters or by local alignment_techniques this article makes the following contributions bullet we show that for seed and extend based mappers most potential mappings contain far more errors than what is typically allowed section bullet we introduce a fast and accurate simd friendly bit vector filter shd which approximately verifies a potential mapping with a small set of simd friendly operations section bullet we prove that shd never removes correct mappings from consideration hence shd never reduces the accuracy or the comprehensiveness of a mapper section bullet we provide an implementation of shd with intel sse section and compare it against three previously_proposed filtering and local_alignment implementations section including an sse implementation of the smithwaterman_algorithm swps an implementation of gene myerss bit vector algorithm seqan d ring et_al and an implementation of our adjacency filtering algorithm fasthash our results on a wide_variety of real read sets show that shd sse is both fast and accurate shd sse provides up to speedup against the best previous state of the art edit_distance implementation d ring et_al with a maximum false_positive of the rate of incorrect mappings passing shd read_mappers identify locations within a reference_genome where the read and the reference match within a user_defined error i e insertions deletions or substitutions threshold e in practice e is usually of the read_length but most aligners can be configured to return only the best mapping the mapping with the fewest errors as seen in in supplementary_materials most potential location mappings tested by seed and extend based mappers are incorrect having more errors than allowed in fact when e of the read_length more than of mappings are incorrect since alignment is the primary computationally_intensive task performed by seed and extend based read_mappers it is crucial that incorrect mappings be rejected efficiently many mechanisms have been proposed to efficiently calculate the edit_distance of strings and filter out incorrect mappings these mechanisms can be divided_into five main classes i dynamic_programming dp algorithms ii simd implementations of dp algorithms iii bit vector implementations of dp algorithms iv hamming_distance calculation and v locality based filtering mechanisms notice that although mechanisms in both ii and iii are different implementations of i we separate them into two categories because they use different optimization strategies while mechanisms in ii faithfully implement the dp algorithm in a simd fashion mechanisms in iii use a modified bit parallel algorithm to calculate a bit representation of the dp matrix full descriptions of each strategy are provided in supplementary_materials section s in this article we choose three representative implementations from ii iii and v swps seqan and fasthash for detailed analysis see supplementary_materials s these mechanisms were not designed as simd bit parallel filters and are either fast or accurate can filter out most incorrect mappings but not both conversely we designed shd to leverage bit parallelism and simd instructions to achieve high performance while preserving high_accuracy we implemented shd in c using intel sse we compared shd against three edit_distance calculation filtering implementations they are seqan an implementation of gene myerss bit vector algorithm swps a smith_waterman algorithm smith and implementation and fasthash an adjacency filtering af implementation both seqan and swps are also implemented with sse and all implementations were configured to be single threaded we used a popular seed and extend mapper mrfast to retrieve all potential mappings read reference pairs from real_datasets from the genome_project phase i genomes_project consortium lists the read_length and read size of each set each read set is processed using multiple error thresholds i e e from to errors we benchmarked all four implementations using the same potential mappings i e seed hits produced by mrfast for a fair comparison of the four techniques shows the execution time of the four techniques with different error thresholds across multiple read sets notice that when the indel threshold is zero shd reduces to bit parallel hamming_distance a detailed comparison against bit parallel hamming_distance implementation is provided in supplementary_materials section s among the four implementations shd is on average faster than seqan and faster than swps although shd is slightly slower than fasthash af when e is greater than two e g slower when e shd produces far fewer on average false_positives than fasthash seen in note the speedup gained by shd diminishes with greater e this is expected since the number of bit parallel simd operations of shd increases for larger e illustrates the false_positive of shd and fasthash af seqan and swps both have a false_positive compared with shd which has a false_positive on average that being the case shd is only a heuristic to filter potential mappings while both seqan and swps must compute the exact edit distances of the potential mappings as we discussed in section the false_positive of shd increases with larger e nonetheless the false_positive of shd at e is only much smaller than the false_positive of fasthash af asshows with these results a mapper can selectively combine multiple implementations together to construct an efficient multi_layer filter edit_distance calculator for instance a mapper can attach shd with fasthash to obtain both the fast speed of fasthash and the high_accuracy of shd a mapper can also combine shd with seqan to obtain accuracy without significantly sacrificing the speed of shd of course there are many possibilities to integrate shd into a other mappers but a comprehensive study of this topic is beyond the scope of this article and is part of our future work most potential mappings that must be verified by seed and extendbased mappers are incorrect containing far more errors than what is typically allowed our proposed filtering algorithm shd can quickly identify most incorrect mappings through our experiment shd can filter billion potential mappings within min on a single thread while obtaining a false_positive of at maximum while preserving all correct ones comparison against three other state of the art edit_distance calculation filtering implementations revealed that our intel sse implementation of shd is faster than seqan the previous best edit_distance calculation technique 
