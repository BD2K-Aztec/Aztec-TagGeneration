epga de_novo using the distributions of reads and insert_size motivation in genome_assembly the primary issue is how to determine upstream and downstream sequence_regions of sequence seeds for constructing long contigs or scaffolds when extending one sequence seed repetitive_regions in the genome always cause multiple feasible extension candidates which increase the difficulty of genome_assembly the universally_accepted solution is choosing one based on read overlaps and paired_end mate_pair reads however this solution faces difficulties with regard to some complex repetitive_regions in addition sequencing_errors may produce false repetitive_regions and uneven sequencing_depth leads some sequence_regions to have too few or too many reads all the aforementioned problems prohibit existing as semblers from getting satisfactory assembly results results in this article we develop an algorithm called extract paths for genome_assembly epga which extracts paths from de_bruijn for genome_assembly epga uses a new score function to evaluate extension candidates based on the distributions of reads and insert_size the distribution of reads can solve problems caused by sequencing_errors and short repetitive_regions through assessing the variation of the distribution of insert_size epga can solve problems introduced by some complex repetitive_regions for solving uneven sequencing_depth epga uses relative mapping to evaluate extension candidates on real_datasets we compare the performance of epga and other popular assemblers the experimental_results demonstrate that epga can effectively obtain longer and more accurate contigs and scaffolds knowledge of genome_sequences has become indispensable in numerous applied fields such as diagnostics biotechnology forensic biology and systems_biology the next_generation ngs_technologies also known as high_throughput including illumina life_sciences and solid can provide short sequence_fragments named reads much more quickly and cheaply than previously used sanger_sequencing but at the sacrifice of read_length a number of genome_assemblers have been proposed using a great_deal of short_reads produced by ngstechnologies for reconstructing complete_genome the primary issue of these assemblers is how to determine upstream and downstream sequence_regions of sequence seeds for constructing contigs or scaffolds as the length of reads decreases the number of repetitive_regions in one genome will dramatically_increase when extending one seed_sequence repetitive_regions can cause multiple feasible candidate_regions which increase the difficulty of genome_assembly so the repetitive_regions especially longer than the read_length in one genome become one of the most challenges in genome_assembly the earlier assemblers generally employ read overlaps to extend one sequence seed when there are multiple feasible extension candidates caused by repetitive_regions the assemblers usually select one with the maximum overlap or the highest consensus to extend the length of read overlap is important to identify extension candidates and choose the correct one among them because sequencing_errors often result in erroneous read overlaps and low depth regions miss some read overlaps so read overlaps usually compromise between continuity and error_rate de_bruijn is a useful data_structure which can store read overlaps there are some improved de_bruijn used for assembly however the information about read overlaps has no effect on repetitive_regions longer than the read_length most recent assemblers make use of paired_end mate_pair reads which can be produced by ngs_technologies for resolving repetitive region problems one paired_end is referred to a pair of short_reads sequenced from two ends of one long sequence fragment and the sequence fragment length the distance between paired_end is usually called insert_size which is a random variable with mean l is and sd d is the insert_size is frequently assumed to have a normal distribution n l is d is for every paired_end its two reads are called the mates of each other in recent_years there have been numerous assemblers presented for biologists velvet uses paired_end to mark nodes and finds a correct path through marked nodes to connect two long nodes based on de_bruijn however some nodes shorter than the read_length cannot be marked so it tends to contain more errors at short repetitive_regions abyss adopts a method similar to velvets when extending one sequence seed or filling one gap region pe assembly tries to identify feasible extensions from local read sets produced from paired_end idba and idba ud iterately change k_mer k consecutive bases in one read_length and uses paired_end to eliminate branches in de_bruijn telescoper first constructs read overlap graph_based on reads whose mate reads can map to sequence seeds and it develops a statistical_framework using penalty function to choose paths for constructing contigs soapdenovo and soapdenovo directly use nodes in de_bruijn as contigs which are usually short allpaths_lg has specific requirements in read_length and insert_size which differ from common read libraries in the following part let r denote the read_length and s denote a sequence sis the i th base in s sis the sub region of s from i to j th base l s is the length of s and r s is the set of reads in s re s is the set of reads in r s which exist in the read library rml s is the set of reads in re s which have left mate reads and mrl s is one set which includes the corresponding left mate reads rmlm s i s j is the set of reads in rml s j whose one left mate read can be mapped to s i and the distance between the mapped pairedend reads must be in the interval l is d is l is d is dls i s j is the set including the corresponding distances rmr s mrr s rmrm s i s j and dr s i s j all can be obtained from right mate reads of the sequences jtj is cardinality of one set t the information contained in paired_end can facilitate genome_assembly because paired_end can span repetitive_regions shorter than insert_size for one sequence seed s s and one downstream extension candidate s we can estimate the correctness of s through its mrl s when the reads in mrl s can be mapped to s s we consider s as the correct one as illustrated in although paired_end are widely_applied to resolve problems caused by repetitive_regions in genome_assembly the performance of most assemblers is not satisfactory there are three major problems which prevent most assemblers from identifying correct extension candidates by using paired_end adjacent repetitive_regions and paired repetitive_regions for two same regions b if the separation distance between the two regions in genome is small we say that it is adjacent repetitive region shown in for two regions a c if the length between a and c is closed to insert_size and the two regions appear in genome repeatedly we say that it is paired repetitive region shown in the upstream or downstream regions of adjacent and paired repetitive_regions are difficult to determine because the most reads in mrl or mrr of extension candidates can be mapped to the sequence seed sequencing_errors sequencing_errors always bring about incorrect reads which probably lead to false repetitive_regions and false extension candidates uneven sequencing_depths sequencing_depth of one sequence region depends on the average number of reads in the read library which can be mapped to the region because sequencing_depths of different regions in a genome are universally highly uneven there are no or fewer reads which can be mapped to low depth regions but high depth regions have too many mapped_reads uneven sequencing_depths aggravate the problems caused by and in for the sequence seed ab which is merged by a and b and the extension candidate c the distances in dl ab c should follow the distribution nl is d is d is the correct extension candidate of abcb and the difference between the length of ab and the length of abcb is lc lb when d is regarded as the extension candidate of ab the distances in dl ab d will follow nl is lb lc d is in the distances in dl abc d will follow nl is d is because h is the correct extension paired_end using in extending sequence seed the graph g is constructed based on sequence s abc dbe when extending downstream region of ab it has two extension candidates c and e if no sequencing_errors reads in mrl c can be mapped to ab but reads in mrl e can not be mapped to ab so c is the correct extension candidate candidate of aec and the difference between the length of abc and the length of aec is le lb the distances in dl abc h will follow nl is le lb d is it is clear that we can identify which extension candidate is correct by assessing whether the distances in dl follow nl is d is to our knowledge pe assembly is the only tool which considers the variation of the distribution of insert_size in filling gap step for one fixed_length sequence s r s includes l s r reads due to sequencing_depth some reads in r s probably do not appear in the read library jresj is usually smaller than jrsj every read is sequenced randomly jrej is a random variable whose distribution is called the distribution of reads jresj is a particular value of the random variable which should be within a reasonable range the probability p is one read can be sequenced if p is the same for every read in genome reference the distribution of reads approximately follows binomial_distribution the reasonable range can be determined by binomial_distribution if jresj goes beyond this range we consider s including false bases if sequencing_depth is even and sequencing_coverage is large enough without sequencing_errors genome_sequence is corresponding to one path contained in de_bruijn however due to the uneven sequencing_depth and sequencing_errors the path is inevitably segmented into many noncontiguous sub paths so the target of de_novo becomes to analyze de_bruijn for seeking out accurate sub paths corresponding to sub regions of genome we develop a novel assembler called epga extract paths for genome_assembly to improve genome_assembly see the flowchart of epga in supplementary epga selects some nodes in de_bruijn as sequence seeds the precursor nodes and successor nodes of sequence seeds are treated as its upstream and downstream extension candidates epga processes each extension candidate to form an evaluating region which is evaluated based on a new score function using the new score function epga iteratively extends sequence seeds on both sides to extract long paths which are contigs for one sequence seed s s its downstream extension candidate s and evaluating region s e epga uses the following three new strategies which make novel use of paired_end to resolve problem epga adopts the coefficient of determination cd to evaluate whether the distances in dls s s e follow nl is d is the cd provides a measure of how well the distances are replicated by nl is d is as the proportion of total_variation of the distances is explained by nl is d is to resolve problem based on the distribution of reads epga determines a reasonable range of jres e j to identify whether s is a false extension candidate the probability that jres e j is within the range should be large enough to resolve problem epga designs a new index named relative mapping rm to evaluate extension candidates the relative mapping is the ratio of rmlms s s e to rmls e so relative mapping can guarantee that correct extension candidates are given high score no matter sequencing_depth is in epga we mainly incorporate two new ideas for genome_assembly i we consider the distribution of reads to identify whether one extension candidate includes sequencing_errors rather than only using k_mer frequency ii based on the distribution of insert_size we develop a new score function to overcome complex repetitive_regions the performance of epga and other popular assemblers are compared on real_datasets the results demonstrate that epga can get more continuous and correct genome_sequences epga extends sequence seeds by iteratively evaluating extension candidates and choosing correct one between them to construct contig set because there exists sequencing_errors and uneven sequencing_depth in read libraries we present new ideas to avoid problems produced by them for adjacent repetitive_regions and paired repetitive_regions we use cd to distinguish correct extension candidates from false ones the performance of epga is validated on real_datasets from two bacteria and two fungi using the illumina_platform in our experiments we included some popular algorithms with available implementation we considered several standard metrics for comparing assemblies for all four datasets epga produced more satisfactory_results than the other assemblers considered epga has been demonstrated that it is possible to obtain complete and highly_accurate de_novo genome_assemblies as one direction of future work we would study how to reduce peak memory and running time for better performance funding this work was supported in part by the national natural_science of chinaand the program for new century excellent talents in university conflict of interest none declared 
