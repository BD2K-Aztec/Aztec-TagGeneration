integration of string and de_bruijn for genome_assembly motivation string and de_bruijn are two graph models used by most genome_assemblers at present none of the existing assemblers clearly outperforms the others across all datasets we found that although a string_graph can make use of entire reads for resolving repeats de_bruijn can naturally assemble through regions that are error_prone due to sequencing bias results we developed a novel assembler called stride that has advantages of both string and de_bruijn first the reads are decomposed adaptively only in error_prone regions second each paired_end is extended into a long_read directly using an fm_index the decomposed and extended reads are used to build an assembly_graph in addition several essential components of an assembler were designed or improved the resulting assembler was fully parallelized tested and compared with state of the art assemblers using benchmark_datasets the results indicate that contiguity of stride is comparable with top assemblers on both short_read and long_read datasets and the assembly accuracy is high in comparison with the others availability_and https github com ythuang stridealthough next and third_generation have been widely used to sequence and assemble genomes of many species in the biosphere many assembled_genomes are still fragmented due to complex repetitive structure a fragmented assembled genome often introduces extra complexity into downstream processing e g estimation of gene family_size and comparative_analysis recently several evaluation projects e g gage gage b and assemblathon have been conducted to assess the accuracy contiguity and speed of state of the art assemblers none of the existing assemblers clearly outperforms all the others across all benchmarks the overlap_layout olc and de_bruijn are two models used by most assemblers these two models represent the overlapping relation between reads in different ways the olcbased assemblers including mira newbler and celera assemblers first identify all pairs of overlapping reads and construct a graph with vertices representing reads and with edges denoting two overlapping reads next the genome_sequence is assembled by figuring out a feasible layout of reads from the graph the olc based_methods make good use of the entire read_length for resolving repeats and chimeras this approach is beneficial for sequencing_platforms generating long_reads e g sanger_sequencing roche and pacific_biosciences these assemblers however are computationally inefficient at assembling a massive amount of short_reads because of the time consuming overlap computation nowadays de_bruijn assemblers including velvet soapdenovo abyss and allpaths are the preferred choice for most sequencing_projects these assemblers break each read into fixed size k_mers which do not require the overlap computation and a graph is directly constructed where each vertex is a k_mer and each edge indicates two adjacent k_mers overlapping by k letters the construction of a de_bruijn is much more efficient nonetheless the graph_structure is more complex owing to repeats larger than k_mer recently a paired de_bruijn assembler spades overcame this limitation by building a graph by means of paired k_mers from paired_end aside from these two graph models there is a variant called string_graph that is similar to the olc graph without transitive edges the construction of a string_graph from reads can be computed in linear time using an fm_index the first such assembler called the string_graph assembler sga is capable of assembling mammalian size genomes but its contiguity is not better than that of de_bruijn assemblers according to several benchmark tests the string_graph shares many properties with the olc and de_bruijn but their equivalence in terms of real sequencing_data remains a subject of debate we found that the major difference lies in the ability to assemble through regions that are error_prone due to sequencing bias e g high gc regions see supplementary this article_presents a novel assembler called stride which adaptively decomposes reads within error_prone regions and extends paired_end into long_reads using an fm_index in addition an improved error_correction algorithm overlap computation specialized layout algorithms and full parallelization were implemented to make the assembler more practical the new assembler stride was tested using gage b benchmark_datasets gage b provides datasets of genome_sequencing of different bacteria using illumina_hiseq and miseq platforms stride was compared with seven other wellknown assemblers abyss v cabog masurca v soapdenovo v sga v spades v and velvet v the quality asessment tool quast was used to compute and compare various assembly metrics e g n and misassembly the parameters k k_mer size and t min k_mer frequency used by stride are fixed to and across all gage b experiments respectively this article_presents a novel assembler stride with advantages from string and de_bruijn many essential components of an assembler were developed or improved an initial test over various illumina short long_read datasets showed that stride can assemble through error_prone and repetitive_regions using decomposed and extended reads respectively the entire implementation is largely inherited from two open_source projects lis ropebwt and simpsons sga the proposed assembler is still lacking a scaffolding module although third_party scaffolding programs can be incorporated the number of misassemblies by each assembler on short_read hiseq or long_read miseq datasets 
