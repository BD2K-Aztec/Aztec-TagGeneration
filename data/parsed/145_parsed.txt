a fast lock free approach for efficient parallel counting of occurrences of k_mers motivation counting the number of occurrences of every k_mer substring of length k in a long string is a central subproblem in many applications including genome_assembly error_correction of sequencing_reads fast multiple_sequence and repeat detection recently the deep sequence_coverage generated by next_generation has caused the amount of sequence to be processed during a genome_project to grow rapidly and has rendered current k_mer tools too slow and memory intensive at the same time large multicore computers have become commonplace in research facilities allowing for a new parallel computational paradigm results we propose a new k_mer algorithm and associated implementation called jellyfish which is fast and memory_efficient it is based on a multithreaded lock free hash_table optimized for counting k_mers up to bases in length due to their flexibility suffix_arrays have been the data_structure of choice for solving many string problems for the task of k_mer important in many biological_applications jellyfish offers a much faster and more memory_efficient solution given a string s we are often interested in counting the number of occurrences in s of every substring of length k these lengthk substrings are called k_mers and the problem of determining the number of their occurrences is called k_mer counting the k_mers in a dna_sequence is an important step in many applications for example genome_assemblers using the overlap_layout paradigm such as the celera and arachne assemblers use k_mers shared by reads as seeds to find overlaps statistics on the number of occurrences of each k_mer are first computed and used to filter out which k_mers are used as seeds such k_mer to whom correspondence should be addressed count statistics are also used to estimate the genome_size if a large fraction of k_mers occur c times we can estimate the sequencing_coverage to be approximately c and derive an estimate of the genome_size from c and the total length of the reads in addition in most short_read assembly projects errors are corrected in the sequencing_reads to improve the quality of the final assembly for example use k_mer frequencies to assess the likelihood that a misalignment between reads is a sequencing_error or a genuine difference in sequence a third application is the detection of repeated_sequences such as transposons which play an important biological role de_novo repeat annotation techniques find candidate_regions based on k_mer frequencies the counts of k_mers are also used to seed fast multiple_sequence finally k_mer distributions can produce new biological_insights directly used k_mers frequencies with large k k to study the mechanisms of sequence duplication in genomes we consider the k_mer problem in the context where the input string s is either one dna_sequence or a concatenation of many dna_sequences and the alphabet is a c g t the main application to which we apply our new k_mer algorithms here is counting k_mers in sequencing_reads from large genome_sequencing where the length n of the sequence to process is equal to the length g of the genome sequenced times the coverage c of the sequencing project n gc recent sequencing_techniques using shorter reads with a much deeper coverage generate large_amounts of sequence and provide with a major_challenge for genome_assembly and for k_mer for example the giant panda sequencing project generated coverage yielding gb of sequence much larger than the coverage a sequencing project using traditional sanger methodology would generate of course k_mer can be naively implemented using a simple hash_table where keys are the k_mers and the stored values are the counts however this strategy is extremely slow and implementing multithreaded access to the hash_table via standard locking mechanisms results in slower performance than a singlethreaded implementation typically more advanced k_mer counters such as tallymer have been based on the suffix_array data_structure despite the recent algorithmic progress to compute the suffix_array of a string it remains a relatively expensive computational operation moreover in sequencing_applications memory_requirements for a suffix_array grow linearly with theincreasingly practical computation on large collections of genomic_sequences requires software which can use parallel computer architectures that are commonly available today the lock free operations used in jellyfish permit the design of truly concurrent data_structures that are fast in serial mode and scale almost linearly with the number of processors used jellyfish can tackle k_mer on the large_datasets available today as short_read sequencing_projects become more common and achieve larger and larger coverage efficient k_mer will become increasingly important the hash_table at the heart of jellyfish is a versatile and widely used data_structure proper optimizations make jellyfishs hash_table competitive in both time and space even when compared with other data_structures specifically_designed for string processing such as suffix_arrays as implemented in competing k_mer packages 
