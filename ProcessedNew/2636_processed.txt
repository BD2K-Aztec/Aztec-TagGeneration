kcmbt: a k-mer counter based on multiple burst trees motivation: a massive number of bioinformatics applications require counting of k-length sub-strings in genetically important long strings. a k-mer counter generates the frequencies of each k-length substring in genome sequences. genome assembly, repeat detection, multiple sequence alignment, error detection and many other related applications use a k-mer counter as a building block. very fast and efficient algorithms are necessary to count k-mers in large data sets to be useful in such applications. results: we propose a novel trie-based algorithm for this k-mer counting problem. we compare our devised algorithm k-mer counter based on multiple burst trees (kcmbt) with available all well-known algorithms. our experimental results show that kcmbt is around 30 faster than the previous best-performing algorithm kmc2 for human genome dataset. as another example, our algorithm is around six times faster than jellyfish2. overall, kcmbt is 2030 faster than kmc2 on five benchmark data sets when both the algorithms were run using multiple threads. availability and implementation: kcmbt is freely available on github: (https://github.com/abdulstring algorithms have been frequently used in bioinformatics as genomic sequences can be represented by strings from an alphabet of distinct characters. a substring of length k in a string is defined as a k-mer, where k is a positive integer. k-mers in genomic sequences have been utilized to perform various analyses on the sequences. numerous applications require counting the occurrences of particular k-mers. a k-mer counter computes the abundance of every unique k-mer in a string or a set of strings. it has become an elementary building block for various bioinformatics applications. frequencies of k-mers along with the coverage information have been used in assembling genomic sequences (burst tries to store k-mers, consideration of k x-mers and unifying a k-mer and its count in a single unit. currently kcmbt is the fastest k-mer counting algorithm. experimental results in conjunction with theoretical analysis establish our statement.we have compared our kcmbt implementation with previous best-known algorithms. kcmbt has been implemented in c , and compiled with g along with optimization level 3. we ran all the algorithms on a 16 core dual intel xeon processor e5-2667 machine with 512 gb ddr4 ram, 12 tb hdd, 256 gb sata ssd and (red hat linux enterprise 7.0). we have collected statistics for jellyfish-2.2.4, kmc2-2.3.0, turtle-0.3.1, dsk-2.0.7 and our kcmbt-1.0. we have chosen the latest working implementations of these algorithms. most of these algorithms perform much better than their original versions published in their respective publications. as kmc2 is currently the fastest k-mer counting algorithm, we have attempted to compare with it more thoroughly. for this purpose, we have used the same input datasets that kmc2 used for experiments. we have received all the information from their publication. our input data sets consist of five genomes with varied genome lengths. fragaria vesca is the smallest data set among these five, and homo sapiens 2 is the largest one. all of these genomes have multiple compressed fastq files. we have decompressed and concatenated them into one file, so that every tool can handle them easily. jellyfish2 requires an initial hash table to store k-mers and their counts. we supplied around 10 more value than the exact unique k-mers count. for example we used 7000m hash size for h.sapiens 1 where we knew that the total number of unique k-mers is around 6339 millions. some tools do not count k-mers with single occurrences. we ran all of these implementations in such a way that they output all the k-mers. turtle is another internal memory algorithm. it has a necessary parameter for the expected number of unique k-mers to select the array size it uses for sorting and counting. we have also used the same number as we have used for jellyfish2. turtle comes with three different tools: scturtle, cturtle and aturtle. each one has two versions to support for maximum 32-mer and 64-mer computations. scturtle counts k-mers with frequency 1, cturtle only reports k-mers with frequency 1 without showing their counts and aturtle gives k-mers with all frequencies along with their counts. scturtle and cturtle support multiple threads, but aturle is single threaded. we have used aturtle for our experiments as it counts k-mers with all frequencies. kmc2 is mainly an external memory or disk-based algorithm, but it has an option to make it an internal memory-based algorithm. original publication shows results for using 6 gb memory and 12 gb memory limit options. later option performs better, although we see that it uses less than allocated memory. we have only included results for the 12 gb memory limit option. dsk is another memory frugal disk-based algorithm. it can complete k-mer counting of human genome using only 4 gb of memory. we chose a fixed 6 gb of memory for all the tests although it did not use all of it. kcmbt is a cache efficient algorithm. it has several parameters which have substantial effects on the running time. containers of burst trie contain k-mers. if the container size is large, many containers will be partially filled up, and it will leave a huge memory unused. on the other hand, the depth of the trees will be low, and consequently insertion and traversal will take less time. also there will be less number of sorting, as sorting is called when a container is full. but if the container size is small, memory requirement is low. sorting and bursting are called frequently, and the height of the tree will be high. hence insertion and traversal need to compare many branches, and the running time will be increased. even if the container size is large, consumed time may be high because of numerous cache misses. another important factor is the number of trees. if we have only one tree, it becomes giant for large genomes. height of the tree grows fast, and cache misses occur constantly. to keep the depth reasonable, we employ hundreds of trees to store k-mers. index of the tree for a k-mer is determined by its prefix. as a tree contains k-mers with the same prefix, there is no need to keep that prefix in those k-mers. so we can use this spare bits to manage counting. there are some optimal values for the number of trees dependent on the genome size, cache and memory size. we see in our experiments that 4 5 or 1024 trees work the best for 2 or 4 threads, but 4 6 or 4096 is a good number for a single thread. we chose 4 6 for experiments with a single thread, and 4 5 for multiple threads. we insert k-mers into trees in batches. if we insert one k-mer at a time, caches have to be refreshed possibly each time, which is very time consuming. so we fill a buffer of a fixed size for each tree until it is full. then we insert these k-mers into that tree. we have found that a buffer size of 1024 is a good value for our experiments. another major impact factor is the value of x for k x-mers. generation of k x-mers is time consuming, but it reduces the total number of insertions or traversals. we use x 3 as a default value as we have received good results with this value. fragaria vesca has a comparatively smaller genome size and coverage. we ran jellyfish2, turtle, kmc2, dsk and kcmbt. from table 2, we see that jellyfish2 is the slowest one among these. turtle is faster than jellyfish2, but it has occupied much more memory than jellyfish2. all of our tests count all the k-mers including single occurrence k-mers. cturtle and scturtle do not provide perfect counting. so we used single threaded aturtle32 for our purposes. dsk is well-known for its careful memory usage. kmc2 is a popular disk-based k-mer counter. it requires almost the same amount of memory as dsk, but it is much faster than dsk. the internal memory version of kmc2 consumes the same amount of time as the external memory one. our kcmbt implementation shows a remarkable improvement. it is around 50 faster than kmc2 for single thread and two threads, and around 30 faster for four threads. we see that kcmbt is around six times faster than jellyfish2 for one thread and two threads, and four times for four threads. it uses 14 gb memory for one thread, where 8 gb for two threads and 11 gb for four threads. we have noticed that kmc2 is more than two times faster when running with four threads than when running with two threads.kmc2 has two phases. it uses one thread for reading sequences in the first phase. this reading thread does not employ cpu all the time. therefore it wastes some time here. so when we run with one thread or two threads, the first phase generally uses two threads. one thread is for reading sequences and another one is for computational works. but for four threads there are three threads for computation compared to one in two threads. as a consequence the speedup for four threads is better than for two threads. jellyfish2 takes more than 90 min to complete the counting of k-mers in gallus gallus for one thread and 25 min for four threads. kcmbt has also performed excellently for this data set, which took 2230 less time than kmc2. kmc2 needed 445 s for four threads, whereas kcmbt takes 347 s. kmc2(ram) spends the same amount of time as kmc2 for this genome. dsk is much slower than kmc2.compares these tools for g.gallus. atutrtle32 was run for musa balbisiana, but we waited for several hours without observing any noticeable update, and then we killed the process. so we did not include turtle for all of our other tests.also showed that turtle was an underperformer than jellyfish2 although they included results for scturtle, which reports k-mers with frequency above 1.displays results for m.balbisiana. jellyfish2 uses only 11 gb of memory to count k-mers for m.balbisiana, but it is more than three times slower than kmc2. kcmbt is also around 30 faster than kmc2, and dsk takes more than double the time taken by kcmbt. we see from tables 2, 3 and 4 that kcmbt for two threads and four threads takes much less memory than for one thread. the memory usage depends on several factors such as k-mer distribution of that input genome, percentage of buckets filled up in burst trees, and so on. human genome is a massive as well as vital data set. we have compared these tools for h.sapiens 1 and h sapiens 2 and arranged the results in tables 5 and 6, respectively. homo sapiens 1 has around 62.7 billion 28-mers and 6.3 billion unique 28-mers. jellyfish2 is still a very memory efficient internal memory algorithm, as it has used only 41 gb of memory to hold these huge number of unique k-mers and their counts in memory. but it is very slow compared to other tools in. kmc2 is five times faster than this one. kmc2(ram) achieves a similar speed up. dsk seems to be slow compared to kmc2 and kcmbt. kmc2 is slower than kcmbt by around 35 for one thread, 20 for two threads and 17 for four threads. homo sapiens 2 has more coverage than h.sapiens 1. the comparative analysis among these tools remains the same fromkcmbt: a k-mer counterh.sapiens 1 to h.sapiens 2. in this case, kmc2 is around 45 slower than kcmbt for one thread and 30 slower for four threads. kcmbt consumes 82 gb memory for a single thread, whereas kmc2(ram) uses 107 gb. but kcmbt takes 147 gb memory for four threads as every prefix has four trees and similar k-mers exist in four trees. kcmbt works in three phases. the most time consuming phase is the generation of k x-mers and insertion of them. we have chosen 0 x 3 for all of our tests. the first phase generates k-mers and their reverse complements, and tracks the minimum or canonical ones. then it slides one symbol, computes new k-mer value and a new reverse complement. it again finds the minimum one of these two. if this minimum and the previous minimum are from the same direction (given a k-mer direction or its reverse complement direction), it gets a k 1-mer. then it shifts symbol again to extend till x 3 or directions of minimum and previous minimum are different. we maintain fixed length buffers for each tree. whenever a buffer is full, all the k x-mers are inserted into the tree. insertion is also time consuming. it incorporates traversal to find the proper bucket, and if the bucket is full, a new node and buckets are created and the distribution of k x-mers takes place. so we see fromthat 59 of the total time for f.vesca was needed for this first phase. this value is 78 for g.gallus, 90 for m.balbisiana, 81 for h.sapiens 1 and 86 for h.sapiens 2. this phase takes a major portion of the total time, and the ratio increases according to the size of the total number of k-mers and unique k-mers. we show the importance of generation and insertion of k xmers in the first phase in. the last column indicates how many k-mers will have to be inserted if we only insert k-mers instead of k x-mers, where x 0. for each data set, we had to call insertion less than 50 of the times because of the benefits of generation of k x-mers. we also see that this phase produces a majority number of k 3-mers after k-mers for every considered genome except m.balbisiana. this point is beneficial for the second and the third phases. this reduction in the number of insertions comes at some expense on k x-mers generation. the first phase completes a considerable part of the work. the second phase traverses all the k 1-mer, k 2-mer and k 3mer trees. after the traversal of a k 1-mer tree, we get the k 1-mer count of that specific k 1-mer. if this count value is c, then the constituent two k-mers (starting at position 0 and position 1, respectively) will have a count of c from this k 1-mer. k 2-mer trees contain k 2-mers, each of which has three k-mers. for a k 3-mer, this value is 4. so when x is large, our gain is large as well.shows how many unique k x-mers exist after the traversal in phase 2, where 1 x 3. let c 1 , c 2 and c 3 be the counts of k 1-mers, k 2-mers and k 3-mers found in phase 2, respectively. we know that a k x-mer covers x 1 k-mers. so we get 2c 1 3c 2 4c 3 k-mers from only c 1 c 2 c 3 k x-mers, where 1 x 3. for h.sapiens 2, we observe that the average counts of k 1-mers, k 2-mers and k 3mers is around a billion. this average is more than 65 million for f.vesca, 300 million for g.gallus, 125 million for m.balbisiana and 760 million for h.sapiens 1. this improved achievement is the main reason behind the consideration of k x-mers. from all of these experiments, we discover that high expenses at first phase are substantially recovered by second and third phases.displays the total numbers of k-mers in k-mer trees after the first two phases. if the number of k-mers in a tree increases, the height of the tree might increase. the other effects are moreinsertion time and traversal time. we have thousands of trees to reduce the height of these trees. the idea of generation, insertion and traversal of k x-mers also facilitates our intention of keeping the trees within a reasonable height. the total number of k-mers in k-mer trees is 18 754 millions instead of 62 739 millions for h.sapiens 1 26 818 millions instead of 98 893 millions for h.sapiens 2. these values are 45 times smaller than originally required insertions. as the inserted numbers of k-mers have been reduced a lot, the time for traversal in the third phase is dramatically reduced. we observe fromthat very little amount of time was spent for this final traversal. third phase traverses these k-mer trees, and produces k-mers with their counts. if we do not use k x-mers for some x 0, then we have to traverse larger trees, which is very time taking. the number of trees has a huge impact on the running time. if we increase the number of trees, the average height of trees decreases. therefore insertion and traversal take less time. but after a certain number, the running time starts to increase. because there are already many trees and cache misses occur frequently at the time of insertion. our observations from experimental results imply that 1024 (4 5 ) or 4096 (4 6 ) are quite good numbers for the trees for these data sets. we used 4 6 for all of these experiments. we have included elapsed time for all of these data sets for these two values inkcmbt outperforms every other k-mer counter by a large margin. kmc2 is currently the best-performing k-mer counter. it requires a low internal memory and some not so much inexpensive disk storage. it is practically a very fast k-mer counter with several good options. we have collected data sets of the five genomes used in our experiments from available links in the published paper of kmc2 . in this kmc2 paper the authors also explain how they ran the other programs. we have tried to employ the same values for the underlying parameters except for the number of cores. we have shown in the previous section how our ideas were fruitful in counting k-mers efficiently. our algorithm chooses burst tries to store k-mers. burst trie is very cache efficient for keeping strings in approximate sorted order. we need that for holding somewhat similar k-mers together. for large genomes, there exist enormous numbers of k-mers. a single tree is not enough to store all of them efficiently. insertion and traversal become very time expensive operations because of the large height of the tree. we employed hundreds of trees to resolve this issue. when the number of trees is large, we can remove some prefix bits from each k-mer to index its corresponding tree. these extra bits can be used to store counts. keeping a k-mer and its count together in an unsigned 64 bit word is indeed helpful. since the alphabet size is 4, each symbol needs at least 2 bits. if we want a 5 symbol prefix, there will be 4 5 or 1024 trees. we ran kcmbt for prefix 07 symbols. for 04 value, some of these tree heights become large. for a value of 7, there are a massive number of trees, and cache misses occur regularly. we have found good results for values 5 and 6. it is not fruitful to insert one k-mer at a time. if we choose this option, in some of the cases the running time rises more than 25 because of frequent cache swapping. therefore we choose a large buffer to cache these k-mers and insert them at a time, which is very cache friendly. our first attempt was generation and insertion of k-mers. there were two phases. the first phase inserted these k-mers into trees and the second phase traversed them to accumulate all k-mers with their counts. but this idea was not good enough to outperform kmc2 in some cases. we have adapted the very good idea of using of k xmers from kmc2. we have followed almost the same idea to generate these k x-mers. kmc2 generates them from super k-mers stored in disk files. we form them from k-mers in the first phase. experimental outcomes prove the usefulness of this idea. it eliminates many insertion and traverse counts. we generally use k xmers, where 0 x 3. a value of more than 3 for x works better if they have enough duplicate occurrences. we have noticed that 0 x 3 performs better in our experiments.in the second phase, we traverse k x-mer trees, and count the number of occurrences of each k x-mer. we then split each k x-mer into k-mers, and insert them into k-mer trees. we could have improved the time by not inserting the k-mers occurring in the first positions of k x-mers. if we did that, we will have to merge at a later stage. the process would be complicated. as the total time spent in the last two phases is not that much, we have avoided this complexity.kcmbt: a k-mer counter  
