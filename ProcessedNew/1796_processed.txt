fastsp: linear time calculation of alignment accuracy motivation: multiple sequence alignment is a basic part of much biological research, including phylogeny estimation and protein structure and function prediction. different alignments on the same set of unaligned sequences are often compared, sometimes in order to assess the accuracy of alignment methods or to infer a consensus alignment from a set of estimated alignments. three of the standard techniques for comparing alignments, developer, modeler and total column (tc) scores can be derived through calculations of the set of homologies that the alignments share. however, the brute-force technique for calculating this set is quadratic in the input size. the remaining standard technique, cline shift score, inherently requires quadratic time. results: in this article, we prove that each of these scores can be computed in linear time, and we present fastsp, a linear-time algorithm for calculating these scores. even on the largest alignments we explored (one with 50 000 sequences), fastsp completed 2 min and used at most 2 gb of the main memory. the best alternative is qscore, a method whose empirical running time is approximately the same as fastsp when given sufficient memory (at least 8 gb), but whose asymptotic running time has never been theoretically established. in addition, for comparisons of large alignments under lower memory conditions (at most 4 gb of main memory), qscore uses substantial memory (up to 10 gb for the datasets we studied), took more time and failed to analyze the largest datasets. availability: the open-source software and executables are available online atestimation of multiple sequence alignments for molecular datasets is fundamental to many problems in biology, including the prediction of protein function and structure and phylogeny estimation. estimated alignments are often compared with other alignments in order to assess accuracy or to determine the features shared by two or more alignments. in addition, since different alignment methods can produce alignments that differ enough to introduce phylogenetic uncertainty and alignment error increases with the size of the dataset , the use of several alignments, and comparisons of these alignments, is advisable for large-scale phylogenetic studies. to whom correspondence should be addressed.of the various methods for comparing an estimated alignment to a reference alignment, four are generally in use: the developer score (also called the sp-score, for sum-of-pairs), modeler score, total column score and cline shift score. the sp-score and modeler scores are quite similar: the sp-score is the percentage of the homologies in the reference alignment that appears in the estimated alignment, and the modeler score is the percentage of the homologies in the estimated alignment that appears in the reference alignment. thus, each can be obtained by computing the number of shared homologies and then normalizing by either the number of homologies in the reference or true alignment. the total column score is the number of alignment columns shared by both alignments, and can also be normalized by the number of columns in one of the alignments. finally, the cline shift score is computed by averaging the cline shift scores for each of the induced pairwise alignments. each of these normalized scores ranges from 0 to 100, with 0 indicating that the two alignments are maximally dissimilar for the criterion and 100 indicating that the two alignments are considered identical with respect to the criterion. thus, these scores represent accuracy measures, and complementing these scores (subtracting them from 100) produces the corresponding error metrics. while several methods have been developed for comparing alignments, only qscore and lobster (available online at http://www.drive5.com/qscore and http://www.drive5 .com/lobster, respectively) correctly compute the sp-score. however, the computational complexity of these methodsi.e. their asymptotic running timehas never been established. clearly, all four scores can be computed in quadratic time using bruteforce techniques, and the cline shift score (by definition) requires quadratic time. however, the sp-score, modeler score and total column scores might not require quadratic time. in this article, we show that the sp-score, modeler score and total column scores can each be computed in linear timetime where n is the number of sequences and k is the length of the longer alignment]. we present a method, fastsp, to compute the number of shared homologies between two alignments and prove that it runs in linear time. the result then follows, since each of the three scores can be obtained directly from this number. since error scores are complements of these accuracy scores, fastsp can be used to compute error rates such as sp-fn (the percentage of true homologies missing in the estimated alignment) and sp-fp (the percentage of predicted homologies that are not present in the true alignment). furthermore, fastsp can be used to evaluate the reliability of a given alignment with respect to a set of alignments, since it enables fast all-pairs comparisons. thus, fastsp is a basic tool for analyzing sets of multiple sequence alignments.the main observations we can make are these. when run on machines with sufficient memory (at least 8 gb for these datasets we studied), fastsp and qscore have very close running times, but qscore has higher peak memory usage. thus, even though the two methods are not distinguishable by running time in this case, they differ substantially in terms of memory usage. on the other hand, when memory is limited to 4 gb, the two methods have substantially different running times for large alignments. thus, in general the two methods cannot be distinguished on alignments with small numbers of taxa, but are distinguished on large alignments either with respect to running time (if memory is limited to 4 gb) or with respect to memory usage (when memory is not limited). although the methods have different running times, it is evident that the differences in running time are a result of differences in their memory usage. but, why do we see these differences? recall that fastsp has memory usage that grows only linearly with the reference alignment size, and does not need to keep the estimated alignment in memory; this can reduce the memory usage substantially. the most likely explanation is a simple one: qscore uses more memory simply because it was not implemented with memory usage optimization as one of its objectives.  
