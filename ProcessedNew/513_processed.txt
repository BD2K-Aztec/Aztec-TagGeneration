assembling short reads from jumping libraries with large insert sizes motivation: advances in next-generation sequencing technologies and sample preparation recently enabled generation of high-quality jumping libraries that have a potential to significantly improve short read assemblies. however, assembly algorithms have to catch up with experimental innovations to benefit from them and to produce high-quality assemblies. results: we present a new algorithm that extends recently described exspander universal repeat resolution approach to enable its applications to several challenging data types, including jumping libraries generated by the recently developed illumina nextera mate pair protocol. we demonstrate that, with these improvements, bacterial genomes often can be assembled in a few contigs using only a single nextera mate pair library of short reads. availability and implementation: described algorithms are implemented in c as a part of spades genome assembler, which is freely available at bioinf.spbau.ru/en/spades.in an article titled de novo fragment assembly with short matepaired reads: does the read length matter?,argued that availability of paired reads with long and accurate insert sizes (rather than the increase in the read length) is the most important factor for improving the quality of short read assemblies. however, while paired reads with long insert sizes have been extensively used in many assembly projects, robust generation of readpairs with accurate insert sizes proved to be difficult and have only been achieved recently. the recently emerged sample preparation technologies open new opportunities for genome assembly from short reads. for example, illumina nextera mate pair protocol generates long inserts (3 kb and longer) that feature rather tight insert size distribution and small rate of non-circularized fragments that result in read-pairs with abnormal distances. as discussed in, such read-pair libraries may enable assemblies approaching the quality of assemblies from long reads of length equal to the insert size. moreover, they can potentially substitute the existing assembly approaches based on a combination of short paired-end libraries (with insert size less than 1 kb) and long jumping libraries (with insert sizes typically longer than 1 kb) by a pipeline based on a single nextera mate pair library. however, even though the popular assembly algorithms perform well with the previously proposed approaches to sample preparation, they have not kept up with recent experimental innovations. to catch up, bioinfomaticians either need to design novel tools for every technology improvement or to develop a universal assembler that can be easily modified to support new data types. for example, ray and spades is based on the path extension framework that was proposed by the authors of the ray assembler and later implemented in the telescoper and perga assemblers. given a path p in the assembly graph , exspander iteratively attempts to grow it by choosing one of its extension edges (all edges starting at the terminal vertex of the path p). the assembly graph is defined as simplified de bruijn graph of k-mers in reads after removal of bulges, tips and chimeric edges. to extend a path p, exspander computes the scoring function score p e for each extension edge e using read-pairs with one read mapping to p and another read mapping to e (further referred to as (p, e)-connecting read-pairs). afterward, exspander decides whether to select the top-scoring extension edge or to stop growing p. it iteratively repeats the path extension procedure starting with single-edge paths until every edge in the assembly graph is covered by at least one path and no path can be extended further. to generate equivalent contigs on both strands, exspander is implemented as a bidirectional approach that can extend a path in both directions. while the scoring function score p e described in prjibelski et al.(2014) works well with short libraries, it appears to be rather inefficient when using jumping libraries. the key limitation of the previously defined scoring function is that it analyses only (p, e)connecting read-pairs (where e is an extension edge of path p) and ignores read-pairs that connect path p with other edges. when an edge e is short and the variations in the insert sizes are large, there is a danger that no (p, e)-connecting read-pairs exist and thus scorep; e 0 even if e is the correct extension edge . thus, the decision rule may stop extending path p or even select an incorrect extension edge. additionally, the approach described inis inapplicable for scaffolding procedure, since it is unable to jump over coverage gaps. in this article, we extend the exspander approach to scaffolding. this extension is important since scaffolding with jumping libraries may dramatically improve the assembly quality. we describe several algorithms that address these bottlenecks based on the following idea. consider a set of extension paths e [rather than extension edges as in] that contain all sufficiently long paths (longer than the insert size) starting from the extension edges of the path p. once the set e is constructed, we choose the best-scoring path e in e and extend path p by the first edge of e. our analysis has shown that such conservative extension (by the first edge of the best-scoring extension path rather than by the entire path) provides more accurate assemblies. to perform scaffolding procedure, we allow extension paths to jump over coverage gaps in the assembly graph. this intuitive approach, while appealing, is often impractical since the assembly graph is usually tangled, resulting in a prohibitively large number of extension paths. to reduce the running time, we have implemented the new algorithm based on the observation that, instead of the exhaustive search through the set of all extension paths, one can significantly prune this set using single reads and paired-end libraries (if available). we demonstrate that the new algorithm enables assemblies of nearly complete genomes from a single nextera mate pair library. we also show that spades, coupled with the improved exspander algorithm, outperforms other popular assemblers, such as abyss , idba-ud , ray , soapdenovo and velvet on various types of datasets.to evaluate how availability of nextera mate pair libraries affects the quality of assembly, we assembled several bacterial genomes using multicell datasets provided by illumina (nextera mate pair libraries only). in this article, we describe benchmarking (using seven different assemblers and three scaffolders) on meiothermus ruber str. 21t nextera mate pair library and additionally, on escherichia coli st. k12 subst. mg1655 single-cell dataset that contains both a short paired-end library and a long jumping library. results for other nextera mate pair libraries are presented in the supplementary material. since the assemblers we used for comparison were not designed for assembling nextera mate pair libraries, we have conducted. jumping over coverage gaps in the assembly graph from an out-tip to an in-tip: (a) an extension path e (marked red) ending with an out-tip e; (b) the only p-supported edge e 0 is an in-tip (marked green); (c) the path e is extended by an edge e 0 with a gap (red line). jumping over coverage gaps in the assembly graph from an out-tip to an internal edge: (d) the only p-supported edge e 0 is not an in-tip (marked green) and (e) paths e 1 and e 2 that start with in-tips and contain p-supported edge e 0 , both paths are considered as possible extensions for e (shown by red lines) additional optimization and selected the optimal k-mer sizes (with respect to n50) to ensure fair benchmarking with these assemblers. we ran abyss 1.3.6 , ray 2.0.0 , soapdenovo 2.0.4 , velvet 1.2.10 and velvet-sc (based on velvet 0.7.62, released on march 11, 2011) with the kmer sizes 59, 57, 71, 99 and 105, respectively. iterative de bruijn graph assemblers idba-ud 1.1.1 , spades 3.0.0 (with the previous version of exspander (and spades 3.5.0 (that implements the new algorithm described in this article) were run with the default parameters. in addition to scaffolds, we also provide information about contigs generated by spades 3.5 (referred to as spades 3.5 ctg). we have also included results for such popular scaffolders as opera 2.0 , scarpa 0.241 and sspace 3.0 . to perform a fair comparison, we ran all scaffolders on the contigs that were assembled by spades 3.5.0 using all data as single-end reads (discarding read-pair information). the resulting assemblies were evaluated with quast 2.3 using standard metrics: nga50 (ng50 corrected for assembly errors), the total number of scaffolds in the assembly, the size of the largest scaffold, the number of misassemblies, the fraction of genome covered and the number of uncalled bases (n) in the assembly.benchmarks various assemblers on m.ruber nextera mate pair library (mean insert size 3.6 kb). some of the assemblers used in the comparison produce rather inaccurate assemblies (e.g. 95 misassemblies for ray and 244 misassemblies for soapdenovo). also, some assemblers generate very large number of unspecified symbols n (abyss, ray, soapdenovo and velvet). interestingly, most assemblers showed rather unstable behavior with nextera mate pair libraries with exception of idba-ud and spades (originally developed as single-cell assemblers). spades exspander assembles an almost complete m.ruber genome with less than 0.03 of unspecified nucleotides and the largest scaffold capturing more than 93 of the genome. spades generates similar high-quality assemblies on all nextera mate pair libraries (see supplementary material) and often results in assemblies of very few contigs with the quality that approaches the quality of the assemblies from long pacific biosciences reads . thus, nextera mate pair libraries provide a valuable low-cost trade-off when compared with the assemblies that use pacific biosciences reads. in table 2, we also present a comparison between selected tools on e.coli single-cell dataset with paired-end and jumping libraries. in addition, we ran allpaths-lg (build 47561, released on september 15, 2013) with the default parameters using both libraries together. as  
