idba-tran: a more robust de novo de bruijn graph assembler for transcriptomes with uneven expression levels motivation: rna sequencing based on next-generation sequencing technology is effective for analyzing transcriptomes. like de novo genome assembly, de novo transcriptome assembly does not rely on any reference genome or additional annotation information, but is more difficult. in particular, isoforms can have very uneven expression levels (e.g. 1:100), which make it very difficult to identify low-expressed isoforms. one challenge is to remove erroneous vertices/ edges with high multiplicity (produced by high-expressed isoforms) in the de bruijn graph without removing correct ones with not-so-high multiplicity from low-expressed isoforms. failing to do so will result in the loss of low-expressed isoforms or having complicated subgraphs with transcripts of different genes mixed together due to erroneous vertices/edges. contributions: unlike existing tools, which remove erroneous ver-tices/edges with multiplicities lower than a global threshold, we use a probabilistic progressive approach to iteratively remove them with local thresholds. this enables us to decompose the graph into disconnected components, each containing a few genes, if not a single gene, while retaining many correct vertices/edges of low-expressed iso-forms. combined with existing techniques, idba-tran is able to assemble both high-expressed and low-expressed transcripts and outperform existing assemblers in terms of sensitivity and specificity for both simulated and real data.recent development of massively parallel cdna sequencing (rna-seq) provides a more powerful and cost-effective way to analyze transcriptome data. rna-seq has been used successfully to identify novel genes, refine 5 0 and 3 0 ends of genes, study gene functions , locate exon/intron boundaries and estimate expression levels of isoforms . however, transcriptome reconstruction (the reconstruction of all expressed transcripts) from rna-seq data remains a challenging unresolved problem when there is splicing, i.e. when different combinations of regions (exons) of a single gene are decoded to multiple transcripts (isoforms) . currently, there are two computational approaches to solve this problem. alignment-based methods, such as cufflinks and scripture , first align reads to reference genomes using splice junction mappers, such as tophat , to identify exonintron boundary and then build a graph in which exons are the nodes and two exons are connected if reads connect them. cufflinks attaches weights to edges and models the isoform reconstruction problem as a minimum path cover problem, while scripture creates a statistical model to identify significant segments as isoforms. in contrast, de novo assembly methods, such as trinity , oases , trans-abyss and t-idba , assemble transcripts directly from reads. alignment-based transcriptome assembly methods, which rely on reference genomes and additional annotation information, may suffer from missing/erroneous information. also, the quality of these methods depends heavily on the accuracy of the alignment tools , which is also complicated by splicing and sequencing errors. as rna-seq technology becomes more mature, there will be an increasing need to reconstruct unknown transcriptomes without reference genome information, and de novo transcriptome assembly will become increasingly more important. difficulties: at first glance, the de novo transcriptome assembly problem looks similar to the de novo genome assembly problem. in fact, many existing methods for de novo transcriptome assembly, like genome assembly, apply the de bruijn graph approach with fragments of transcripts being simple paths in graph, in which a vertex is a k-mer and an edge exists between two vertices u and v if u and v appear consecutively in a read. however, two main aspects make the two assembly problems different. (1) exons shared by multiple isoforms. in this paper, we focus on transcriptome assembly for eukaryotes with splicing since, without splicing, the problem is much easier. consider the example (loc_os10g02220 from rice) in. a to i represent different exons forming 5 isoforms (in red). shared exons (e.g. d and h) look like repeats, and most genome assemblers try to resolve repeats at the branch level, i.e., each branch needs to be supported by paired-end reads. in our case, since all five isoforms are real, branches bd and cd as well as de and df will be supported. some assemblers may stop at the junctions, reporting b, c, d, e and f as separate (short) contigs or falsely regard cde as a transcript (provided both cd and de have enough support). for example, running velvet on the rice data to whom correspondence should be addressed. the author 2013. published by oxford university press. this is an open access article distributed under the terms of the creative commons attribution non-commercial license (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. for commercial re-use, please contact journals.permissions@oup.com (see section 3.2 for details) results in contigs of mean length 245 bp only, while the mean length of transcripts is about 1700 bp. some metagenomic and single-cell assemblers try to find a path with maximum paired-end reads support; however, as the insert distance of transcriptome data usually cannot cover more than one branch (splicing junction) and there are multiple correct paths (isoforms) with paired-end reads support, these assembliers also fail to reconstruct the isoforms. (2) different expression levels of isoforms of the same gene. isoforms of the same gene may have very different expression levels. there are two problems. first, low-expressed isoforms may have little support from reads and thus are missed by the assembler. for example, in, if there are only a few paired-end reads supporting branch bd and fh, isoform abdfh is unlikely to be obtained. second, support from reads of erroneous k-mers from high-expressed transcripts may be higher than that of correct k-mers from low-expressed transcripts. these erroneous k-mers introduce branches in the de bruijn graph and make the graph very complicated.shows an example from a real rice transcriptome dataset (loc-os12g12850). this subgraph (k 50) is supposed to contain only two isoforms (shows the conceptual view of the isoforms). there are 92 353 and 90 126 erroneous k-mers and branches respectively in the de bruijn graph when we simulated reads with 1 sequencing error (details shown in section 3). existing approaches usually employ a global threshold to remove erroneous k-mers and branches if the multiplicities of these components are smaller than the threshold. this simple approach will not work for transcriptome data. since the error positions of each read are known, we can count the number of correct and erroneous k-mers for simulated data on rice (section 3.1) for different multiplicities . no matter how we set the threshold of multiplicity for removing erroneous k-mers (draw a vertical line and consider all k-mers on the left with lower multiplicities as erroneous k-mers), some erroneous kmers will remain and correct k-mers will be removed. these complicated components will make isoform finding extremely difficult as there are many paths to be considered. in the ideal case, the de bruijn graph should have many isolated components, each representing isoforms from one gene unless there are repeats in different genes. in most cases, the structure of the component should be simple as most genes do not contain many isoforms. to tackle this issue, we need a method to separate components that are falsely connected by erroneous k-mers and we need to remove erroneous k-mers from each component.existing solutions: oases and trinity are two popular de novo transcriptome assemblers for rna-seq data. in order to solve the splicing problem], both apply a dynamic programming approach to identify potential paths in the graph, which are supported by many reads or paired-end reads. in other words, they try to identify isoforms more globally through a path-level analysis instead of a local branch-level analysis. the results are much better than those of genome assemblers. however, since the problem is np-complete (proved in the supplementary appendix), the running time of the dynamic programming approach increases exponentially with the number of branches in the de bruijn graph. due to issue (2), erroneous reads sampled from high-expressed transcripts introduce many branches (with more support than reads sampled from low-expressed transcripts) and thus dynamic programming takes a long time. in practice, these tools fall back on heuristic search instead of dynamic programming for large components. to tackle issue (2), t-idba uses another approach to isolate components. based on the observation that transcripts from different genes share less common vertices when k value is large, t-idba builds a de bruijn graph from small k and iteratively updates the graph with larger k values. it then finds transcripts in the de bruijn graph with large k value where transcripts from the same gene usually form a single component. however, it does not perform very well for low-expressed transcripts because there are more missing k-mers when k is large. there is no dedicated solution in t-idba that solves the issue of erroneous k-mers within a component and methods for isolating components are not sensitive to low-expressed isoforms. to recover low-expressed transcripts, several post-processing methods were developed for velvet and abyss . they are all based on the observation that lower k values make the assembler more sensitive to low-expressed transcripts, while larger k values make it more specific to high-expressed transcripts. in order to combine the advantages of different values of k, the resultant contigs, generated by different k-mer lengths independently, are merged together. however, merging assembly results from different runs is not a straightforward task. although output transcripts are clustered and duplicated transcripts are removed, many duplicates are difficult to detect and errors can accumulate in the cluster-remove step. as a result, multiple contigs with errors are generated for the same transcripts and the number of resulting contigs is much more than the number of expressed transcripts. oases-m, an extension of oases, makes use of multiple k to improve its assembly result and is now the best tool using this approach. however, since the fundamental problem of removing erroneous vertices from high-expressed isoforms while keeping correct vertices from low-expressed isoforms is not solved, there are still many false positives as well as duplicated transcripts (section 3). some single-cell genome assemblers also have a problem with uneven multiplicities of correct k-mers. they resolve the problem based on the assumption that, although the multiplicities of these erroneous k-mers are high, their multiplicities should be lower than the nearby correct k-mers. thus, they calculate a local threshold, based on. example of de bruijn graph for five isoforms from the same gene i327 idba-tran the multiplicities of nearby k-mers or contigs, for removing erroneous k-mers. however, as a k-mer representing the common exon of several expressed isoforms can have relatively higher multiplicity than nearby correct k-mers , calculating the local threshold from only one or two nearby kmers or contigs may be misleading and the algorithms may remove many correct k-mers near these high multiplicity k-mers. our contributions: if issue (2) can be resolved, issue (1) can be tackled by existing path-level analysis as the components will be simple enough. thus, our core contribution is handling issue (2). as mentioned before, the traditional filtering method of using one single global threshold for multiplicity cannot separate correct k-mers sampled from low-expressed transcripts from erroneous k-mers sampled from high-expressed transcripts, and single-cell genome assemblers calculating local thresholds from nearby k-mers may remove many correct k-mers. thus, we propose a probabilistic progressive approach to solve this problem. our proposed assembler idba-tran calculates the probability that a k-mer or short simple path (contigs) contains error using not only the multiplicity of the k-mer or contig (or their neighboring k-mers or contigs) but also uses a multi-normal distribution to model the multiplicities of all k-mers in the whole connected component. based on the multi-normal distribution and the contig length (as a short simple path is more likely to have error than a long one), idba-tran calculates a local threshold for determining whether a k-mer or contig has error. by progressively removing erroneous k-mers, connected components representing isoforms from a single gene are identified. since we successfully remove many erroneous k-mers, the size of each component is small. we can employ a path-level analysis (similar to oases and trinity) to identify transcripts from each component. thus idba-tran can perform better than oases and trinity, producing more contigs, particularly for lowexpressed transcripts. results show that idba-tran outperforms other de novo transcriptome assembly approaches in terms of both sensitivity and specificity for both simulated and real data. idba-tran also makes use of other techniques used in genome assemblers, such as tips pruning, path merging and error correction.shows the workflow of idba-tran for assembling a set of paired-end reads. in the first iteration when k k min , h k is equivalent to a de bruijn graph for vertices whose corresponding k-mers have multiplicity of at least m (2 by default) times in all reads. during all subsequent iterations, sequencing errors are first removed according to the topological structure of h k in a slightly different way to other assemblers (section 2.1). the tips (dangling paths in h k of length shorter than 2k) are likely to be false positives . similar paths (bubbles) representing very similar contigs with the same starting vertex and ending vertex are likely to be caused by errors or snps and they should be merged . then, the depth information for contigs and components is used to decompose the graph into components (section 2.2). paths with high support for the paired-end reads are reconstructed as transcripts in each component (section 2.3). errors in the assembled contigs are corrected by aligning reads to the contigs (section 2.4). when constructing h ks from h k , each length s 1 path in h k is converted into a vertex ((k s)-mer) and there is an edge between two vertices if the corresponding (k s 1)-mer appears f (1 by default) times in reads or once in contigs in c k [lc k [t k , where c k represents the set of contigs, lc k is the set of contigs constructed by local assembly using paired-end information (section 2.5), and t k is the set of transcripts when considering h k. in the following subsections, we describe each step of idba-tran in detail.each branch in the graph, idba-tran checks each outgoing (and incoming) edge, keeps the branch which leads to the longest path, and removes all other branches (tips) which lead to paths shorter than 2k. usually, the correct branch leads to longer paths than tips, and this method preserves correct branches. as transcriptome sequencing data contains more errors and insertions/ deletions than genome sequencing data, idba-tran identifies and merges paths with same starting point and end point and higher than 98 similarity (including insertions and deletions).to evaluate the performance of idba-tran, experiments were carried out on both simulated and real data. we compared idba-tran with the latest transcriptome assemblers trinity and oases . we also compared idba-tran with the single-cell genome assembler idba-ud and velvet-sc , which apply multiple depths when assembling genomes. idba-tran and idba-ud were run with k ranging from 20 to 50 with step size 5. for oases and velvet-sc, k values ranging from 20 to 50 with step size 5 were used, and the best result was selected as output. as the k value of trinity was fixed to 25, the default parameters were used to run it.for transcriptome assembly, the most important indicator of assembly quality is the number of correct transcripts an assembler can reconstruct. in the experiments, known transcript references were used for benchmarking. a known transcript is reconstructed successfully if a certain portion, say 80 (referred as completeness), of its sequence is covered by a contig with 95 similarity. similarly, the contig is considered correct if it can be aligned to at least 80 of a transcript with 95 similarity. the alignment of contigs to transcripts was performed by blat without considering long gaps representing introns (as we aligned contigs to transcripts instead of genome). the sensitivity and specificity were calculated to measure performance. sensitivity is the percentage of reconstructed transcripts over all expressed transcripts. specificity is the percentage of correct contigs over all reported contigs. we also compared the performance of idba-tran and cem on estimating expression levels of reconstructed transcripts. cem requires the genome sequence as additional information. by aligning reads to the reference genome, cem can predict the expressed transcript sequences and estimate the expression level of each transcript based on a statistical model (quasi-multinomial model). since some transcripts may align to multiple contigs and some contigs may align to multiple transcripts, we considered only those transcripts and contigs with one-to-one correspondence. the pearsons correlation between the predicted expression levels and the exact expression levels was calculated. as suggested in, we also calculated the pearsons correlation between the logarithm of predicted expression levels and the logarithm of exact expression levels.we have identified one key issue in transcriptome assembly, namely how to remove erroneous vertices/edges of high multiplicity (due to high-expressed isoforms) from the de bruijn graph while keeping correct ones with relatively lower multiplicity (due to low-expressed isoforms). we developed a probabilistic progressive approach with local thresholds to solve the problem. we proposed idba-tran, combined with other techniques, to assemble transcriptome sequencing data. experiments on both simulated and real data confirm that idba-tran can outperform existing de novo transcriptome assemblers in terms of both sensitivity and specificity. in particular, for low-expressed transcripts, the improvement of idba-tran is substantial. recall that there is another approach to recover both low-expressed and high-expressed transcripts, namely: run the assembler for different k values and merge all contigs as output. oasesm, which runs oases several times with multiple k values, is a post-processing tool based on this approach. oases-m can reconstruct many transcripts for both simulated and real data. however, since erroneous contigs cannot be merged, oases-m produces many incorrect contigs and has a low specificity (see supplementary). moreover, contigs representing some transcripts may appear multiple times (with small difference) in the output such that the number of correct contigs is double the number of reconstructed transcripts. the large number of erroneous contigs and redundant contigs may make analysis difficult, and it is very hard to distinguish the erroneous contigs from the correct ones. on the other hand, we found that oases-m had slightly better performance than idba-tran for high-expressed transcripts for real data (see supplementary). thus, it may be a good idea to investigate how to integrate both approaches to reconstruct more transcripts.  
