ace: accurate correction of errors using k-mer tries the quality of high-throughput next-generation sequencing data significantly influences the performance and memory consumption of assembly and mapping algorithms. the most ubiquitous platform, illumina, mainly suffers from substitution errors. we have developed a tool, ace, based on k-mer tries to correct such errors. on real miseq and hiseq illumina archives, ace yields higher gains in terms of coverage depth, outperforming state-of-the-art competitors in the majority of cases. availability and implementation: ace is licensed under the gpl license and can be freely obtained at https://github.com/sheikhizadeh/ace/. the program is implemented in c and runs on most unix-derived operating systems.genome sequencing involves reading thousands or millions of genome fragments and reconstructing the original genome, either by assembling these reads in de novo assembly projects, or aligning them to a known reference genome in re-sequencing studies. over the last decade, next-generation sequencing (ngs) technology dramatically increased the ease with which material can be sequenced, yielding millions of short reads in a short time. the lower quality of the data (compared to sanger sequencing) however significantly influences performance and memory consumption of assemblers and alignment algorithms; as a result, there has been a growing interest in correcting errors in short-read archives. sequencing errors can result in substitutions, insertions, deletions and unconfirmed nucleotides represented by n symbols. the most ubiquitous platform, illumina, mostly suffers from substitution errors while for others, like 454 and ion torrent, insertions and deletions are most abundant. as an error at a specific genomic position occurs infrequently and randomly, an erroneous base can be detected and corrected taking advantage of the high frequency of the reads that cover that position. this is the idea behind all count-based error correction methods which count k-mers using various data structures. for example, shrec constructs a generalized suffix trie while hitec uses a suffix array. built upon shrec, hybrid-shrec captures indel errors as well as substitutions. sga performs error-correction using the fm-index derived from the compressed burrows-wheeler transform. bless employs a bloom-filter and racer organizes 2-bit-encoded k-mers as 64-bit integers and stores them in a hash table. fiona, based on partial suffix array, is also able to deal with indel errors . alternatively, k-spectrum based error correction methods, like quake and musket collect all k-mers appearing in the set of reads, and align those with a small hamming distance from each other to achieve the correct consensus. finally, msa-based methods, like coral , apply multiple sequence alignment between reads that share k-mers to detect errors. a recent survey provides a comprehensive review of error-correction methods, and establishes a common set of benchmark data and evaluation criteria . here we present ace, a new k-mer count-based algorithm. we employ the k-mer trie, a data structure more time/space-efficient than the suffix trees employed in shrec. k-mer tries have been effective in solving some bioinformatics problems .we experimentally compared the performance of ace in increasing the coverage depth/breadth of reads/k-mers to those of seven stateof-the-art tools, using the benchmark data and following the same evaluation procedure as presented in a recent survey . to be consistent with the result of. the gain of ace in increasing the depth/breadth of reads/k-mers, compared to that of the best tool indepthnote: highlights indicate the level of improvement.compares the gain of ace to that of its best competitor among seven state-of-the-art read cleaners: bless, coral, hitec, musket, racer, sga and shrec; more detailed results can be found in supplementary tables s3s11. in these evaluations, depth of coverage indicates the average number of times each base is covered by reads/k-mers and breadth of coverage indicates the proportion of the genome covered by reads/k-mers . the first criterion is useful for quantitative applications and overlap-layout-consensus assembly, while the second is more applicable for de bruijn graph-based genome assembly. ace outperforms most other tools in terms of coverage depth gain, improving on the best competitor on 18 resp. 22 out of 22 datasets for reads resp. k-mers. in particular for miseq data, which contains more errors, the improvements can be significant. for coverage breadth, the picture is less clear: ace outperforms the best alternative tool on 13 datasets on read coverage breadth gain, whereas k-mer coverage breadth gain was generally worse. however, all tools actually yield low read coverage breadth on most miseq data (as low as 0.25) and decrease k-mer coverage breadth compared to the raw data (see supplementary tables s5s6, s9 s10).compares the time and memory consumption of ace to those of the three competitors which were able to successfully correct all datasets. while for most datasets memory consumption is reasonable, ace has higher computational cost than most other tools, trading speed for accuracy.we developed ace, a command-line tool to accurately correct substitution errors in illumina short-read archives. ace generally outperforms the best among seven state-of-the-art read cleaners in terms of coverage depth, at higher computational cost. this makes it a useful tool for small to medium-sized datasets or applications where accuracy requirements warrant the investment in computational resources. in future work, we aim to lower the runtime of ace by updating the k-mer trie instead of rebuilding it for each round of execution. this future version should also be able to handle indel errors to extend its application to all sequencing platforms.note: time is given in seconds and memory in megabytes, both per input mega base pair.  
