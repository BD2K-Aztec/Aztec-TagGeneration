sequence analysis bitpal: a bit-parallel, general integer-scoring sequence alignment algorithm motivation: mapping of high-throughput sequencing data and other bulk sequence comparison applications have motivated a search for high-efficiency sequence alignment algorithms. the bit-parallel approach represents individual cells in an alignment scoring matrix as bits in computer words and emulates the calculation of scores by a series of logic operations composed of and, or, xor, complement, shift and addition. bit-parallelism has been successfully applied to the longest common subsequence (lcs) and edit-distance problems, producing fast algorithms in practice. results: we have developed bitpal, a bit-parallel algorithm for general , integer-scoring global alignment. integer-scoring schemes assign integer weights for match, mismatch and insertion/deletion. the bitpal method uses structural properties in the relationship between adjacent scores in the scoring matrix to construct classes of efficient algorithms , each designed for a particular set of weights. in timed tests, we show that bitpal runs 725 times faster than a standard iterative algorithm. availability and implementation: source code is freely available for download at http://lobstah.bu.edu/bitpal/bitpal.html. bitpal is implemented in c and runs on all major operating systems.sequence alignment algorithms are critical tools in the analysis of biological sequence data including dna, rna and protein sequences. the demands placed on computational resources by high-throughput experiments require new, more efficient methodologies. while the standard algorithms of smith andand needleman andcalculate the score in each cell of the alignment scoring matrix sequentially, a newer technique called bit-parallelism partially overcomes score dependencies so that scores can be calculated in parallel to achieve much higher efficiencies. bit-parallel algorithms have been developed for exact and approximate string matching problems. early examples include the algorithms of baeza-yates and, which finds exact matches to a simple string pattern, and, which finds approximate matches to a string pattern or a regular expression, where the number of differences between the pattern and the text is at most k (counting single character substitutions and single character insertions and deletions or indels). the latter is implemented as the unix command agrep. additional k-differences examples include , which finds matches to limited expressions, i.e. regular expressions without kleene closure, , which finds matches to simple string patterns and emulates the dynamic programming solution used in alignment, and , which allows arbitrary integer weights for substitution of each pair of characters, insertion of each character and deletion of each character, and finds occurrences of regular expressions where the sum of the edit weights is at most k. in most k-differences algorithms, the complexity (and computing time) increases with increasing k. bit-parallel methods have been successfully applied to the longest common subsequence (lcs) problem , and to unit-cost edit-distance (hyyr o and) by modifications of myerss method (1999). these algorithms compute the alignment score, de-linking that computation from the traceback, which produces the final alignment. in the lcs scoring matrix, scores are monotonically non-decreasing in the rows and columns, and bit-parallel implementations use bits to represent the cells where an increase occurs. in edit-distance scoring, adjacent scores can differ by at most one, and the binary representation stores the locations of (two of the three) possible differences, +1, 1 and zero. these algorithms are ad hoc in their approach, relying on specific properties of the underlying problems, making it difficult to directly adapt them to other alignment scoring schemes. below, we present a bit-parallel method for similarity and distance based global alignment using general integer-scoring , allowing arbitrary integer weights for match, mismatch and indel. other approaches have been suggested byand bergeron and hamel (2002). the method ofis more flexible in scoring and applies to both simple patterns and regular expressions, but is much slower than our method in practice. our contribution is based on an observation of the regularity in the relationship between adjacent scores in the scoring matrix (section 2.1) and the design of an efficient series of bit operations to exploit that regularity (section 3). because every distinct choice of weights requires a different program, we show how to construct a class of efficient algorithms, each designed for a particular set of weights, and provide an online c code generator for users. to whom correspondence should be addressed. the author 2014. published by oxford university press. this is an open access article distributed under the terms of the creative commons attribution license (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.the complexity of our algorithms depends on the weights, not the ultimate score of the alignment. our method works for general alphabets, but our interest derives from frequent use of dna alignment when analyzing high-throughput sequencing data to detect genetic variation.the bitpal and bitpal packed algorithms outlined above can be extended in several ways. computers now in common usage have special 128 bit simd registers (single instruction, multiple data). using these, with the addition of several bookkeeping operations, would essentially double the efficiency and the speed of computation. another extension derives from the unexploited parallelism of the operations. there are no dependencies on prior computations after the v vectors in zone a are computed. this means that all the computations in zones b, c and d for v and all the subsequent computations for h can be done simultaneously, an ideal situation for the use of general purpose graphical processing units (gpgpu). another possible extension expands the types of scoring schemes allowed. blosum type scoring, which is useful for protein alignments, eliminates match and mismatch scoring and instead assigns different substitution weights to each pair of characters. affine-gap scoring replaces single character indel scoring with gap initiation and gap extension weights. extension to local alignment is also possible. this is a different class of problem in that the best final alignment score can occur in any cell of the alignment matrix. if all the cells have to be examined, then the time complexity shifts back to o(nm). hyyr o and navarro (2006) had some success with this problem using unit cost weights and identifying columns in which the score of at least one cell exceeds a predefined threshold k. the bitpal methods have already been used to accelerate software for detecting tandem repeat variants in high-throughput sequencing data and are well-suited to other dna sequence comparison tasks that involve computing many alignments. funding: this work was supported by the national science foundation (iis-1017621 to g.b., dge-0654108 to j.l. and y.h.).  
