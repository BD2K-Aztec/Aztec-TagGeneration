genome puzzle master (gpm): an integrated pipeline for building and editing pseudomolecules from fragmented sequences motivation: next generation sequencing technologies have revolutionized our ability to rapidly and affordably generate vast quantities of sequence data. once generated, raw sequences are assembled into contigs or scaffolds. however, these assemblies are mostly fragmented and inaccurate at the whole genome scale, largely due to the inability to integrate additional informative datasets (e.g. physical, optical and genetic maps). to address this problem, we developed a semi-automated software toolgenome puzzle master (gpm)that enables the integration of additional genomic signposts to edit and build new-gen-assemblies that result in high-quality an-notation-ready pseudomolecules. results: with gpm, loaded datasets can be connected to each other via their logical relationships which accomplishes tasks to group, merge, order and orient sequences in a draft assembly. manual editing can also be performed with a user-friendly graphical interface. final pseudomole-cules reflect a users total data package and are available for long-term project management. gpm is a web-based pipeline and an important part of a laboratory information management system (lims) which can be easily deployed on local servers for any genome research laboratory. availability and implementation: the gpm (with lims) package is available at https://github.com/ jianwei-zhang/lims contacts:illumina and pacbio smrt sequencing technologies are the two most widely accepted sequencing platforms currently used for large scale genomics-driven data generation. illumina, representing the most widely used second-generation sequencing technology, produces short reads (35150 base read lengths), that are highly accurate, with base call outputs that can yield hundreds of millions of bases from a single lane over several days (depending upon complexity) . pacbio produces hundreds of thousands of long-read error-corrected sequences (up to 20 kb average read lengths) that can be produced in 36 h per smrt cell. data generated by either platform can be used independently, or in combination, to successfully assemble genomes de novo . many assemblers have been developed to assemble raw sequence reads into sequence contigs (i.e. minimum sequence units for an assembly), such as soapdenovo , allpaths , hgap , or falcon (https://github.com/pacificbiosciences/falcon-integrate). a few programs or packages (e.g. bambus, abacas, mauve aligner, allmaps, etc.) are also available for scaffolding contigs . however, software tools that can be used to inspect/edit ngs sequence assemblies, as well as integrate other evidence types (i.e. physical and genetics maps) to produce an assembly that more accurately and completely reflects the native structure of a given genome, are currently lacking. to analyze, manage and incorporate genome datasets for diverse sequencing projects, such as pseudomolecule construction for the maize and several wild oryza genome sequencing projects (schnable et al., 2009; j. stein et al., submitted for publication;), we developed a software tool called genome puzzle master (gpm). gpm does not require sophisticated bioinformatics skills or support, and the final products are ready to use in the form of annotation-ready pseudomolecules. gpm can also facilitate the incorporation of additional datasets as new refinements are generated. here we make gpm available to researchers who have ngs genome assemblies and other unlinked genomic datasets, and are struggling to generate annotation-ready or submission-ready pseudomolecules.of the gpm pipeline to assemble two high-quality reference genome sequences for indica rice: a case study recently, our consortia published two high-quality reference genome sequences for the two main varietal groups of indica rice zhenshan 97 (zs97) and minghui 63 (mh63) . these genomes were primarily sequenced using pacbio long-read sequencing of minimum tiling path bac pools, combined with illumina wgs assembled contigs to fill gaps. once individual bac sequences were assembled they were loaded into gpm for assembly editing and pseudomolecule construction. following is a summary of how these data were used to assemble two of the highest quality indica rice genome assemblies produced to date: to assemble the zs97 and mh63 genomes, the following datasets were loaded in to gpm: (i) whole genome profiling (wgp, van) sequence-based pms for each genome; and (ii) 5363 assembled bac sequences (including duplicates for the same bac clones sequenced in multiple jobs or pools) from 188 hgap jobs for zs97, and 6,801 from 313 jobs for mh63. here we take zs97 as an example to demonstrate the assembly procedure once these data were loaded (supplementary). to start a new assembly, we set the fpc: zs97 v.1 pm as the physical reference and the irgsp-msu (i.e. o.sativa subsp. japonica cv. nipponbare genome sequence,) as the reference genome. we checked assign chromosome number for contigs and orient contigs based-on reference genome since both zs97 and nipponbare belong to the same genus and species (i.e. o.sativa), and minor differences between the to-be-assembled and reference genomes would not mislead the results because they are so closely related. seq-toseq alignment was used to pre-build all possible overlapping relationships among all bac sequences since it was expected that those should be connected. seq-to-genome alignment was also used to map all bac sequences to the reference genome. we also utilized the end-to-end merge, auto-orient sequences and filter redundant sequences and overlaps options. (note: a similar process was used to assemble the mh63 genome, except we used the fpc: mh63 v.1 pm as the physical reference.) after manual checking, editing and removing redundancies, the final assembly products yielded 318 (zs97, composed of 3862 assemblyseqs) and 216 (mh63, composed of 3256 assemblyseqs) assemblyctgs that were ordered, oriented, and assigned to their appropriate chromosomes. the assemblyctg sequences were used as the primary frameworks to build pseudomolecules after gap-filling sequences were integrated during the second round of gpm assembly .gpm is an integrated pipeline for generating and editing pseudomolecules from existing next gen sequence assembles using evidencebased guides such as reference sequences, physical maps, genetic maps and paired bess. we demonstrated how gpm can be used to generate high-quality submission-ready pseudomolecules for two indica rice accessions, zs97 and mh63, by the integration of bac-based physical maps and reference sequence guides. to perform an assembly with gpm, not all the resources like those used for zs97 and mh63 are required, but gpm does require at least one guide type (e.g. genetic, physical or genome reference). since gpm does not reassemble sequence data from the original short/long reads, the kind and quality of the evidence-based guides will greatly affect the amount of time required for editing and will impact the final quality of an assembly. using a reference genome in a gpm assembly is quite valuable, however, the utilization of more evidence guides can greatly enhance the ability to build high-quality pseudomolecules and to avoid the overuse of the reference sequences in conforming a gpm assembly to mimic a refseq. if a reference genome is the only evidence to guide an assembly, then reference sequence overuse mistakes cant be avoided. however, using other information that is available could detect overuse errors which would be corrected during a manual check step (which is not labor-intensive and strongly recommended) with gpm. hence, evidence data are key factors used to build high-quality gpm assemblies. in the current version of our lims, we can track each processing step from bac library construction to the final genome assembly seamlessly during the entire phase of a sequencing project. bac library resources and wet lab sequencing runs are recorded in our system. as a part of the lims, gpm supports fasta-formatted sequences. however, the ability to deal with raw reads has been limited due to their huge data size. some additional features, such as paired end/mate and mtp information, are partially adapted for assembly manipulation in the current version of gpm. pseudomolecules in fasta format with an agp file can be generated as the final output for further downstream analysis and public repository sequence submissions (e.g. genbank).(a) gpm assemblyctg view of a 500-kb region. assemblyseqs, top and bottom, are shown as overlapping (yellow) and fully redundant assemblyseqs are gray. the retained (green) and removed (gray) portions of assemblyseqs are indicated. (b) chromosome-scale view of a 500-kb region that compares two genome assemblies to a reference sequence. the reference sequence is shown in the middle (bright green) with alignments (yellow) to each assemblyctg (violet) at the top and bottom. the assemblyctg order can be changed by drag-and-dropthe lims can be expanded to integrate new functions for a specific project as needed. for example, we built a pipeline called posthgap to perform circularization and identification of bac sequences for the two rice genome sequencing projects described above . as reported in our data descriptor , we used a map-based bac-pool sequencing strategy to produce sequence data that were assembled into a set of sequences (termed unitigs by hgap) for each pool. we were able to process the output of each corresponding hgap job to circularize and identify bac sequences properly using related data information in the lims as follows: (i) posthgap first filtered unitigs with lengths shorter than 10 kb, then (ii) trimmed vectors and circularized plasmid or bac sequences according to pairs of sequences at specific breakpoints and (iii) assigned bac ids to each sequence according to wgp tags or bes information. during the posthgap processing step, two parameters (default: minoverlap 500 bp, overlapidentity 95) could be set for sequence circularization and four optional parameters (default: minclonetagnumber 5, tagmatchidentity 100, tagmatchpercent 80, besmatchidentity 98 if no wgp tags available) for bac id assignment. the program blastn (ncbi blast 2.2.29) was used to perform sequence comparison and alignment analysis in posthgap. as a result, a total of 501 hgap jobs (multiple runs for the same pool count multiple times) for 375 pools were run through posthgap in this study and produced 12 164 bac-id-ready sequences (including duplicates for the same bac processed in multiple jobs or pools) for both zs97 and mh63. all bac-id-ready sequences were seamlessly converted as input datasets for both gpm assemblies. technically, the use of a one-main-table database schema design may simplify query processing. however, one possible disadvantage for this schema is that the response time to query might be longer with increasing amounts of data. based upon our lims structure, we used the new container option for less complicated data and created new tables for large datasets (e.g. clones). to date, we are able to operate gpm smoothly on a 4 12-core cluster with more than 1.7 million data records. these kinds of strategies are recommended for other users. we can provide free host services to academic projects of medium-size genomes (up to 1 gb) with full technical support. several wgs scaffolding packages (e.g. bambus, mauve aligner, abacas, allmaps, etc.) treat assembled contig sequences as nonoverlapping and single-copy sequences. unfortunately, these packages are not focused toward the handling of inherent sequence redundancies and are not programmed to produce incremental assemblies. further, these scaffolding tools are all file-based and do not provide a flexible process for manual checking and editing, especially if the input data has been modified or updated. in contrast, gpm is a relationship-based pipeline, which has the flexibility to edit and visualize assembled data, not only by showing the order and orientation of contig sequences and sequence redundancies but also by displaying the necessary guide information for easy user confirmation. one thing gpm cannot do is to assemble a genome de novo from raw reads. this deficit can be compensated for by its ability to import results (sequences and agps) from other assembly programs to guide new and improved assemblies. the final quality of a gpm assembly relies heavily on the quality and richness of the guide information used. for example, if a draft genome assembly is used as the guide rather than a map-based bac-by-bac assembly, the quality of the gpm assembly will suffer. dna sequencing technologies and assembly programs change rapidly, and the gpm pipeline presented here is no exception. we will continue to improve the interactive functionalities of gpm, as well as integrate additional tools to support more data types. with gpm, data types are seamlessly linked and logically integrated into an encompassing lims for all genomic data. gpm is an open source software dynamically developed for the genomics research community and can be extensively adapted/improved by different research groups for their own applications.  
