data and text mining ptmtreesearch: a novel two-stage tree-search algorithm with pruning rules for the identification of post-translational modification of proteins in ms/ms spectra motivation: tandem mass spectrometry has become a standard tool for identifying post-translational modifications (ptms) of proteins. algorithmic searches for ptms from tandem mass spectrum data (ms/ms) tend to be hampered by noisy data as well as by a combina-torial explosion of search space. this leads to high uncertainty and long search-execution times. results: to address this issue, we present ptmtreesearch, a new algorithm that uses a large database of known ptms to identify ptms from ms/ms data. for a given peptide sequence, ptmtreesearch builds a computational tree wherein each path from the root to the leaves is labeled with the amino acids of a peptide sequence. branches then represent ptms. various empirical tree pruning rules have been designed to decrease the search-execution time by eliminating biologically unlikely solutions. ptmtreesearch first identifies a relatively small set of high confidence ptm types, and in a second stage, performs a more exhaustive search on this restricted set using relaxed search parameter settings. an analysis of experimental data shows that using the same criteria for false discovery, ptmtreesearch annotates more peptides than the current state-of-the-art methods and ptm identification algorithms, and achieves this at roughly the same execution time. ptmtreesearch is implemented as a plugable scoring function in the x!tandem search engine. availability: the source code of ptmtreesearch and a demo server application can be found at http://net.icgeb.org/ptmtreesearch.mass spectrometry is now the de facto method used for protein identification in complex biological samples. subsequent computational analysis of data from even a single sample may be intense and involve the application of a long pipeline of various algorithms to reveal protein identification and structure. (for reviews see) difficulties arise when unexpected or missed cleavages, point mutations and post-translational and chemical modifications need to be considered in the analysis, since the inclusion of these structural features of proteins can lead to the combinatorial explosion of the search space. this can lead to increases in search-execution time, decreases in the significance of hits, and increases in the number of false assignments. a solution to this problem involves application of a so-called two-round-search (often termed error-tolerant search) applied extensively in x!tandem and mascot . the first round of this strategy uses clean, i.e. unmodified peptides to identify proteins, and then in a second round of analysis, a more exhaustive search is used to identify modified peptides. this principle assumes that at least one high-quality unmodified peptide is present in the sample under analysis. identification of post-translational modifications of proteins (ptms) is an especially difficult task. on average, human proteins are thought to carry about three ptms per molecule . however, 51 of the proteins in the uniprotkb/swiss-prot databases are annotated with ptms , meaning significant variations from this estimate may exist. the current list of known ptms is 4500, and they can be found in various lookup tables (ptmdbs, ptm databases). a good example is the resid database of protein modifications . a ptm carried on a peptide alters the molecular weight of the peptide and the corresponding fragment ions and results in a shift within the mass spectrum fragment ion series. we term this shift a gap. a ptm search can then be formalized as follows: given a theoretical and an experimental spectrum, to whom correspondence should be addressed. insert one or more gaps into the theoretical spectrum such that it maximizes the number of the overlapping peaks or other scoring functions. the main challenge for the ptm-search algorithms is then to find such gaps that can be interpreted as ptms in the ms/ms data, while keeping the execution time and the false discovery rate (fdr) low . ptm-search algorithms can be categorized into three large groups: targeted, untargeted and de novo ptm-search methods (for a review see). in the case of targeted ptm searches, the user/experimenter has to specify the ptms that may be present in the sample as an input parameter to the search program and these parameters will then be used to calculate the gaps. for instance, x!tandem considers one type of ptm per amino acid. however, this results in a combinatorial explosion of the search space that increases the execution time and often reduces the significance of the hits. for example, a partial (incomplete) modification, such as phosphorylation of serine would result in a mass shift of $80 da at serine residues and would effectively double the number of serine-containing peptides. this is because each serine residue would have to be annotated with and without the mass shift due to phosphorylation. untargeted ptm searches do not require the user to specify expected ptms but instead use heuristic search algorithms to find modifications on the basis of a database of known ptms. resid is one such database that can be used in this type of search. for instance, the algorithm pilot_ptm (prediction via integer linear optimization and tandem mass spectrometry) uses a binary integer optimization model to find ptms that best match the experimental data under analysis . modi identifies shortsequence tags (35-amino acid long) and fills gaps between tags with amino acids that are unmodified or modified by ptms. ptmsearchplus uses further information obtained from accurate intact protein mass to identify ptms in ms/ms data. de novo ptm-search algorithms (also called unrestricted ptm searches or blind searches) do not use a priori information about modifications making it possible to discover novel, previously never reported, modifications. in general, a theoretical spectrum of a peptide sequence is aligned to an experimental spectrum, allowing placement of one or a few gaps in one way or another. these gaps are then reported as putative ptms. to explain this in more detail, let denote the mass difference between the precursor mass of the experimental spectrum and the parent mass of the theoretical peptide. some methods have a restriction on gaps, such as the number of the gaps or the sum of the inserted gaps must be . ms-alignment uses a dynamic programming approach to calculate the best alignment. a similar method has been proposed by , but in this case does not take into account during the alignment calculation. p-mod , ptmap and pmatch place of each amino acid on the theoretical peptide and matches it to the experimental spectrum iteratively. in a similar manner, twinpeaks and deltamt calculate the location of the ptm but twinpeaks shifts the theoretical peptide over a wide range and derives the ptm mass from the shift providing the highest score. deltamt meanwhile assumes that both modified and unmodified versions of the peptides are present in the sample and looks for frequent occurrences of the retention time and parent ion-mass difference between spectral pairs. high concentration of such pairs is assumed to represent modification groups in the sample. opensea , in a similar manner to mod i , identifies shortsequence tags from the spectrum but fills the gaps between tags without using a ptmdb. sims meanwhile interprets pairs of product ion peaks, which represent potential amino acid residues or intervals, as a means of mapping ptms. the de novo ptm identification algorithms often misplace ptms on the amino acid sequence or require other corrections to improve accuracy. ptmclust and ptmfinder have been designed to improve the quality of ptm assignments obtained with de novo ptm identification. building a prefix tree from theoretical peptide sequences constitutes a different kind of approach wherein the problem of ptm identification is reduced to tree traversal . for a peptide sequence p 1. .. p n of length n, a prefix tree structure can be built wherein the nodes at the i-th level of the tree are labeled with the amino acid p i and each branch represents different modifications on p i taken from a ptmdb. at each node, the corresponding theoretical fragment ion masses are calculated and matched to the experimental spectrum, providing a score for the given node. leaves that have gathered modifications on the path from the root and add up to the parent mass difference are considered feasible solutions. the problem with this approach is the trees size: a complete traversal is too time-consuming for practical application. a greedy traversal heuristic has previously been proposed that traverses only a fraction of the full search space thus reducing running times to a manageable level . however, greedy algorithms may fail to find the best solution and report false annotations. instead of developing more sophisticated tree traversal algorithms for this problem, we decided to develop treepruning rules to eliminate unlikely modifications and reduce the search space. in this article we present a novel method, called ptmtreesearch, which is designed to identify modifications in experimental spectra using a ptmdb. ptmtreesearch is executed in two rounds. using strict tree-pruning rules, the first round of search is aimed at identifying a restricted set of ptm types with high confidence. the second round uses this restricted set of ptm types but runs with relaxed tree-pruning rules so as to identify more modified spectra. to the best of our knowledge, this method is the first that applies a two-stage-search approach to ptm identification. this idea is analogous to the two round peptide identification strategy used by x!tandem and mascot, where the first round is used to reduce the search space to likely solutions followed by an error-tolerant, more exhaustive search in the second round. the rest of this article is structured as follows: section 2 presents the ptmtreesearch algorithm along with the tree pruning techniques applied; section 3 describes the datasets and methods used and section 4 presents and discusses the results. finally, section 5 concludes our findings and outlines further work. let l a be a list of modification masses (measured in daltons) for the amino acid a and n a jl a j denote the number of the elements in the list (0.0 da is always included and represents no modification). a modification mass is the mass difference that the amino acid gains or losses due to the molecular modification. for example l c /0.0, 17.0265, 47.9847, 57.0215, 71.0371,. .. , / means the amino acid cysteine can be (i) unmodified, (ii) lose 17.0265 da (via losing ammonia from cysteine), (iii) gain 47.9847 da (via complete oxidation), (iv) gain 57.0215 da (via carbamidomethylation) and (v) gain 71.0371 da (via propionamide), and so on. the molecular mass of cysteine is 121.16 da and becomes 178.1815 da after carbamidomethylation. note that one particular amino acid molecule is not modified with more than one modification at the same time, but an amino acid can be modified with various modifications at different occurrences in the peptide sequence (and in different peptides as well). let q be an experimental spectrum represented as a list of locationintensity peak pairs, p a 1 a 2. .. a n be a peptide sequence, pm(q) and pm(p) denote the precursor mass of q and p, respectively, and pm(q) pm(p). the basic idea is to generate the theoretical fragment ion peaks for all modified variations of peptide p and store them in a prefix tree, where a branch at the level i denotes a ptm on amino acid a i. a tree node at the level i contains a structure v hs, b, y, m, ci, where s is a score that quantifies the comparison of the peptide part a 1. .. a i to the experimental spectrum. then c is the number and m is the sum of the mass of the acquired modifications in the sequence a 1. .. a i. the variables b and y store the masses (m/z) of the b-and y-fragment ions that correspond to the (a 1. .. a i ) m and (a i1. .. a n ) m fragment ions, respectively. now we recursively define the tree and the values stored in the node structures as follows: the root node is h0, 0, pm(q), 0, 0i at level 0. if v hs, b, y, m, ci is a node in the tree at the level i (0 i5n), then the node v j hs h, b m ai1 m j , y m ai1 m j , m m j , c 0 i is a child of the node v at level i 1, where m ai1 is the mass of the amino acid a i1 , m j is the j-th modification in the list l ai1 , h is the sum of the intensities of the experimental peaks that matches to the theoretical peaks b m ai1 m j and y m ai1 m j within the small ion match tolerance, c 0 c 1 if m j 6 0, otherwise c 0 c (that is c 0 counts the ptms on the a 1. .. a i1 fragment).the node v j at level i 1 represents that the amino acid a i1 in the peptide p is modified with the j-th modification from l ai1. if v is a node at level n then v is a leaf node. a leaf l hs, b, y, m, ci is called a feasible solution if m (up to a small precursor mass tolerance); that is the mass of the peptide with the acquired modification masses is equal to the precursor mass of the query spectrum. note that h can be calculated in an efficient way by storing the peaks of the experimental spectrum in an ordered list ordered by the peaks m/z locations. the score of the spectrum q and peptide p comparison is the maximum score of the feasible solutions, if there is any, otherwise null is returned. this goal can be found with any kind of tree traversal method depthfirst traversal algorithms are a good example in this case. the modifications on the peptide can then be extracted from the path between the root and the best goal leaf. note that all nodes at level i correspond to the i-th amino acids in peptide p, and all have the same n ai number of children. hence, the tree is balanced and all leaves have the same depth. this gives the size of the search space:which makes the time complexity of the traversal algorithm impractical. note also that the size of the search space does not depend on the experimental spectrum. in the next subsection we define pruning techniques in order to maintain the run time polynomial and make it appropriate for real applications. an example computational tree is given in.  
