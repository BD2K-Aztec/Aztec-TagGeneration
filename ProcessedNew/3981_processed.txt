sequence analysis reptile: representative tiling for short read error correction motivation: error correction is critical to the success of next-generation sequencing applications, such as resequencing and de novo genome sequencing. it is especially important for high-throughput short-read sequencing, where reads are much shorter and more abundant, and errors more frequent than in traditional sanger sequencing. processing massive numbers of short reads with existing error correction methods is both compute and memory intensive, yet the results are far from satisfactory when applied to real datasets. results: we present a novel approach, termed reptile, for error correction in short-read data from next-generation sequencing. reptile works with the spectrum of k-mers from the input reads, and corrects errors by simultaneously examining: (i) hamming distance-based correction possibilities for potentially erroneous k-mers; and (ii) neighboring k-mers from the same read for correct contextual information. by not needing to store input data, reptile has the favorable property that it can handle data that does not fit in main memory. in addition to sequence data, reptile can make use of available quality score information. our experiments show that reptile outperforms previous methods in the percentage of errors removed from the data and the accuracy in true base assignment. in addition, a significant reduction in run time and memory usage have been achieved compared with previous methods, making it more practical for short-read error correction when sampling larger genomes. availability: reptile is implemented in c++ and is available through the link: http://aluru-sun.high-throughput sequencing is profoundly changing the way genetics data are collected, stored and processed . the advantages of the new technology have led to revitalization of old techniques and discovery of novel uses, with growing applications in resequencing, de novo genome assembly, metagenomics and beyond . new technology inevitably comes with challenges. for many next-generation sequencers, the advantage of deeper and cheaper to whom correspondence should be addressed. coverage comes at the cost of shorter reads with higher error rates compared with the sanger sequencing they replace. genome assembly, the de novo inference of a genome without the aid of a reference genome, is challenging. sanger reads, typically 7001000 bp in length, are long enough for overlaps to be reliable indicators of genomic co-location, which are used in the overlap-layout-consensus approach for genome assembly. however, this approach does poorly with the much shorter reads of many next-generation sequencing platforms (e.g. 35100 bp for illumina genome analyzer ii). in this context, de bruijn graph and string graph based formulations that reconstruct the genome as a path in a graph perform better due to their more global analysis and ability to naturally accommodate paired read information. as a result, they have become de facto models for building short-read genome assemblers, e.g. allpaths , velvet , abyss and yaga . error correction has long been recognized as a critical and difficult part of these graph-based assemblers. it also has significant impact in other next-generation sequencing applications such as resequencing. we give a brief review of several well-known error correction methods. alignment-based error correction methods, such as mised for sanger reads, require refined multiple read alignments and assume unusually isolated bases to be read errors. like the sanger-motivated assembly algorithms, these approaches do not adapt well to short reads. hence,proposed the spectral alignment problem (sap): in a given dataset, a kmer is considered solid if its multiplicity exceeds a threshold, and insolid otherwise. reads containing insolid kmers are corrected using a minimum number of edit operations so that they contain only solid kmers post-correction. similar approaches have been adapted and used by others . to overcome the typically long run times of sap-based approaches,proposed shrec, a method based on a generalized suffix tree constructed from short-read data using both forward and reverse complementary strands. shrec compares the multiplicity of a substring, represented by a node in the suffix tree, with its expected frequency of occurrence calculated analytically, assuming uniform sampling of the genome and uniformly distributed sequencing errors. the nodes with observed counts that deviate beyond a tolerable threshold from their expected values are considered erroneous. an erroneous node is corrected to a sibling when applicable, and all its descendants are transferred to the selected sibling. well-engineered code is necessary to cope with the largepage: 2527 25262533we evaluated reptile on several illumina/solexa datasets and compared the results with shrec version 2.0, a recent high-quality short-read error correction method that is itself shown to give superior results over prior k-spectrum approaches. we omitted evaluation on simulated data because simulations with random errors or synthetic genomes do not accurately reflect actual short-read sequencing errors , and could even be misleading. our test datasets are illuminagenerated short reads of well-characterized, sanger assembled bacterial genomes. knowledge of the genomes is needed for determining the accuracy of the error correction methods. the six experimental datasets, downloaded from the sequence read archive at ncbi, are listed in. datasets d1 (accession number: srx000429), d2 (srr001665_1), d5 (srr022918_1) and d6 (srr034509_1) are illumina reads from the e.coli str. k-12 substr (nc_000913) genome (4.64 mbp); datasets d3 (srr006332) and d4 are illumina reads from the acinetobacter sp. adp1 (nc_005966) genome (3.6 mb). the first four datasets are generated by solexa 1g genome analyzer, where each read has the same length 36 bp. the latter two datasets are generated using the more recent illumina genome analyzer ii, with read lengths of 47 bp in d5 and 101 bp in d6. d1 has high coverage and low error rate. d2 has typical coverage and low error rate. d3 has high coverage and high error rate. d4 is derived from d3 by randomly selecting short reads amounting to 40 coverage. this is done for evaluating performance on a low coverage, high error rate dataset. both d5 and d6 have higher error rates. in addition, 13.9 of the reads in d6 contain ambiguous nucleotides, denoted by character n. since shrec cannot process non-acgt characters, we eliminated all reads with ambiguous bases, even though reptile has no such limitation. the number of discarded reads is indicated in column 5,. similar to, we evaluated error correction results with the aid of rmap (v2.05) , which maps short reads to a known genome by minimizing mismatches. we allowed up to five mismatches per read in the first four datasets page: 2531 25262533error rate is estimated by mapping the reads to the corresponding genome using rmap, and finding mismatches based on uniquely mapped reads.and allowed up to 10 mismatches (default value of rmap) in d5 and fifteen mismatches in d6 since the reads are longer in the latter two datasets. reads that could not be mapped to the genome, or that map to multiple locations, are discarded. the mismatches between uniquely mapped reads and the genome are considered read errors. quality of the datasets varied as shown in, with the percentage of reads that are uniquely mapped ranging from 62.5 to 96.7. the large percentage of unmappable reads, the higher error rates as well as the large percentage of reads with ambiguous bases indicate that d5 and d6 have lower quality than d1 to d4. since the goal of error correction is to identify and correct each erroneous nucleotide, we assess the quality of error correction at the base level. a true positive (tp) is any erroneous base that is changed to the true base, a false positive (fp) is any true base changed wrongly, a true negative (tn) is any true base left unchanged, and a false negative (fn) is any erroneous base left unchanged. then sensitivity = tp/(tp + fn) and specificity = tn/(tn + fp). note that these definitions are different from those used by, which target read-level error detection (whether a read is flagged as containing an error or not). this is a less stringent measure because any read containing errors was classified as tp provided at least one of its errors was detected and irrespective of whether they were accurately corrected or not. we propose two additional measures for assessing the quality of error correction: @bullet erroneous base assignment (eba): let n e denote the number of erroneous bases that are correctly identified but changed to a wrong base. then, eba = n e /(tp+n e ) reflects how well we are able to correct an erroneous base to the true base after a sequencing error has been identified. a lower value of eba indicates a more accurate base assignment. @bullet gain: (tp fp)/(tp + fn). this measures the percentage of errors effectively removed from the dataset, which is equivalent to the number of errors before correction minus the number of errors after correction divided by the number of errors before correction. clearly, gain should approach one for the best methods, but may be negative for methods that actually introduce more errors than they correct.the proposed error correction algorithm is conservative because it avoids changing bases unless there is a compelling underrepresentation of a tile compared with its d-mutant tiles. actual errors in read r cannot be corrected if r occurs in a very low coverage region of the genome or there exist multiple candidate d-mutant tiles, probably because of genome repetition. on the other hand, a tile may be miscorrected if it contains a minor variant of a highly repetitive element in the genome or it traverses a low coverage region that is similar to other regions with normal coverage. our method is not unique in being challenged by non-uniform coverage on repetitive genomes. error correction for highly repetitive genomes is essential for successfully assembling larger eukaryotic genomes but none of the existing methods successfully addresses this problem, including reptile. short-read mapping provides a reasonable method to evaluate error correction methods in well-assembled, low repetition genomes. nevertheless, it is not possible to unambiguously determine all errors. there are natural polymorphisms among bacterial lines, and some presumed polymorphisms may be unrecognized assembly errors. furthermore, the mapping software chooses among alternative mappings by invoking parsimony, but there is some chance that the true number of errors is less than the minimum. lastly, mapping software cannot map reads that contain more than a constant number of substitutions, typically just two, with full sensitivity, although we considered 5 here and tested as many as 15 with similar results. despite these limitations, we believe that most errors are correctly identified, and this approach can provide a fair comparison of error correction methods. we and others have found that sequence quality scores provide valuable information. our use of quality scores probably helped us account for the error patterns in nextgeneration sequencing data without explicitly modeling them. however, it has been observed that high quality scores may be too optimistic and low quality scores too pessimistic in estimating sequencing errors in solexa data. since quality scores may not be precise measures of misread probabilities, the current version of reptile uses quality score information in a very simple manner, but can be modified to make more sophisticated use of quality scores if warranted. finally, although quality scores are needed to run reptile, it can be run effectively without scores by setting all quality scores and the threshold q c to the same value. there remain several additional challenges in next-generation sequencing error correction. one challenge is to distinguish errors from polymorphisms, for example, single nucleotide polymorphisms (snps). reptile could accommodate snp prediction with modification in the tile correction stage (algorithm 1), where ambiguities may indicate polymorphisms. another challenge is the growing read length of upcoming high-throughput sequencers. currently, we define tiles as concatenations of two kmers. it might prove useful to extend the tile definition to more than two kmers in order to address error correction in much longer reads.  
