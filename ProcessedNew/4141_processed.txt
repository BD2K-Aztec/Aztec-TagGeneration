genome analysis scarpa: scaffolding reads with practical algorithms motivation: scaffolding is the process of ordering and orienting con-tigs produced during genome assembly. accurate scaffolding is essential for finishing draft assemblies, as it facilitates the costly and laborious procedures needed to fill in the gaps between contigs. conventional formulations of the scaffolding problem are intractable, and most scaffolding programs rely on heuristic or approximate solutions , with potentially exponential running time. results: we present scarpa, a novel scaffolder, which combines fixed-parameter tractable and bounded algorithms with linear programming to produce near-optimal scaffolds. we test scarpa on real datasets in addition to a simulated diploid genome and compare its performance with several state-of-the-art scaffolders. we show that scarpa produces longer or similar length scaffolds that are highly accurate compared with other scaffolders. scarpa is also capable of detecting misassembled contigs and reports them during scaffolding. availability: scarpa is open source and available from http://compwhile assemblers developed for high-throughput sequencing (hts) platforms can produce high-quality draft assemblies for the genomes of bacteria and viruses, de novo assemblies of more complex genomes using short reads are typically fragmented. this fragmentation can be partially alleviated through scaffolding: the process of linking contigs into longer sequences (possibly with gaps) using paired read information. scaffolding not only improves the contiguity of the initial assembly, but is also helpful for designing experiments for finishing of the genome through additional sequencing of selected regions with lower-throughput technology, such as sanger. although many genome assemblers produce scaffolds using paired reads during the assembly process , the problems of building contigs and scaffolding them are distinct. a scaffolder takes as input a set of assembled contigs and a set of paired reads. the relative orientation of two paired reads and the approximate distance between them are known. thus, if the two reads can be unambiguously mapped to different contigs, we can identify the relative ordering and the distance between these contigs. owing to errors in the read pair data (e.g. chimeric pairs) and in the assembly (e.g. misassembled contigs), the ordering achieved from different read pairs can be contradictory. consequently, the scaffolding problem is often defined as finding an ordering on the contigs that maximizes the number of supporting read pairs. computationally, this formulation is np-hard , leading most scaffolding approaches to use heuristic algorithms with no provable guarantees. some scaffolders greedily link contigs by considering them in order of strongest paired read support or largest contig length , while rejecting links that contradict those already chosen. alternatively, the scaffolding problem is often represented as a graph, where nodes denote contigs and edges denote paired read links. sopra partitions this graph into smaller parts and solves the scaffolding problem in each subgraph using statistical optimization. mip scaffolder partitions the graph in a similar way; however, it solves the problem for each subgraph exactly using mixed integer programming. to keep the algorithms tractable, both of these scaffolders limit the sizes of the subgraphs. opera applies an alternate partitioning scheme using a graph contraction procedure and solves the scaffolding problem with a fixed-parameter tractable algorithm based on a graph-bandwidth formulation. these approaches to scaffolding attempt to maximize the number of paired reads that are satisfied, implicitly assuming that paired read links are noisy and the contigs are error-free. however, in larger and more complex genomes, the assembled contigs may well have misassemblies. in this article, we present a novel method that combines several practical algorithms for the scaffolding problem. our approach assumes that both erroneous read pairs and contigs are possible, allowing us to detect misassembled contigs and remove these from the scaffolds. this formulation of the problem allows for an algorithm with practical time and memory requirements, while providing an exact solution of bounded error. this algorithm is implemented within scarpa, a stand-alone scaffolder for hts data. we have tested scarpa on real datasets as well as on a simulated diploid genome, and show that it builds highly accurate and longer scaffolds compared with several state-ofthe-art scaffolders.scaffolding improves the contiguity of an assembly and facilitates the finishing of a genome by establishing an order and orientation of contigs. in this article, we have presented scarpa, a novel scaffolder for hts data that combines graph algorithms with lp. using simulated and real datasets, we show that scarpa produces as long or longer scaffolds than the current state-of-the-art tools, while at the same time achieving high accuracy.note: for g.clavigera, the size of the available draft sequence is given in place of the genome size. for the assemblathon1 dataset, the genome size is given as an average of the haploid reference sequences. a novel feature of scarpa is the ability to detect misassembled contigs. although this procedure may produce false positives, scarpa reports only a few such contigs per dataset, which can be manually investigated if necessary. for instance, scarpa discards no contigs in the g.clavigera and assemblathon1 datasets and only three contigs in the e.coli dataset, two of which are indeed found to be erroneous.we also show that scarpa has favorable running time on these datasets, although it is slightly slower than sspace. in addition, scarpa has a small memory footprint, requiring 52 gb on the assemblathon1 dataset. within scarpa, the most time-consuming step is the contig orientation task. while we believe our method typically produces more accurate scaffolds compared with greedy-or heuristicbased approach and has the advantage of detecting misassemblies, it can be computationally expensive for large and complex genomes. on the other hand, the fixed-parameter tractable algorithm we use is suitable for parallel computation. although our current implementation is single-threaded, we plan to explore this direction in a future version.note: mapping is performed using bowtie with 16 threads, and mapping time is included for all scaffolders. for information, the total wall-clock time taken by bowtie to index the reference and write read mappings in sam format is also reported.  
