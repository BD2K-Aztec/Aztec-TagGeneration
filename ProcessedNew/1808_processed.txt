fermikit: assembly-based variant calling for illumina resequencing data fermikit is a variant calling pipeline for illumina whole-genome germline data. it de novo assembles short reads and then maps the assembly against a reference genome to call snps, short insertions/deletions and structural variations. fermikit takes about one day to assemble 30-fold human whole-genome data on a modern 16-core server with 85 gb ram at the peak, and calls variants in half an hour to an accuracy comparable to the current practice. fermikit assembly is a reduced representation of raw data while retaining most of the original information. availability and implementation: https://github.com/lh3/fermikit contact: hengli@broadinstitute.orgdeep resequencing of a human sample typically results in a bam file of 60100 gb in size. storing, distributing and processing many such huge files is becoming a burden for sequencing facilities and research labs. while better compression helps to alleviate this issue, it adds processing time and can barely halve the size, which does not keep up with the rapidly increasing sequencing throughput. illumina and gatk use gvcf as a reduced representation of raw data. however, gvcf is reference dependent and it is nontrivial to encode both large and small variants consistently. we still need to go back to raw data for long events and when upgrading the reference genome. another idea from the past practice is to assemble sequence reads into contigs that ideally retains all information in the raw data, but whether this approach is practical to illumina human resequencing remains to be confirmed.we have run fermikit on multiple whole-genome datasets of sample na12878 along with gatk-haplotypecaller (hc in brief) and freebayes . we used genome-in-abottle (giab;) as truth data to evaluate the accuracy . recent illumina data have excessive systematic errors around poly-a which hc does not handle well. it called over 4000 false indels from sample s1 and s4 with the vast majority around poly-a. we excluded these regions to avoid one simple error source greatly affecting the metrics. after this treatment, variant callers are broadly comparable when the same set of hard filters are applied. vqsr as is advised in gatk best practice does not work well with single-sample calling. giab was generated from multiple na12878 call sets. it is potentially biased against new callers and biased towards easier regions that can be called by the existing callers. for example, the gatk, which is overly good and is worrying. we turned to the chm1-na12878 dataset for an unbiased evaluation . in this evaluation, fermikit produces calls of higher specificity at the cost of sensitivity. this is probably because fermikit is less powerful in repetitive or duplicated regions or regions affected by systematic artefacts. nonetheless, in wellbehaved regions that are outside unimask, the loss of sensitivity is minor. the gain in precision is significant if we consider that there may be 520 k real heterozygous snps in chm1 , which should not be counted as fps. fermikit performs well in calling long deletions . while it does not use read pairs, it achieves comparable sensitivity and higher specificity in comparison to the popular tools. fermikit also called 480 insertions over 100 bp and identified multiple kb-long contigs having poor alignments to grch37 but nearly perfect alignment to a pacbio assembly of chm1 (ac:gca_001007805.1). we also mapped the chm1 fermikit unitigs to the pacbio assembly and called 71 long deletions, 11 insertions and 262 other events. as pacbio assemblies are generally of higher quality, these numbers give a rough estimate on the number potential false positives of fermi on a haploid dataset.  
