sequence analysis batmis: a fast algorithm for k-mismatch mapping motivation: second-generation sequencing (sgs) generates millions of reads that need to be aligned to a reference genome allowing errors. although current aligners can efficiently map reads allowing a small number of mismatches, they are not well suited for handling a large number of mismatches. the efficiency of aligners can be improved using various heuristics, but the sensitivity and accuracy of the alignments are sacrificed. in this article, we introduce basic alignment tool for mismatches (batmis)an efficient method to align short reads to a reference allowing k mismatches. batmis is a burrowswheeler transformation based aligner that uses a seed and extend approach, and it is an exact method. results: benchmark tests show that batmis performs better than competing aligners in solving the k-mismatch problem. furthermore, it can compete favorably even when compared with the heuristic modes of the other aligners. batmis is a useful alternative for applications where fast k-mismatch mappings, unique mappings or multiple mappings of sgs data are required.second-generation sequencing (sgs) technologies generate a high volume of sequencing data economically and this abundance of data has introduced new possibilities to genomic studies. applications such as whole-genome sequencing , gene expression profiling and chipseq have benefited from it. all these applications need to map the sgs reads to a reference genome. due to the differences between the sampled genome and the reference genomes and the errors introduced during the sequencing process, the mapping needs to be done allowing a reasonable number of errors. mapping sgs reads in general require the ability to map indels. however, for platforms like illumina and solid, most of the reads can be aligned allowing mismatches only. in fact, some popular aligners like bowtie only the authors wish it to be known that, in their opinion, the first two authors should be regarded as joint first authors. to whom correspondence should be addressed. consider mismatches in alignment, while many others consider only mismatches by default . there are many experiments where a large number of mismatches are allowed, sometimes along with indels . therefore, the k-mismatch problem, i.e. mapping a short read allowing k-mismatches to a reference genome, is an interesting problem in bioinformatics. although the general k-mismatch problem can be solved heuristically with generic aligners like blast or exactly with aligners like bwt-sw , they are not practical solutions to handle tens of millions of reads produced by sgs. therefore, specialized aligners for short read mapping are needed and the existing aligners can be broadly categorized into two classes. the first class uses a variety of hashing methods or the indexing data structure bwt to index the reference genome . others use hashing methods to index the reads . then, by enumerating possible mismatch patterns, the reads are aligned onto the genome. when the number of mismatches is not high, these aligners are very efficient. however, the running time will increase rapidly when the number of mismatches increases. the hashing-based methods become slow since they need to look up many hash table entries as the number of allowed mismatches increases. bwt-based aligners, since they simulate suffix/prefix tree traversal, become slow due to the rapid increase of branches that needs to be traversed as the number of mismatches increases. as shown in section 3, the current aligners are slow or inadequate to handle even moderate numbers of mismatches. to overcome the slowdown with large mismatches, aligners use various heuristic methods. a common solution is to use seeding methods [e.g. bwa, bowtie and eland (. in these methods, selected seed regions of a read are aligned to the reference allowing a small number of mismatches and these alignments are extended allowing k mismatches. some specialized methods like razers can guarantee to find a given percentage of correct alignments. these methods cut down the alignment time dramatically. however, applying these heuristics to solve the k-mismatch problem will result in a loss of sensitivity and accuracy. different types of experiments require different types of mappings. the most basic type of alignment reports the first hit of a read satisfying a given mismatch threshold. however, in some experiments, hits are required to satisfy some form of a uniqueness criterion. for example, in chip-seq experiments, scientists might prefer to map reads uniquely for better accuracy. other situations require multiple hits for each read. for example, rna-seq pipelines like tophat need an external aligner tothere are a vast number of sequence aligners that can perform exact k-mismatch alignment. different aligners have different policiesfairly, we use datasets without uncalled bases. we test each programs ability to report the least mismatch hits, the unique hits and multiple hits. by the least mismatch hit of a read r in the reference t , we mean any position i such that d(r,t [i..i+r1]) k, and for any other position j we havethe solution for the k-mismatch mapping is important to secondgeneration sequencing. we introduced a new algorithm batmis that can solve the k-mismatch problem exactly and efficiently. we checked the ability to find least mismatch hits, unique hits and multiple hits of some of the current state of the art aligners. our results show that some aligners cannot reliably map reads with a large number of mismatches. on the other hand, batmis was able to recover all the hits and was faster. finally, batmis is faster or has a comparable performance with the heuristic methods of other aligners. these results show that batmis is a robust aligner that performs well at all mismatch thresholds. one limitation of batmis is that it cannot handle paired-end reads and indels. we believe that batmis is a useful alternative for mapping sgs reads when we want to perform multiple mapping, unique mapping or when we want to tolerate a large number of mismatches.  
