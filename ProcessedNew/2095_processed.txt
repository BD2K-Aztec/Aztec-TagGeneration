gorpipe: a query tool for working with sequence data based on a genomic ordered relational (gor) architecture motivation: our aim was to create a general-purpose relational data format and analysis tools to provide an efficient and coherent framework for working with large volumes of dna sequence data. results: for this purpose we developed the gorpipe software system. it is based on a genomic ordered architecture and uses a declarative query language that combines features from sql and shell pipe syntax in a novel manner. the system can for instance be used to annotate sequence variants, find genomic spatial overlap between various types of genomic features, filter and aggregate them in various ways. availability and implementation: the gorpipe software is freely available for non-commercial academic usage and can be downloaded from www.nextcode.com/rapid advances in high-throughput sequencing technology have introduced formidable data management challenges for bioinformaticians. conventional relational database management systems (rdbms) are ill suited to the task of dealing with high volume of sequence reads and sequence variation data, partly because of their requirements for fine-grained transactions and partly because of their legacy command set and data structures. in the field of bioinformatics, the exodus from the on-hand relational databases has introduced a myriad of specialized tools and file formats, that are often incompatible, causing much computation and io being spent on data conversions and developers time to master a large set of disparate tools.the work presented here originates over 5 years back within decodes large scale population based sequencing project in iceland . the aim was to create generalpurpose relational data format and analysis tools in order to be able to annotate sequence variants, find genomic overlap between various types of features, filter and aggregate them in various ways. essentially, a replacement for the conventional rdbms; capable of handling sequence and variation data from hundreds of thousand samples and analyze them in the context of other genomic features. having worked with very large snp genotype datasets in the past, our key observation was that in order to support many of the envisioned usage scenarios, such as range queries, data joins and aggregation, we would need a genomic ordered data architecture, where the analysis algorithms largely treat the input data as ordered streams.furthermore, for on-going sequence analysis, such as in clinical practice or in very large research projects, where practically unlimited number of variations is captured with modern sequencing technology, sparse data formats are needed to represent the sequence variations, as compared to the finite grid structures used for chip-based snps in the gwas era. rather than using the convention of accessing the data via an index, based on an id scheme such as rsids, the variation data has to be identified and accessed solely based on its position and the sequence difference from a particular reference genome build. in order to achieve the above, we developed a system based on a genomic ordered relational architecture; a gor format and a query system, using a declarative relational query language, which syntax is a hybrid of unix shell command pipe syntax and sql. by design, our system works only for the analysis downstream of the sequence read alignment step, and while it does incorporate some functions for variation calling, the primary focus has been to develop query tools for tertiary analysis. while the gor data format shares many features with other earlier formats such as bed and bam and the more general purpose format tabix , it differs by being an index-free tabular storage format, where the first two columns representing the genomic position must be consistently ordered to allow for a binary-like seek. similarly, when it comes to the data layout, we emphasize relational normalization against de-normalization and columnar storage against excessive usage of attribute-value columns. this we do based on the same arguments that have been extensively used in the literature on rdbms when preaching good relational schema designs for ease of data updates and querying. as to be expected, our gorpipe program overlaps with many tools that have been developed in recent years such as bedtools , galaxy , vcftools , gatk , annovar and snpeff/snpsift (, b) to name few. for instance, many of these tools include features for intersecting and annotating variation data. our design is, however, very different in the sense that it is more of a query system or a language based approach. in this regard, it has similarities with the work on the genome query language (gql) . our approach does indeed follow the unix design philosophy of combining many small sharp tools with clear and simple interfaces. that being said, we made a conscious decision not to implement the system using linux shell commands and rely on the operating systems pipe mechanism, although we also recognized many benefits of using that approach. rather, we implemented our own multi-threaded command pipe framework, which runs in a single jvm instance, allowing us to create lightweight pipes with full control. this enables us to create efficient queries consisting of a very high number of commands (pipe steps) and importantly, to create declarative and nested streams which are seekable, unlike regular process substitutions in shells. this allows us also to optimize the query execution plan, although our current implementation does nowhere near exhaust the possibilities on that frontier. in the rest of this paper we introduce the gor architecture, briefly describe our tab-delimited storage format and explain how other genomic ordered tabular formats can be used with our system. to do this, we introduce the basic gor command, which reads the data from one or more files. we also introduce gor tables (dictionaries), which provide a relational abstraction to equivalent data in multiple files. we then give an informal description of the gor query language. a formal definition of the syntax and a detailed implementation description is, however, outside the scope of this work. rather, we like to demonstrate the unique nature of the gorpipe system and some of its commands through selected examples, something we think is more intuitive and valuable for practicing bio-informaticians. additionally, we briefly describe a related nor syntax, for non-ordered relational data, which together with the gor syntax, provides a powerful framework for working with both clinical and genetic data.in this paper, we have presented a software system developed around genomic ordered relations and a novel declarative query language. the syntax combines in a novel manner features from both unix shell commands and sql. as with most new programming and query languages, it is not so much a question of enabling something that wasnt possible before, but rather, to bring forth an elegant language which allows a good data abstraction, promotes and facilitates efficient query patterns. we do this by combining relational data abstraction patterns from the rdbms world with pipe shell syntax to implement relational operators. as we show, this flavour of query syntax is not limited to ordered genomic data and is also very convenient for time ordered data or generic relational data. indeed, since each command is isolated syntactically, we find this type of language structure in many ways easier to extend and work with than languages such as sql. here, we have demonstrated the versatile nature of our syntax to express complex queries. the gorpipe system is also easily integrated into bash pipe commands or python scripts. thus, if the expressive power of our declarative gorpipe syntax is exhausted, one can mix it with imperative programming languages. while the relational concepts are not new, our implementation is very different from existing rdbms. it is based on a genomic ordered streaming architecture which is better suited to deal with the high volume of sequence data which many sites are just starting to grapple with. just like sql, our gorpipe command set goes beyond operations that can be mapped to conventional relational algebra and many of the gorpipe commands have similarity with the more recently introduced sql windowing functions. unlike in sql, for simplicity and performance reasons, gorpipe only supports a single genomic ordering scheme. we do indeed find that our system performs quite well, although we have yet not undertaken a formal comparison study. for an example, in the variant effect prediction example, which we provide in section 1.3 in the supplementary material, we see performance which is ten times faster than the comparison. also, using version 2. 10.1 of bedtools, an intersection of a dbsnp.bed table against itself with the -sorted option, returns over 118 million rows in 3:36 while the same type of gorpipe query performing a-snpsnp join on equivalent gorz file returns the same number of rows in 3:25. an informal performance comparison between the file formats gorz and tabix files, in section 1.5 in the supplementary material, shows that gorz provides almost two times better streaming efficiency for gorpipe than the latest java implementation of tabix and equivalent seek performance. although our simple approach of using a binary-like search, as compared to using something like an r-tree structure, may not be as well suited for data files where there are features with very different segment sizes, we argue that features of unlike nature, e.g. due to very different size categories, are indeed better split up into separate tables where appropriate-maxseg options can be applied, since this allows for better streaming utilization in range queries. this approach can indeed also be applied on the physical file level, regardless of whether the data is stored in a single file or a collection of files. as to be expected, some of the language features in gorpipe have been introduced elsewhere in similar form, although not in as coherent manner. recently, it has been brought to our attention, by one of the reviewers, that support for named columns has for instance been introduced in bioawk, an extension of awk. motivated by the group by clause in sql, we introduced the-gc option in our aggregate commands as well as some other commands where we think grouping is relevant. it turns out that similar grouping option can be found in the command line utility datamash. the fact that gorpipe supports a fork write to simultaneously output data to multiple files (partitions) and many commands which support grouping (-gc) and equi-join options (-xl,-xr), makes it easy to express queries that process multiple samples and share the overhead of accessing non-sample reference data for annotations or filtering. the declarative nature of our syntax means that there is room for many additional optimizations behind the scenes. this may involve changing the order of commands execution and predicate push-down, combining command steps, use of adaptive buffer sizes, fine tuning of the memory model and rely on more powerful iterator abstraction in our implementation. also, the use of more metadata and more sophisticated query optimization may eliminate the need for the-maxseg option in the genome spatial joins. on the near term roadmap are features to allow users to create new commands and functions, leveraging dynamic class loading, based on any jvm language such as scala, jython and renjin r. we also foresee an integration with the hadoop stack, including the use of hdfs, parquet columnar storage and drivers relying on sparksql . finally, we are working on an extension of the gorpipe system with a full blown elastic cloud based database engine with support for data partition and distributed computing.conflict of interest: none declared.  
