gkmsvm: an r package for gapped-kmer svm we present a new r package for training gapped-kmer svm classifiers for dna and protein sequences. we describe an improved algorithm for kernel matrix calculation that speeds run time by about 2 to 5-fold over our original gkmsvm algorithm. this package supports several sequence kernels, including: gkmsvm, kmer-svm, mismatch kernel and wildcard kernel.we recently introduced a gapped-kmer-svm classifier (gkmsvm) to detect functional sequence elements in regulatory dna which has been applied to interpret a wide range of genomic datasets . while we released a version of our earlier kmer-svm as a webserver , gkmsvm was only released as c source code. here, we present an r package, gkmsvm-r, with several improvements to facilitate easier implementation and broader use. our original gkmsvm-1.3 implementation used a tree algorithm to compute the kernel matrix (. in this paper, we describe a new algorithm, idl-bound, that speeds up kernel matrix computation. we have implemented the algorithm in c and our r package is easily accessible on different platforms. our package also includes fast implementations of other kernels . we refer the c code implementing the faster idl kernel calculation as gkmsvm-2.0.shows an overview of the gkmsvm analysis pipeline. given two sets of sequences, the goal is to build a predictive model to classify the two sets. for example, in a gkmsvm is trained to detect regulatory dna elements active in a cell type by using chromatin accessible dna sequences as the positive set and a set of gc matched inaccessible dna sequences as negative set. the model then can score and predict the accessibility of any dna sequence. the first step is to build the kernel matrix (the pairwise similarity scores for all the sequences in the positive and negative sets). this is done using gkmsvm_kernel function: gkmsvm_kernel(posfn, negfn, kernelfn); where posfn and negfn are the input file names for the positive and negative sets (fasta format) and kernelfn is the output file name for the kernel matrix. the second step is to train the svm model, using: gkmsvm_train(kernelfn, posfn, negfn, svmfnprfx);where svmfnprfx is the output file name prefix for the svm model (support vectors). finally to classify/score a sequence, gkmsvm_classify is used: gkmsvm_classify(testfn, svmfnprfx, outfn);to evaluate the algorithm performance, we applied it to ctcf and ep300 datasets described in .shows running times for different values of l and d. we observe an average improvement of two fold using a single thread and up to 20-fold using 8 threads. ls-gkm , designed for training on very large datasets, is typically two times slower. with the faster idl algorithm we were also able optimize the svm c parameter for the 467 chip-seq datasets analyzed in . we reproduce the results of gkmsvm-1.3 with gkmsvm-r when c 1, and when c is optimized, as shown in, there is minimal improvement. we therefore recommend running with c 1.  
