fast and accurate long-read alignment with burrowsâ€“wheeler transform motivation: many programs for aligning short sequencing reads to a reference genome have been developed in the last 2 years. most of them are very efficient for short reads but inefficient or not applicable for reads 200 bp because the algorithms are heavily and specifically tuned for short queries with low sequencing error rate. however, some sequencing platforms already produce longer reads and others are expected to become available soon. for longer reads, hashing-based software such as blat and ssaha2 remain the only choices. nonetheless, these methods are substantially slower than short-read aligners in terms of aligned bases per unit time. results: we designed and implemented a new algorithm, burrows-wheeler aligners smith-waterman alignment (bwa-sw), to align long sequences up to 1 mb against a large sequence database (e.g. the human genome) with a few gigabytes of memory. the algorithm is as accurate as ssaha2, more accurate than blat, and is several to tens of times faster than both. availability: http://biofollowing the development of sensitive local alignment software, such as fasta and blast around 1990, a new generation of faster methods to find dna sequence matches was developed since 2000, including megablast , ssaha2 , blat and patternhunter , greatly speeding up matching capillary sequencing reads against a large reference genome. when new sequencing technologies arrived that generated millions of short (100 bp) reads, a variety of new algorithms were developed which were 101000 times faster, including soap , maq , bowtie and bwa . however, roche/454 sequencing technology has already produced reads 400 bp in production, illumina gradually increases read length 100 bp, and pacific bioscience generates 1000 bp reads in early testing . reads coming from the new sequencing technologies are not short any more, which effectively rules out many of the new aligners exclusively designed for reads to whom correspondence should be addressed. no longer than 100 bp. efficiently aligning long reads against a long reference sequence like the human genome poses a new challenge to the development of alignment tools. long-read alignment has different objectives from short-read alignment. first, in short-read alignment, we would usually like to align the full-length read to reduce the reference bias caused by the mismatches toward the ends of the read. given this requirement, we can design spaced seed templates spanning the entire read , or quickly filter out poor matches, for example, by applying q-gram filtration or by bounding the search process , and thus accelerate the alignment. in long-read alignment, however, we would prefer to find local matches because a long read is more fragile to structural variations and misassemblies in the reference but is less affected by the mismatches close to the ends of a read. secondly, many short-read aligners are only efficient when doing ungapped alignment or allowing limited gaps, e.g. a maximum of one gap. they cannot find more gaps or the performance quickly degrades when they are tuned for this task. long-read aligners, however, must be permissive about alignment gaps because indels occur more frequently in long reads and may be the dominant source of sequencing errors for some technologies such as 454 and pacific bioscience. when considering algorithms to speed-up long-read alignment, hash table indexing as is used in most current software is not the only choice.found a smithwaterman-like dynamic programming that can be applied between a query sequence and the suffix tree of the reference, effectively aligning the query against each subsequence sampled from the suffix tree via a top-down traversal. as on a suffix tree identical sequences are collapsed on a single path, time is saved by avoiding repeated alignment of identical subsequences.furthered this idea by implicitly representing the suffix tree with an fm-index , which is based on the burrowswheeler transform (bwt;), to achieve a small memory footprint. their new algorithm, bwt-sw, is able to deliver identical results to the standard smithwaterman alignment, but thousands of times faster when aligning against the human genome sequence. while bwt-sw is still slower than blast on long query sequences, it finds all matches without heuristics. one can imagine that introducing heuristics would further accelerate bwt-sw. our bwa-sw algorithm follows this route. to some extent, bwa-sw, as well as bwt-sw, also follows the seed-and-extend paradigm. but different from blat and ssaha2,page: 590 589595bwa-sw is an efficient algorithm for aligning a query sequence of a few hundred base pairs or more against a long reference genome. its sensitivity and specificity tend to be higher given a long query or a query with low error rate, and on such query sequences, the accuracy of bwa-sw is comparable with the most accurate aligner so far. furthermore, bwa-sw is able to detect chimera, potentially caused by structural variations or reference misassemblies, which may pose a challenge to blat and ssaha2. bwa-sw, blat and ssaha2 all follow the seed-and-extend paradigm. the major difference comes from the seeding strategy. blat and ssaha2 identify short exact matches as seeds, typically of length 11 or 12 bp. for k-mer seeding between two sequences of length l and l, respectively, the expected number of seeds is l l/4 k , or of the order of 10 5 for alignment against the human genome. extending these seeds each with the smithwaterman algorithm is expensive. to reduce unnecessary seed extension, both blat and ssaha2 use non-overlapping seeds by default and require multiple seed matches, which should work well for random sequences, but still involves many seed extensions in highly repetitive regions. bwa-sw resolves this issue by using a few long gapped seeds in unique regions. on real biological data, it saves many unnecessary seed extensions and leads to a better overall performance. however, to reduce time when identifying long seeds, bwa-sw only maintains a very small fraction of the dynamic programming matrix, which may miss all seeds for true matches. this heuristic is the major source of alignment errors especially for short queries when there are only few valid unique seeds between the sequences to be aligned. on long alignments, fortunately, the chance of missing all seeds is small. we have shown bwa-sw works equally well as ssaha2. bwa-sw differs from bwt-sw in several aspects. first of all, bwt-sw guarantees to find all local matches, whereas bwa-sw is a heuristic algorithm which may miss true hits but is much faster. secondly, bwa-sw aligns two fm-indices while bwt-sw aligns one sequence and a fm-index. building a prefix dawg for the query sequences potentially helps to avoid repeatedly aligning identical substrings in the query, and thus improves the theoretical time complexity. thirdly, bwa-sw traverses the reference prefix trie in the inner loop while bwt-sw loops through the query sequence in the inner loop. without heuristics, the bwa-sw approach would hurt performance because we have to trade speed for memory in traversing the reference prefix trie, and it would be more efficient to traverse it in the outer loop. nonetheless, applying the z-best strategy requires to know the top-scoring reference nodes matching a query substring without finishing the dynamic programming and thus only works when the reference is traversed in the inner loop. fourthly, bwa-sw only reports alignments largely non-overlapping on the query sequence, while bwt-sw, like blast, reports all statistically significant alignments. bwa-sw retains key information of alignments and generates much smaller  
