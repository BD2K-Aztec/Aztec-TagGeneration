slidesort: all pairs similarity search for short reads motivation: recent progress in dna sequencing technologies calls for fast and accurate algorithms that can evaluate sequence similarity for a huge amount of short reads. searching similar pairs from a string pool is a fundamental process of de novo genome assembly, genome-wide alignment and other important analyses. results: in this study, we designed and implemented an exact algorithm slidesort that finds all similar pairs from a string pool in terms of edit distance. using an efficient pattern growth algorithm, slidesort discovers chains of common k-mers to narrow down the search. compared to existing methods based on single k-mers, our method is more effective in reducing the number of edit distance calculations. in comparison to backtracking methods such as bwa, our method is much faster in finding remote matches, scaling easily to tens of millions of sequences. our software has an additional function of single link clustering, which is useful in summarizing short reads for further processing. availability: executable binary files and c++ libraries are available atdue to the dramatic improvement of dna sequencing, it is required to evaluate sequence similarities among a huge amount of fragment sequences such as short reads. we address the problem of enumerating all neighbor pairs in a large string pool in terms of edit distance, where the cost of insertion, deletion and substitution is one. namely, given a set of n sequences of equal length , s 1 ,...,s n , the task is to find all pairs whose edit distance is at most d,it is conventionally called all pairs similarity search. all pairs search appears in important biological tasks. for example, it is required in finding seed matches in all pairs alignment necessary in sequence clustering . such alignments can then be used to detect and correct errors in short reads . in the first step of de novo genome assembly , short to whom correspondence should be addressed. reads are decomposed to k-mers, and suffixprefix matches of length k 1 are detected. in most cases, exact matches are employed due to time constraint. using approximate matches, the length of contigs can be extended, which leads to final assembly of better quality. this problem reduces to all pairs similarity search by collecting all k 1 prefixes and suffixes into a sequence pool. from the output, only prefixsuffix pairs are reported. basically, most popular methods solve the search problem by either of the following two approaches or a combination of them.(i) finding a common k-mer and verify the match . (ii) backtracking in an index structure (i.e. suffix array and fm-index) . the first type finds common k-mers in strings (i.e. seed match) and verify if two strings sharing the k-mer are neighbors indeed by extending the match with dynamic programming. it works perfectly well when the string is long enough. however, when strings are short and the threshold d is large, the length of shared k-mers falls so short that too many candidate pairs have to be verified. the second type stores the strings into an index structure, most commonly a suffix array. then, similar strings are found by traversing nodes of the corresponding suffix tree. this approach works fine if d is small, e.g. d 2, and employed in state-of-the-art short read mapping tools such as bwa , bowtie and soap2 . however, it becomes rapidly infeasible as d grows larger, mainly because the complexity is exponential to d and no effective pruning is known. eland and seqmap decompose sequences into blocks and use multiple indices to store all k-concatenations of blocks. obviously, it requires much more memory compared with bwa, which would be problematic in many scenarios. multisorting uses multiple substring matches to narrow down the search effectively, but it can find neighbors in terms of hamming distance only. our method termed slidesort finds a chain of common substrings by an efficient pattern growth algorithm, which has been successfully applied in data mining tasks such as itemset mining . a pattern corresponds to a sequence of substrings. the space of all patterns is organized as a tree and systematically traversed. our method does not rely on any index structure to avoid storage overhead. instead, radix sort is employed to find equivalent strings during pattern growth. to demonstrate the correctness of our algorithm, the existence of a common substring chain in any neighbor pair is proved first. in addition, we deliberately avoid reporting the same pair multiple times by duplication checking. as a result, our method scales easily to 10 million sequences and ispage: 465 464470in this study, we developed a novel method that enumerates all similar pairs from a string pool in terms of edit distance. the proposed method is based on a pattern growth algorithm that can effectively narrow down the search by finding chains of common k-mers. using deliberate duplication checks, the number of edit distance calculations is reduced as much as possible. slidesort was evaluated on large datasets of short reads. as a result, it was about 103000 times faster than other index-based methods. all these results demonstrate practical merits of slidesort. one naturally arising question is if slidesort can be used for mapping. in fact, it is possible by storing the pattern tree in memory, and using it as an index structure. however, the index would cost too much memory for genome-scale data. what we learned from this study is that all pairs similarity search is essentially different from mapping in that one can employ pruning and dynamic memory management. thus, all pairs similarity search is not a subproblem of mapping and deserves separate treatment. in future work, we would like to implement slidesort with parallel computation techniques. recent progress in hardware technology enables end-users to use many types of parallel computing scheme such as sse and gpgpu. slidesort would be further improved by using these technologies.  
