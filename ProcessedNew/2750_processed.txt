long read alignment based on maximal exact match seeds motivation: the explosive growth of next-generation sequencing datasets poses a challenge to the mapping of reads to reference genomes in terms of alignment quality and execution speed. with the continuing progress of high-throughput sequencing technologies, read length is constantly increasing and many existing aligners are becoming inefficient as generated reads grow larger. results: we present cushaw2, a parallelized, accurate, and memory-efficient long read aligner. our aligner is based on the seed-and-extend approach and uses maximal exact matches as seeds to find gapped alignments. we have evaluated and compared cushaw2 to the three other long read aligners bwa-sw, bowtie2 and gassst, by aligning simulated and real datasets to the human genome. the performance evaluation shows that cushaw2 is consistently among the highest-ranked aligners in terms of alignment quality for both single-end and paired-end alignment, while demonstrating highly competitive speed. furthermore, our aligner shows good parallel scalability with respect to the number of cpu threads. availability: cushaw2, written in c++, and all simulated datasets are available at http://many biological applications of next-generation sequencing (ngs) require the alignment of large quantities of produced reads to a given reference genome. consequently, a wide variety of short read aligners have been developed in recent years. they can be classified into two categories according to their approaches to identify seeds: hash tables and prefix/suffix tries. maq , soap , shrimp and bfast are examples of the hash table approach. bowtie , bwa , soap2 and cushaw implement the concept of prefix/suffix tries using the burrowswheeler transform (bwt) and the fm-index . with the progress of ngs technologies, the length of produced reads continues to increase. unfortunately, many existing short read aligners are becoming inefficient as generated reads grow to a few hundred bp in length because of two reasons. first, they typically perform only ungapped alignments or gapped alignments allowing a very limited number of gaps (typically one gap). second, their speed degrades rapidly as the number of gaps increases. however, for long read alignment, more gaps must be allowed as indels will to whom correspondence should be addressed. occur more frequently. these new features of long read alignment thus motivate the design of new aligners with fast speed and high quality. in this article, we devise a new long read aligner based on the well-known seed-and-extend heuristic. this heuristic is based on the observation that significant alignments are likely to include homologous regions, containing exact or inexact short matches between the two sequences. it generally works in three steps. first, seeds, represented as short matches indicating highly similar regions, are generated between the query and the target sequences. secondly, these seeds are extended and refined under certain constraints, such as minimal percentage identity and extension length, to filter out noisy seeds. finally, more sophisticated algorithms, such as the needlemanwunsch algorithm or the smithwaterman (sw) algorithm , are employed to obtain the final alignments. several types of seeds have been proposed, including fixed-length seeds, maximal exact matches (mems), maximal unique matches (mums), and adaptive seeds . fixed-length seeds (k-mers) are the most widely used seed type. the simplest fixed-length seed is the exact k-mer match. some improvements have been suggested by allowing mismatches and gaps in the k-mers, including spaced seeds , and q-gram (a substring of q bases) filters . mems are exact matches that cannot be extended in either direction without allowing a mismatch. mums are inherently mems but require uniqueness in addition. an adaptive seed has a variable seed length, and also has a limitation on the number of seed occurrences in the target. recently, several long read aligners have been developed based on the seed-and-extend approach, including bwa-sw , bowtie2 , and gassst . bwa-sw, inspired by bwt-sw , identifies long gapped seeds by employing a prefix directed acyclic word graph (implicitly represented by an fm-index) to perform dynamic programming (dp). subsequently, it heuristically extends and refines the long gapped seeds to produce the final alignments. bowtie2 extracts all mismatch-allowable fixed-length seeds from a read using the bwt and then employs dp to identity alignments. gassst employs hash tables to find fixed-length seeds and employs multiple filters to remove noisy seeds, prior to the final dp-based alignment. this approach is effective to significantly reduce the number of noisy seeds, but also has the risk of discarding correct ones. in this article, we present a new long read aligner using mems as seeds. mems have been used for whole genome alignment . however, to the best of our knowledge, mems have not been used for ngs read alignment. our aligner employs memoryefficient versions of the bwt and fm-index data structures to generate mem seeds for each read. each seed defines a potential mapping read region on the genome. we then compute the optimal. pipeline of our aligner for the se and the pe alignment: the dashed lines show the additional two stages for the pe alignment local alignment score between the read and each potential mapping region and select the highest-scoring mapping region to produce the final alignment. in addition, our aligner provides support for paired-end (pe) alignment. for the pe alignment, a new seed-pairing approach is introduced with the intention to quickly determine the potential mapping regions of a pe read pair without performing alignments. furthermore, we employ vectorization and multithreading to achieve fast execution speed on standard multi-core cpus. the performance of our aligner is assessed and compared with bwa-sw, bowtie2 and gassst, by aligning simulated and real datasets to the human genome. the experimental results show that our aligner achieves favorable alignment quality, highly competitive speed and good parallel scalability with respect to the number of threads. this new aligner has been integrated into our software package cushaw. the first version of cushaw was designed for short read alignment (128-bp reads) using gpu computing. it uses mismatch-allowable fixed-length seeds and does not provide support for gapped alignments. we name the aligner presented in this article, cushaw2, to indicate the extended functionality.the performance of cushaw2 is compared with three other long read aligners: bwa-sw (v0.6.1), bowtie2 (v2.0.0-beta5) and gassst (v1.28). bwa-sw employs the default settings and bowtie2 also employs the default settings, except for the insert size related parameters for the pe alignment. gassst uses a minimal percentage identity of 90 and default settings for other parameters. cushaw2 requires the final alignment to have a percentage identity of 90 (default setting) and to include 80 (default setting) bases of the read.all the tests are conducted on a workstation with two six-core intel xeon x5650 2.67ghz cpus and 96 gb ram, running the linux operating system. the runtime of each aligner is measured in wall clock time for all tests, where the one-time construction time of the bwt and the fm-index is not counted in for cushaw2, bwa-sw and bowtie2. we use the recall and precision measures to assess all aligners using simulated datasets, where recall (precision) is calculated by dividing the number of reads that are correctly aligned by the total number of reads (the number of aligned read). if not explicitly specified, a read is deemed to be correctly aligned if the mapping position has a distance of 5 to the true position. for real datasets, we use the sensitivity measure, which is calculated by dividing the number of aligned reads by the total number of reads. gassst does not evaluate every seed to determine the best alignment for a single read. instead, it continues reporting identified alignments until reaching the maximal limit of the number of alignments. thus, we consider the best of all reported alignments as the final alignment of the read and discard the others. in addition, gassst does not provide the support for pe alignment and thus is only evaluated for se alignment. bwa-sw might report more than one alignment for a single read (in rare cases for not very long reads), where one alignment corresponds to one fragment of the read. since these fragment alignments are difficult to be distinguished and ranked, we take all of them into consideration.  
