data and text mining efficient comparison of sets of intervals with nc-lists motivation: high-throughput sequencing produces in a small amount of time a large amount of data, which are usually difficult to analyze. mapping the reads to the transcripts they originate from, to quantify the expression of the genes, is a simple, yet time demanding, example of analysis. fast genomic comparison algorithms are thus crucial for the analysis of the ever-expanding number of reads sequenced. results: we used nc-lists to implement an algorithm that compares a set of query intervals with a set of reference intervals in two steps. the first step, a pre-processing done once for all, requires time or logr q logq, where q and r are the sets of query and reference intervals. the search phase requires constant space, and time or q m, where m is the set of overlaps. we showed that our algorithm compares favorably with five other algorithms, especially when several comparisons are performed. availability: the algorithm has been included to smart, a versatile tool box for rna-seq analysis, freely available at http://urgi.versailles. inra.fr/tools/s-mart. the algorithm can be used for many kinds of data (sequencing reads, annotations, etc.) in many formats (gff3, bed, sam, etc.), on any operating system. it is thus readily useable for the analysis of next-generation sequencing data.with the advent of high-throughput sequencing, bioinformatics must analyze a large amount of data every day. modern sequencers can generate several hundred millions of sequences in a week for a price that is affordable to more and more labs. when a reference genome is available, the first task is to map the reads on the genome. many mapping tools are now available and research is active on this topic. for rna-seq, the second step may be the assignment of the mapped read to the transcripts they originate from, to estimate the expression of the genes . in general, the genomic comparison of the mapped reads with a reference annotation is the basis of many analyses: comparison of putative transcription factor binding sites with up-regulated genes ; detection of the single-nucleotide polymorphisms that are located in coding regions ; processing de novo transcript sequences to determine if they represent known or novel genes . these three examples involve a comparison of two annotations, and the problem has been addressed often. however, high-throughput sequencing, for the amount a data it produces, requires optimized algorithms for its analysis. most tools model the reads or annotation as intervals, or lists of intervals when different elements are modeled (exons, utrs, etc.). these intervals are considered along a reference, which usually is a chromosome or a scaffold. thus, comparing rnaseq reads with known transcripts reduces to comparing a set of query intervals (the reads) with a set of reference intervals (the exons of the transcripts). every efficient algorithm requires a dedicated data structure, such as an indexed database, an indexed flat file [such as a bam file (, an r-tree or nc-lists (nested containment lists) . these structures are usually built once during the pre-processing step, and can be reused for other analyses. although these structures may take considerable amount of time to build, the balance is usually favorable to pre-processed structures when several comparisons are performed, as the time spent for the comparison itself is considerably reduced. this observation leads to the conception of the bam format, now widely used in the bioinformatics community. with the notable exception of the fjoin algorithm , almost all the algorithms previously described only get all the reference intervals that overlap with one given query interval: most algorithms have been designed to retrieve all the intervals a user can see when he selects a given window in a genome browser . whereas these algorithms can be used to compare two sets by comparing each query interval, one after the other, with the reference intervals, we will show here how comparing the whole query set with the reference set can be more efficient. among the possible data structures presented to compare intervals, nc-lists are one of the most promising. nc-lists have been first described to retrieve all the reference intervals that overlap with a single interval. their structure is compact (a simple set of two arrays, l and h), the algorithm is fast in practice and the search phase requires only constant space, which is compulsory when handling several hundreds of millions of reads. the key idea of nc-lists is to perform binary dichotomic search on the list of reference intervals. but dichotomic search cannot be performed when some intervals are contained (or nested) inside other intervals, so nc-lists arrange intervals into liststhe l arraywhere no two intervals are nested. if some intervals are nested inside an ancestor interval, to whom correspondence should be addressed. the author 2013. published by oxford university press. all rights reserved. for permissions, please e-mail: journals.permissions@oup.com they are stored in a separate sublist using the h array (see). nc-lists can be built in linearithmic time [i.e. of the form on log n], using linear space (actually, only five integers are stored per interval). in their article, the authors presented a recursive dichotomic algorithm, equivalent to alg. 1, which uses nc-lists. it is claimed that getting all the reference intervals that overlap with a query interval could be done in time ologr m, where r is the reference set and m the pairs query/reference that overlap, but this is not accurate for some cases (see section 3.1). in this article, we will present an algorithm, which relies on nc-lists, and provides all the pairs query intervals/reference intervals that overlap. in a pre-processing step, the algorithm sorts the query and the reference intervals. it then builds a nc-list for the reference intervals. in the search phase, the algorithm compares every query interval with the reference intervals in time or q m. all together, the algorithm takes or logr q logq m. although the complexity of the whole algorithm is not better than already known algorithms, the runtime complexity is significantly lower than other constant-space algorithms. as such, our algorithm is especially useful when performing multiple comparisons on large sets of data, such as in an rna-seq data analysis.comparison to other implementations. we show here the results of our algorithm when compared with several other published methods. the first is a simple nc-list algorithm, as presented by, which does not use any information between two consecutive query intervals, hereafter called nc. the second method implements binning using an indexed sqlite table, hereafter called bin. we also implemented another flavor of this algorithm, called has, where the database has been replaced by a hash structure, such that the keys are the bins, and the values are lists of intervals. a forth algorithm is a binning table with segment tree, as described in segtor , called seg. we also added fjoin (fj), which scans the previously sorted query intervals and reference intervals simultaneously to find overlaps. our algorithm will simply be called new. among the presented algorithms, only bin, nc and new have constant space complexities. the other algorithms, has, seg (where the trees are stored in memory) and fj (which has a linear space complexity), are thus not likely to work on the large amount of data modern sequencers generate, with a standard computer. for instance, in our implementation, the has algorithm fills our ram (4 gb) when the reference dataset contains 30 m intervals. still, as they rely on in-memory data, they usually run faster on the sets they can handle. for a fair comparison of all the algorithms, and to exclude any bias that would originate from the choice of the programming language used by the different methods, we re-implemented all the algorithms carefully as described by the articles. all the algorithms have exactly the same input, output and functionalities, which reflect a usual mapped reads/annotation comparison study. first, strand is ignored (as many rna-seq data have no strand information, and most algorithms, when described in their original articles, do not deal with this case). second, each feature (hereafter a read or a transcript) is stored as a single interval. if an overlap is detected, the transcript is extracted from the input file (each method keeps track of the memory address of the features) and a second comparison is performed to check if the overlap is not located in the introns of the transcript, in which case the overlap is not reported. last, the output file is a gff3 file, which contains the query intervals that overlap with at least one reference element, and the list of the overlapping elements are added in the tags of the ninth field. these implementations, as well as the benchmark itself, are available in the smart toolbox. see supplementary materials for more information about these implementations. example on a real dataset. we downloaded three different publicly available rna-seq datasets: on yeast, fly and cress (available as srr014335, srr030228 and srr346552 datasets in geo). we mapped the reads with bowtie on the reference genome and we compared the mapped reads with the annotation (the genome sequence and the annotations are both available from the bowtie website). for each dataset, we reported the number of annotated transcripts (which are the reference intervals) as well as the number of reads (the query intervals). we used the six different algorithms previously mentioned. run-time results are shown in. the first columns give the characteristics of the datasets: number of reads, number of transcripts and number of overlaps. the following columns give the run-time spent by the algorithms when the genes are the reference and the reads are the query. as expected, has and the fj algorithms usually perform well on this dataset because the intervals are stored in memory.our algorithm is still among the fastest ones. however, the preprocessing of our algorithm is by far the slowest one (see supplementary data). this is a typical trade-off between run-time speed and pre-processing-time speed because the bin algorithm, the slowest algorithm in the comparison step, is the fastest algorithm in the pre-processing step among constant space methods.example on simulated datasets. we also generated several datasets to compare the algorithms in detail. the intervals ranged from 36 to 100 nt, the genome contained a single chromosome, ranging from 10 k to 2 m bp. the number of reference and query intervals varies from 100 to 100 k and 100 to 10 m elements, respectively. each configuration was generated five times. the results ingive the run-time results of each method. our algorithm is still the fastest among the constant space complexity algorithms. the fj required too much ram (more than 4 gb) to work on the largest datasets. regarding the pre-processing step, our algorithm is the slowest one (see supplementary information) but overall, the balance is always favorable to our algorithm after three comparisons when compared with the bin, the seg or the nc algorithm.insertion in smart. smart is a versatile tool box for the analysis of rna-seq data. it contains many useful tools for the comparison of rna-seq data with respect to a given annotation: number of reads for each transcript, distance distribution between the reads and the closest transcripts, discovery of previously unknown transcribed loci, etc. we added a new tool, called findoverlapsoptim, which implements the algorithm presented in this article. as a consequence, the algorithm can be used for many kinds of data (such as rna-seq reads, but also annotation of any feature) in many formats (gff3, bed, sam, etc.). we included a so-called nclist format in smart, which contains several nclists (one per chromosome), so that preprocessing can be done once for all. this pre-processing step can be performed using a separate tool called convertton clist. these files can be used as input file by most tools of the smart suite, much like bed or gff3 files. we also implemented a second version of our algorithm in the smart tool called compareoverlapping. this version is more flexible and accepts many different parameters: it may output the query elements only if they are collinear (or antisense) to the overlapping reference element, the query elements that are nested inside reference elements, the query elements that overlap the first 100 bp of the reference elements, etc. because compareoverlapping is much more flexible than findoverlapsoptim, it is also substantially slower. last, we added two versions of the much faster has algorithm in smart, to be used when the query or the reference have moderate sizes. the encapsulation of the algorithms within smart ensures that the presented method is not only a theoretical work, but also used in a tool that is readily available to biologists. for the computer scientists, we also implemented an api and executables in c so that they can embed them in their algorithms.the method presented here uses nc-lists and provides a fast algorithm that compares two large sets of intervals efficiently.to our knowledge, it is the first time that an algorithm with both linear time complexity and constant space complexity during the search phase is presented. this low run-time complexity comes at the cost of a high pre-processing time complexity, where the intervals should be sorted. however, this step is done only once and is far from untractable (the samtools sort algorithm is used routinely to sort bam files). as a result, the algorithm presented in this article is adapted to multiple comparisons. when we designed the algorithm, we had the idea in mind that it could help comparing features such as rna-seq data, which can amount to several hundreds millions reads. while this algorithm presents a theoretical interest by itself, we also encapsulated it in the smart tool box, which includes all the features to handle usual file formats. as a consequence, we hope this work will be useful for both computer scientists and biologists.  
